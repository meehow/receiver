/*!
 * SPDX-License-Identifier: Unlicense
 * This file was automatically generated by https://github.com/yt-dlp/ejs
 *
 * Bundled Dependencies:
 *
 * ---
 * Name: meriyah
 * Version: 6.1.4
 * License: ISC
 * Repository: git+https://github.com/meriyah/meriyah.git
 * Author: Kenny F. (https://github.com/KFlash)
 *
 * ISC License
 *
 * Copyright (c) 2019 and later, KFlash and others.
 *
 * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * ---
 * Name: astring
 * Version: 1.9.0
 * License: MIT
 * Repository: https://github.com/davidbonnet/astring.git
 * Author: David Bonnet <david@bonnet.cc>
 *
 * Copyright (c) 2015, David Bonnet <david@bonnet.cc>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * ---
 */
var lib = (function (exports) {
  'use strict';
  const unicodeLookup = ((compressed, lookup) => {
    const result = new Uint32Array(69632);
    let index = 0;
    let subIndex = 0;
    while (index < 2571) {
      const inst = compressed[index++];
      if (inst < 0) {
        subIndex -= inst;
      } else {
        let code = compressed[index++];
        if (inst & 2) code = lookup[code];
        if (inst & 1) {
          result.fill(code, subIndex, (subIndex += compressed[index++]));
        } else {
          result[subIndex++] = code;
        }
      }
    }
    return result;
  })(
    [
      -1, 2, 26, 2, 27, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64,
      3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0,
      4294966523, 3, 0, 4, 2, 16, 2, 65, 2, 0, 0, 4294836735, 0, 3221225471, 0,
      4294901942, 2, 66, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0,
      2683305983, 0, 2684354047, 2, 18, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2,
      0, 0, 608174079, 2, 0, 2, 60, 2, 7, 2, 6, 0, 4286611199, 3, 0, 2, 2, 1, 3,
      0, 3, 0, 4294901711, 2, 40, 0, 4089839103, 0, 2961209759, 0, 1342439375,
      0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2,
      2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2967484831, 0, 196559,
      0, 3594373100, 0, 3288319768, 0, 8469959, 0, 65472, 2, 3, 0, 4093640191,
      0, 660618719, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1616920031, 0,
      982991, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247022, 2, 71, 0,
      4284449919, 0, 851904, 2, 4, 2, 12, 0, 67076095, -1, 2, 72, 0, 1073741743,
      0, 4093607775, -1, 0, 50331649, 0, 3265266687, 2, 33, 0, 4294844415, 0,
      4278190047, 2, 20, 2, 137, -1, 3, 0, 2, 2, 23, 2, 0, 2, 10, 2, 0, 2, 15,
      2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77, 2, 0, 2, 78, 2, 0, 2,
      11, 0, 261632, 2, 25, 3, 0, 2, 2, 13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0,
      2, 2, 80, 0, 2151677951, 2, 29, 2, 9, 0, 909311, 3, 0, 2, 0, 814743551, 2,
      49, 0, 67090432, 3, 0, 2, 2, 42, 2, 0, 2, 6, 2, 0, 2, 30, 2, 8, 0,
      268374015, 2, 110, 2, 51, 2, 0, 2, 81, 0, 134153215, -1, 2, 7, 2, 0, 2, 8,
      0, 2684354559, 0, 67044351, 0, 3221160064, 2, 17, -1, 3, 0, 2, 2, 53, 0,
      1046528, 3, 0, 3, 2, 9, 2, 0, 2, 54, 0, 4294960127, 2, 10, 2, 6, 2, 11, 0,
      4294377472, 2, 12, 3, 0, 16, 2, 13, 2, 0, 2, 82, 2, 10, 2, 0, 2, 83, 2,
      84, 2, 85, 0, 12288, 2, 55, 0, 1048577, 2, 86, 2, 14, -1, 2, 14, 0,
      131042, 2, 87, 2, 88, 2, 89, 2, 0, 2, 34, -83, 3, 0, 7, 0, 1046559, 2, 0,
      2, 15, 2, 0, 0, 2147516671, 2, 21, 3, 90, 2, 2, 0, -16, 2, 91, 0,
      524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 3, 0, 2, 2, 28, 2, 16, 3, 0,
      2, 2, 17, 2, 0, -1, 2, 18, -16, 3, 0, 206, -2, 3, 0, 692, 2, 73, -1, 2,
      18, 2, 10, 3, 0, 8, 2, 93, 2, 133, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19, 2,
      94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2, 97, 2, 46, 2, 0, 0, 4351, 2, 0, 2, 9,
      3, 0, 2, 0, 67043391, 0, 3909091327, 2, 0, 2, 24, 2, 9, 2, 20, 3, 0, 2, 0,
      67076097, 2, 8, 2, 0, 2, 21, 0, 67059711, 0, 4236247039, 3, 0, 2, 0,
      939524103, 0, 8191999, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 67057663,
      3, 0, 349, 2, 103, 2, 104, 2, 7, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 32,
      -1, 0, 3774349439, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107, 3, 0, 10, 2,
      10, 2, 18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, 2, 25, 0, 1638399, 0, 57344,
      2, 109, 3, 0, 3, 2, 20, 2, 26, 2, 27, 2, 5, 2, 28, 2, 0, 2, 8, 2, 111, -1,
      2, 112, 2, 113, 2, 114, -1, 3, 0, 3, 2, 12, -2, 2, 0, 2, 29, -3, 0,
      536870912, -4, 2, 20, 2, 0, 2, 36, 0, 1, 2, 0, 2, 67, 2, 6, 2, 12, 2, 10,
      2, 0, 2, 115, -1, 3, 0, 4, 2, 10, 2, 23, 2, 116, 2, 7, 2, 0, 2, 117, 2, 0,
      2, 118, 2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2, 30, 2, 31, 2, 121,
      2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21, 2, 8, -2, 2, 125, 2, 30, 2, 32,
      -2, 2, 0, 2, 39, -2, 0, 4277137519, 0, 2269118463, -1, 3, 20, 2, -1, 2,
      33, 2, 38, 2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3, 0, 2, 2, 34, -1, 2, 0, 2,
      35, 2, 0, 2, 35, 2, 0, 2, 48, 2, 0, 0, 4294950463, 2, 37, -7, 2, 0, 0,
      203775, 2, 57, 0, 4026531840, 2, 20, 2, 43, 2, 36, 2, 18, 2, 37, 2, 18, 2,
      126, 2, 21, 3, 0, 2, 2, 38, 0, 2151677888, 2, 0, 2, 12, 0, 4294901764, 2,
      144, 2, 0, 2, 58, 2, 56, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 128, 2,
      39, 0, 3, -1, 2, 129, 2, 130, 2, 0, 0, 67045375, 2, 40, 0, 4226678271, 0,
      3766565279, 0, 2039759, 2, 132, 2, 41, 0, 1046437, 0, 6, 3, 0, 2, 0,
      3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0,
      1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 42, 2, 23, 2, 50, 2,
      11, 2, 61, 2, 38, -5, 2, 0, 2, 12, -3, 3, 0, 2, 0, 2147484671, 2, 134, 0,
      4190109695, 2, 52, -2, 2, 135, 0, 4244635647, 0, 27, 2, 0, 2, 8, 2, 43, 2,
      0, 2, 68, 2, 18, 2, 0, 2, 42, -6, 2, 0, 2, 45, 2, 59, 2, 44, 2, 45, 2, 46,
      2, 47, 0, 8388351, -2, 2, 136, 0, 3028287487, 2, 48, 2, 138, 0, 33259519,
      2, 49, -9, 2, 21, 0, 4294836223, 0, 3355443199, 0, 134152199, -2, 2, 69,
      -2, 3, 0, 28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50, -81, 2, 18, 3, 0,
      2, 2, 36, 3, 0, 33, 2, 25, 2, 30, 3, 0, 124, 2, 12, 3, 0, 18, 2, 38, -213,
      2, 0, 2, 32, -54, 3, 0, 17, 2, 42, 2, 8, 2, 23, 2, 0, 2, 8, 2, 23, 2, 51,
      2, 0, 2, 21, 2, 52, 2, 139, 2, 25, -13, 2, 0, 2, 53, -6, 3, 0, 2, -4, 3,
      0, 2, 0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 54,
      3, 0, 38, 2, 30, 2, 55, 2, 34, -278, 2, 140, 3, 0, 9, 2, 141, 2, 142, 2,
      56, 3, 0, 11, 2, 7, -72, 3, 0, 3, 2, 143, 0, 1677656575, -130, 2, 26, -16,
      2, 0, 2, 24, 2, 38, -16, 0, 4161266656, 0, 4071, 0, 15360, -4, 2, 57, -13,
      3, 0, 2, 2, 58, 2, 0, 2, 145, 2, 146, 2, 62, 2, 0, 2, 147, 2, 148, 2, 149,
      3, 0, 10, 2, 150, 2, 151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 0,
      4294954999, 2, 0, -16, 2, 0, 2, 92, 2, 0, 0, 2105343, 0, 4160749584, 0,
      65534, -34, 2, 8, 2, 154, -6, 0, 4194303871, 0, 4294903771, 2, 0, 2, 60,
      2, 100, -3, 2, 0, 0, 1073684479, 0, 17407, -9, 2, 18, 2, 17, 2, 0, 2, 32,
      -14, 2, 18, 2, 32, -6, 2, 18, 2, 12, -15, 2, 155, 3, 0, 6, 0, 8323103, -1,
      3, 0, 2, 2, 61, -37, 2, 62, 2, 156, 2, 157, 2, 158, 2, 159, 2, 160, -105,
      2, 26, -32, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2, 10, 3, 0, 180,
      2, 161, 3, 0, 233, 2, 162, 3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10, -47, 3,
      0, 154, 2, 6, 3, 0, 130, 2, 25, -22250, 3, 0, 7, 2, 25, -6130, 3, 5, 2,
      -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64, -3, 0, 3168731136, 0,
      4294956864, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2,
      65, 2, 0, 2, 34, -1, 2, 18, 2, 66, -1, 2, 0, 0, 2047, 0, 4294885376, 3, 0,
      2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 25, 2, 67, 3, 0, 2, 0,
      131135, 2, 98, 0, 70256639, 0, 71303167, 0, 272, 2, 42, 2, 6, 0, 32511, 2,
      0, 2, 49, -1, 2, 99, 2, 68, 0, 4278255616, 0, 4294836227, 0, 4294549473,
      0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0,
      1577058304, 0, 1835008, 0, 4294688736, 2, 70, 2, 69, 0, 33554435, 2, 131,
      2, 70, 0, 2952790016, 0, 131075, 0, 3594373096, 0, 67094296, 2, 69, -1, 0,
      4294828e3, 0, 603979263, 0, 654311424, 0, 3, 0, 4294828001, 0, 602930687,
      0, 1610612736, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0,
      4227858435, 0, 4236247008, 2, 71, 2, 38, -1, 2, 4, 0, 917503, 2, 38, -1,
      2, 72, 0, 537788335, 0, 4026531935, -1, 0, 1, -1, 2, 33, 2, 73, 0, 7936,
      -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2,
      15, 2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77, 2, 0, 2, 78, 2, 0,
      2, 12, -1, 2, 25, 3, 0, 2, 2, 13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0, 2, 2,
      80, 0, 2147745791, 3, 19, 2, 0, 122879, 2, 0, 2, 9, 0, 276824064, -2, 3,
      0, 2, 2, 42, 2, 0, 0, 4294903295, 2, 0, 2, 30, 2, 8, -1, 2, 18, 2, 51, 2,
      0, 2, 81, 2, 49, -1, 2, 21, 2, 0, 2, 29, -2, 0, 128, -2, 2, 28, 2, 9, 0,
      8160, -1, 2, 127, 0, 4227907585, 2, 0, 2, 37, 2, 0, 2, 50, 0, 4227915776,
      2, 10, 2, 6, 2, 11, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 13, 2, 0, 2,
      82, 2, 10, 2, 0, 2, 83, 2, 84, 2, 85, -3, 2, 86, 2, 14, -3, 2, 87, 2, 88,
      2, 89, 2, 0, 2, 34, -83, 3, 0, 7, 0, 817183, 2, 0, 2, 15, 2, 0, 0, 33023,
      2, 21, 3, 90, 2, -17, 2, 91, 0, 524157950, 2, 4, 2, 0, 2, 92, 2, 4, 2, 0,
      2, 22, 2, 28, 2, 16, 3, 0, 2, 2, 17, 2, 0, -1, 2, 18, -16, 3, 0, 206, -2,
      3, 0, 692, 2, 73, -1, 2, 18, 2, 10, 3, 0, 8, 2, 93, 0, 3072, 2, 0, 0,
      2147516415, 2, 10, 3, 0, 2, 2, 25, 2, 94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2,
      97, 2, 46, 0, 4294965179, 0, 7, 2, 0, 2, 9, 2, 95, 2, 9, -1, 0,
      1761345536, 2, 98, 0, 4294901823, 2, 38, 2, 20, 2, 99, 2, 35, 2, 100, 0,
      2080440287, 2, 0, 2, 34, 2, 153, 0, 3296722943, 2, 0, 0, 1046675455, 0,
      939524101, 0, 1837055, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 7, 3, 0,
      349, 2, 103, 2, 104, 2, 7, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 32, -1, 0,
      2700607615, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107, 3, 0, 10, 2, 10, 2,
      18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, -3, 2, 109, 3, 0, 3, 2, 20, -1, 3,
      5, 2, 2, 110, 2, 0, 2, 8, 2, 111, -1, 2, 112, 2, 113, 2, 114, -1, 3, 0, 3,
      2, 12, -2, 2, 0, 2, 29, -8, 2, 20, 2, 0, 2, 36, -1, 2, 0, 2, 67, 2, 6, 2,
      30, 2, 10, 2, 0, 2, 115, -1, 3, 0, 4, 2, 10, 2, 18, 2, 116, 2, 7, 2, 0, 2,
      117, 2, 0, 2, 118, 2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2, 30, 2,
      31, 2, 121, 2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21, 2, 8, -2, 2, 125, 2,
      30, 2, 32, -2, 2, 0, 2, 39, -2, 0, 4277075969, 2, 30, -1, 3, 20, 2, -1, 2,
      33, 2, 126, 2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3, 0, 2, 2, 34, -1, 2, 0, 2,
      35, 2, 0, 2, 35, 2, 0, 2, 50, 2, 98, 0, 4294934591, 2, 37, -7, 2, 0, 0,
      197631, 2, 57, -1, 2, 20, 2, 43, 2, 37, 2, 18, 0, 3, 2, 18, 2, 126, 2, 21,
      2, 127, 2, 54, -1, 0, 2490368, 2, 127, 2, 25, 2, 18, 2, 34, 2, 127, 2, 38,
      0, 4294901904, 0, 4718591, 2, 127, 2, 35, 0, 335544350, -1, 2, 128, 0,
      2147487743, 0, 1, -1, 2, 129, 2, 130, 2, 8, -1, 2, 131, 2, 70, 0,
      3758161920, 0, 3, 2, 132, 0, 12582911, 0, 655360, -1, 2, 0, 2, 29, 0,
      2147485568, 0, 3, 2, 0, 2, 25, 0, 176, -5, 2, 0, 2, 17, 0, 251658240, -1,
      2, 0, 2, 25, 0, 16, -1, 2, 0, 0, 16779263, -2, 2, 12, -1, 2, 38, -5, 2, 0,
      2, 133, -3, 3, 0, 2, 2, 55, 2, 134, 0, 2147549183, 0, 2, -2, 2, 135, 2,
      36, 0, 10, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 536871935,
      2, 18, 2, 0, 2, 42, -6, 2, 0, 0, 1, 2, 59, 2, 17, 0, 1, 2, 46, 2, 25, -3,
      2, 136, 2, 36, 2, 137, 2, 138, 0, 16778239, -10, 2, 35, 0, 4294836212, 2,
      9, -3, 2, 69, -2, 3, 0, 28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50,
      -81, 2, 18, 3, 0, 2, 2, 36, 3, 0, 33, 2, 25, 0, 126, 3, 0, 124, 2, 12, 3,
      0, 18, 2, 38, -213, 2, 10, -55, 3, 0, 17, 2, 42, 2, 8, 2, 18, 2, 0, 2, 8,
      2, 18, 2, 60, 2, 0, 2, 25, 2, 50, 2, 139, 2, 25, -13, 2, 0, 2, 73, -6, 3,
      0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 107, -2, 0, 11, 3, 0, 191, 2, 54, 3,
      0, 38, 2, 30, 2, 55, 2, 34, -278, 2, 140, 3, 0, 9, 2, 141, 2, 142, 2, 56,
      3, 0, 11, 2, 7, -72, 3, 0, 3, 2, 143, 2, 144, -187, 3, 0, 2, 2, 58, 2, 0,
      2, 145, 2, 146, 2, 62, 2, 0, 2, 147, 2, 148, 2, 149, 3, 0, 10, 2, 150, 2,
      151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 2, 153, -57, 2, 8, 2, 154, -7,
      2, 18, 2, 0, 2, 60, -4, 2, 0, 0, 1065361407, 0, 16384, -9, 2, 18, 2, 60,
      2, 0, 2, 133, -14, 2, 18, 2, 133, -6, 2, 18, 0, 81919, -15, 2, 155, 3, 0,
      6, 2, 126, -1, 3, 0, 2, 0, 2063, -37, 2, 62, 2, 156, 2, 157, 2, 158, 2,
      159, 2, 160, -138, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2, 10, 3, 0,
      180, 2, 161, 3, 0, 233, 2, 162, 3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10,
      -47, 3, 0, 154, 2, 6, 3, 0, 130, 2, 25, -28386,
    ],
    [
      4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726,
      4294903807, 268435455, 2147483647, 1048575, 1073741823, 3892314111,
      134217727, 1061158911, 536805376, 4294910143, 4294901759, 32767,
      4294901760, 262143, 536870911, 8388607, 4160749567, 4294902783,
      4294918143, 65535, 67043328, 2281701374, 4294967264, 2097151, 4194303,
      255, 67108863, 4294967039, 511, 524287, 131071, 63, 127, 3238002687,
      4294549487, 4290772991, 33554431, 4294901888, 4286578687, 67043329,
      4294705152, 4294770687, 67043583, 1023, 15, 2047999, 67043343, 67051519,
      16777215, 2147483648, 4294902e3, 28, 4292870143, 4294966783, 16383,
      67047423, 4294967279, 262083, 20511, 41943039, 493567, 4294959104,
      603979775, 65536, 602799615, 805044223, 4294965206, 8191, 1031749119,
      4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095,
      4294905855, 2868854591, 1608515583, 265232348, 534519807, 2147614720,
      1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294909951,
      4286578688, 4294967292, 4294965759, 535511039, 4294966272, 4294967280,
      32768, 8289918, 4294934399, 4294901775, 4294965375, 1602223615,
      4294967259, 4294443008, 268369920, 4292804608, 4294967232, 486341884,
      4294963199, 3087007615, 1073692671, 4128527, 4279238655, 4294902015,
      4160684047, 4290246655, 469499899, 4294967231, 134086655, 4294966591,
      2445279231, 3670015, 31, 4294967288, 4294705151, 3221208447, 4294902271,
      4294549472, 4294921215, 4095, 4285526655, 4294966527, 4294966143, 64,
      4294966719, 3774873592, 1877934080, 262151, 2555904, 536807423, 67043839,
      3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103,
      4160749565, 4294934527, 4087, 2016, 2147446655, 184024726, 2862017156,
      1593309078, 268434431, 268434414, 4294901763, 4294901761,
    ],
  );
  const isIDContinue = (code) =>
    ((unicodeLookup[(code >>> 5) + 0] >>> code) & 31 & 1) !== 0;
  const isIDStart = (code) =>
    ((unicodeLookup[(code >>> 5) + 34816] >>> code) & 31 & 1) !== 0;
  function advanceChar(parser) {
    parser.column++;
    return (parser.currentChar = parser.source.charCodeAt(++parser.index));
  }
  function consumePossibleSurrogatePair(parser) {
    const hi = parser.currentChar;
    if ((hi & 64512) !== 55296) return 0;
    const lo = parser.source.charCodeAt(parser.index + 1);
    if ((lo & 64512) !== 56320) return 0;
    return 65536 + ((hi & 1023) << 10) + (lo & 1023);
  }
  function consumeLineFeed(parser, state) {
    parser.currentChar = parser.source.charCodeAt(++parser.index);
    parser.flags |= 1;
    if ((state & 4) === 0) {
      parser.column = 0;
      parser.line++;
    }
  }
  function scanNewLine(parser) {
    parser.flags |= 1;
    parser.currentChar = parser.source.charCodeAt(++parser.index);
    parser.column = 0;
    parser.line++;
  }
  function isExoticECMAScriptWhitespace(ch) {
    return (
      ch === 160 ||
      ch === 65279 ||
      ch === 133 ||
      ch === 5760 ||
      (ch >= 8192 && ch <= 8203) ||
      ch === 8239 ||
      ch === 8287 ||
      ch === 12288 ||
      ch === 8201 ||
      ch === 65519
    );
  }
  function toHex(code) {
    return code < 65 ? code - 48 : (code - 65 + 10) & 15;
  }
  function convertTokenType(t) {
    switch (t) {
      case 134283266:
        return 'NumericLiteral';
      case 134283267:
        return 'StringLiteral';
      case 86021:
      case 86022:
        return 'BooleanLiteral';
      case 86023:
        return 'NullLiteral';
      case 65540:
        return 'RegularExpression';
      case 67174408:
      case 67174409:
      case 131:
        return 'TemplateLiteral';
      default:
        if ((t & 143360) === 143360) return 'Identifier';
        if ((t & 4096) === 4096) return 'Keyword';
        return 'Punctuator';
    }
  }
  const CharTypes = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8 | 1024,
    0,
    0,
    8 | 2048,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8192,
    0,
    1 | 2,
    0,
    0,
    8192,
    0,
    0,
    0,
    256,
    0,
    256 | 32768,
    0,
    0,
    2 | 16 | 128 | 32 | 64,
    2 | 16 | 128 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 32 | 64,
    2 | 16 | 512 | 64,
    2 | 16 | 512 | 64,
    0,
    0,
    16384,
    0,
    0,
    0,
    0,
    1 | 2 | 64,
    1 | 2 | 64,
    1 | 2 | 64,
    1 | 2 | 64,
    1 | 2 | 64,
    1 | 2 | 64,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    1 | 2,
    0,
    1,
    0,
    0,
    1 | 2 | 4096,
    0,
    1 | 2 | 4 | 64,
    1 | 2 | 4 | 64,
    1 | 2 | 4 | 64,
    1 | 2 | 4 | 64,
    1 | 2 | 4 | 64,
    1 | 2 | 4 | 64,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    1 | 2 | 4,
    16384,
    0,
    0,
    0,
    0,
  ];
  const isIdStart = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0,
  ];
  const isIdPart = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0,
  ];
  function isIdentifierStart(code) {
    return code <= 127 ? isIdStart[code] > 0 : isIDStart(code);
  }
  function isIdentifierPart(code) {
    return code <= 127
      ? isIdPart[code] > 0
      : isIDContinue(code) || code === 8204 || code === 8205;
  }
  const CommentTypes = [
    'SingleLine',
    'MultiLine',
    'HTMLOpen',
    'HTMLClose',
    'HashbangComment',
  ];
  function skipHashBang(parser) {
    const { source: source } = parser;
    if (
      parser.currentChar === 35 &&
      source.charCodeAt(parser.index + 1) === 33
    ) {
      advanceChar(parser);
      advanceChar(parser);
      skipSingleLineComment(parser, source, 0, 4, parser.tokenStart);
    }
  }
  function skipSingleHTMLComment(parser, source, state, context, type, start) {
    if (context & 2) parser.report(0);
    return skipSingleLineComment(parser, source, state, type, start);
  }
  function skipSingleLineComment(parser, source, state, type, start) {
    const { index: index } = parser;
    parser.tokenIndex = parser.index;
    parser.tokenLine = parser.line;
    parser.tokenColumn = parser.column;
    while (parser.index < parser.end) {
      if (CharTypes[parser.currentChar] & 8) {
        const isCR = parser.currentChar === 13;
        scanNewLine(parser);
        if (isCR && parser.index < parser.end && parser.currentChar === 10)
          parser.currentChar = source.charCodeAt(++parser.index);
        break;
      } else if ((parser.currentChar ^ 8232) <= 1) {
        scanNewLine(parser);
        break;
      }
      advanceChar(parser);
      parser.tokenIndex = parser.index;
      parser.tokenLine = parser.line;
      parser.tokenColumn = parser.column;
    }
    if (parser.options.onComment) {
      const loc = {
        start: { line: start.line, column: start.column },
        end: { line: parser.tokenLine, column: parser.tokenColumn },
      };
      parser.options.onComment(
        CommentTypes[type & 255],
        source.slice(index, parser.tokenIndex),
        start.index,
        parser.tokenIndex,
        loc,
      );
    }
    return state | 1;
  }
  function skipMultiLineComment(parser, source, state) {
    const { index: index } = parser;
    while (parser.index < parser.end) {
      if (parser.currentChar < 43) {
        let skippedOneAsterisk = false;
        while (parser.currentChar === 42) {
          if (!skippedOneAsterisk) {
            state &= -5;
            skippedOneAsterisk = true;
          }
          if (advanceChar(parser) === 47) {
            advanceChar(parser);
            if (parser.options.onComment) {
              const loc = {
                start: { line: parser.tokenLine, column: parser.tokenColumn },
                end: { line: parser.line, column: parser.column },
              };
              parser.options.onComment(
                CommentTypes[1 & 255],
                source.slice(index, parser.index - 2),
                index - 2,
                parser.index,
                loc,
              );
            }
            parser.tokenIndex = parser.index;
            parser.tokenLine = parser.line;
            parser.tokenColumn = parser.column;
            return state;
          }
        }
        if (skippedOneAsterisk) {
          continue;
        }
        if (CharTypes[parser.currentChar] & 8) {
          if (parser.currentChar === 13) {
            state |= 1 | 4;
            scanNewLine(parser);
          } else {
            consumeLineFeed(parser, state);
            state = (state & -5) | 1;
          }
        } else {
          advanceChar(parser);
        }
      } else if ((parser.currentChar ^ 8232) <= 1) {
        state = (state & -5) | 1;
        scanNewLine(parser);
      } else {
        state &= -5;
        advanceChar(parser);
      }
    }
    parser.report(18);
  }
  var RegexState;
  (function (RegexState) {
    RegexState[(RegexState['Empty'] = 0)] = 'Empty';
    RegexState[(RegexState['Escape'] = 1)] = 'Escape';
    RegexState[(RegexState['Class'] = 2)] = 'Class';
  })(RegexState || (RegexState = {}));
  var RegexFlags;
  (function (RegexFlags) {
    RegexFlags[(RegexFlags['Empty'] = 0)] = 'Empty';
    RegexFlags[(RegexFlags['IgnoreCase'] = 1)] = 'IgnoreCase';
    RegexFlags[(RegexFlags['Global'] = 2)] = 'Global';
    RegexFlags[(RegexFlags['Multiline'] = 4)] = 'Multiline';
    RegexFlags[(RegexFlags['Unicode'] = 16)] = 'Unicode';
    RegexFlags[(RegexFlags['Sticky'] = 8)] = 'Sticky';
    RegexFlags[(RegexFlags['DotAll'] = 32)] = 'DotAll';
    RegexFlags[(RegexFlags['Indices'] = 64)] = 'Indices';
    RegexFlags[(RegexFlags['UnicodeSets'] = 128)] = 'UnicodeSets';
  })(RegexFlags || (RegexFlags = {}));
  function scanRegularExpression(parser) {
    const bodyStart = parser.index;
    let preparseState = RegexState.Empty;
    loop: while (true) {
      const ch = parser.currentChar;
      advanceChar(parser);
      if (preparseState & RegexState.Escape) {
        preparseState &= ~RegexState.Escape;
      } else {
        switch (ch) {
          case 47:
            if (!preparseState) break loop;
            else break;
          case 92:
            preparseState |= RegexState.Escape;
            break;
          case 91:
            preparseState |= RegexState.Class;
            break;
          case 93:
            preparseState &= RegexState.Escape;
            break;
        }
      }
      if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) {
        parser.report(34);
      }
      if (parser.index >= parser.source.length) {
        return parser.report(34);
      }
    }
    const bodyEnd = parser.index - 1;
    let mask = RegexFlags.Empty;
    let char = parser.currentChar;
    const { index: flagStart } = parser;
    while (isIdentifierPart(char)) {
      switch (char) {
        case 103:
          if (mask & RegexFlags.Global) parser.report(36, 'g');
          mask |= RegexFlags.Global;
          break;
        case 105:
          if (mask & RegexFlags.IgnoreCase) parser.report(36, 'i');
          mask |= RegexFlags.IgnoreCase;
          break;
        case 109:
          if (mask & RegexFlags.Multiline) parser.report(36, 'm');
          mask |= RegexFlags.Multiline;
          break;
        case 117:
          if (mask & RegexFlags.Unicode) parser.report(36, 'u');
          if (mask & RegexFlags.UnicodeSets) parser.report(36, 'vu');
          mask |= RegexFlags.Unicode;
          break;
        case 118:
          if (mask & RegexFlags.Unicode) parser.report(36, 'uv');
          if (mask & RegexFlags.UnicodeSets) parser.report(36, 'v');
          mask |= RegexFlags.UnicodeSets;
          break;
        case 121:
          if (mask & RegexFlags.Sticky) parser.report(36, 'y');
          mask |= RegexFlags.Sticky;
          break;
        case 115:
          if (mask & RegexFlags.DotAll) parser.report(36, 's');
          mask |= RegexFlags.DotAll;
          break;
        case 100:
          if (mask & RegexFlags.Indices) parser.report(36, 'd');
          mask |= RegexFlags.Indices;
          break;
        default:
          parser.report(35);
      }
      char = advanceChar(parser);
    }
    const flags = parser.source.slice(flagStart, parser.index);
    const pattern = parser.source.slice(bodyStart, bodyEnd);
    parser.tokenRegExp = { pattern: pattern, flags: flags };
    if (parser.options.raw)
      parser.tokenRaw = parser.source.slice(parser.tokenIndex, parser.index);
    parser.tokenValue = validate(parser, pattern, flags);
    return 65540;
  }
  function validate(parser, pattern, flags) {
    try {
      return new RegExp(pattern, flags);
    } catch {
      try {
        new RegExp(pattern, flags);
        return null;
      } catch {
        parser.report(34);
      }
    }
  }
  function scanString(parser, context, quote) {
    const { index: start } = parser;
    let ret = '';
    let char = advanceChar(parser);
    let marker = parser.index;
    while ((CharTypes[char] & 8) === 0) {
      if (char === quote) {
        ret += parser.source.slice(marker, parser.index);
        advanceChar(parser);
        if (parser.options.raw)
          parser.tokenRaw = parser.source.slice(start, parser.index);
        parser.tokenValue = ret;
        return 134283267;
      }
      if ((char & 8) === 8 && char === 92) {
        ret += parser.source.slice(marker, parser.index);
        char = advanceChar(parser);
        if (char < 127 || char === 8232 || char === 8233) {
          const code = parseEscape(parser, context, char);
          if (code >= 0) ret += String.fromCodePoint(code);
          else handleStringError(parser, code, 0);
        } else {
          ret += String.fromCodePoint(char);
        }
        marker = parser.index + 1;
      } else if (char === 8232 || char === 8233) {
        parser.column = -1;
        parser.line++;
      }
      if (parser.index >= parser.end) parser.report(16);
      char = advanceChar(parser);
    }
    parser.report(16);
  }
  function parseEscape(parser, context, first, isTemplate = 0) {
    switch (first) {
      case 98:
        return 8;
      case 102:
        return 12;
      case 114:
        return 13;
      case 110:
        return 10;
      case 116:
        return 9;
      case 118:
        return 11;
      case 13: {
        if (parser.index < parser.end) {
          const nextChar = parser.source.charCodeAt(parser.index + 1);
          if (nextChar === 10) {
            parser.index = parser.index + 1;
            parser.currentChar = nextChar;
          }
        }
      }
      case 10:
      case 8232:
      case 8233:
        parser.column = -1;
        parser.line++;
        return -1;
      case 48:
      case 49:
      case 50:
      case 51: {
        let code = first - 48;
        let index = parser.index + 1;
        let column = parser.column + 1;
        if (index < parser.end) {
          const next = parser.source.charCodeAt(index);
          if ((CharTypes[next] & 32) === 0) {
            if (code !== 0 || CharTypes[next] & 512) {
              if (context & 1 || isTemplate) return -2;
              parser.flags |= 64;
            }
          } else if (context & 1 || isTemplate) {
            return -2;
          } else {
            parser.currentChar = next;
            code = (code << 3) | (next - 48);
            index++;
            column++;
            if (index < parser.end) {
              const next = parser.source.charCodeAt(index);
              if (CharTypes[next] & 32) {
                parser.currentChar = next;
                code = (code << 3) | (next - 48);
                index++;
                column++;
              }
            }
            parser.flags |= 64;
          }
          parser.index = index - 1;
          parser.column = column - 1;
        }
        return code;
      }
      case 52:
      case 53:
      case 54:
      case 55: {
        if (isTemplate || context & 1) return -2;
        let code = first - 48;
        const index = parser.index + 1;
        const column = parser.column + 1;
        if (index < parser.end) {
          const next = parser.source.charCodeAt(index);
          if (CharTypes[next] & 32) {
            code = (code << 3) | (next - 48);
            parser.currentChar = next;
            parser.index = index;
            parser.column = column;
          }
        }
        parser.flags |= 64;
        return code;
      }
      case 120: {
        const ch1 = advanceChar(parser);
        if ((CharTypes[ch1] & 64) === 0) return -4;
        const hi = toHex(ch1);
        const ch2 = advanceChar(parser);
        if ((CharTypes[ch2] & 64) === 0) return -4;
        const lo = toHex(ch2);
        return (hi << 4) | lo;
      }
      case 117: {
        const ch = advanceChar(parser);
        if (parser.currentChar === 123) {
          let code = 0;
          while ((CharTypes[advanceChar(parser)] & 64) !== 0) {
            code = (code << 4) | toHex(parser.currentChar);
            if (code > 1114111) return -5;
          }
          if (parser.currentChar < 1 || parser.currentChar !== 125) {
            return -4;
          }
          return code;
        } else {
          if ((CharTypes[ch] & 64) === 0) return -4;
          const ch2 = parser.source.charCodeAt(parser.index + 1);
          if ((CharTypes[ch2] & 64) === 0) return -4;
          const ch3 = parser.source.charCodeAt(parser.index + 2);
          if ((CharTypes[ch3] & 64) === 0) return -4;
          const ch4 = parser.source.charCodeAt(parser.index + 3);
          if ((CharTypes[ch4] & 64) === 0) return -4;
          parser.index += 3;
          parser.column += 3;
          parser.currentChar = parser.source.charCodeAt(parser.index);
          return (
            (toHex(ch) << 12) |
            (toHex(ch2) << 8) |
            (toHex(ch3) << 4) |
            toHex(ch4)
          );
        }
      }
      case 56:
      case 57:
        if (isTemplate || !parser.options.webcompat || context & 1) return -3;
        parser.flags |= 4096;
      default:
        return first;
    }
  }
  function handleStringError(parser, code, isTemplate) {
    switch (code) {
      case -1:
        return;
      case -2:
        parser.report(isTemplate ? 2 : 1);
      case -3:
        parser.report(isTemplate ? 3 : 14);
      case -4:
        parser.report(7);
      case -5:
        parser.report(104);
    }
  }
  function scanTemplate(parser, context) {
    const { index: start } = parser;
    let token = 67174409;
    let ret = '';
    let char = advanceChar(parser);
    while (char !== 96) {
      if (char === 36 && parser.source.charCodeAt(parser.index + 1) === 123) {
        advanceChar(parser);
        token = 67174408;
        break;
      } else if (char === 92) {
        char = advanceChar(parser);
        if (char > 126) {
          ret += String.fromCodePoint(char);
        } else {
          const { index: index, line: line, column: column } = parser;
          const code = parseEscape(parser, context | 1, char, 1);
          if (code >= 0) {
            ret += String.fromCodePoint(code);
          } else if (code !== -1 && context & 64) {
            parser.index = index;
            parser.line = line;
            parser.column = column;
            ret = null;
            char = scanBadTemplate(parser, char);
            if (char < 0) token = 67174408;
            break;
          } else {
            handleStringError(parser, code, 1);
          }
        }
      } else if (parser.index < parser.end) {
        if (char === 13 && parser.source.charCodeAt(parser.index) === 10) {
          ret += String.fromCodePoint(char);
          parser.currentChar = parser.source.charCodeAt(++parser.index);
        }
        if (((char & 83) < 3 && char === 10) || (char ^ 8232) <= 1) {
          parser.column = -1;
          parser.line++;
        }
        ret += String.fromCodePoint(char);
      }
      if (parser.index >= parser.end) parser.report(17);
      char = advanceChar(parser);
    }
    advanceChar(parser);
    parser.tokenValue = ret;
    parser.tokenRaw = parser.source.slice(
      start + 1,
      parser.index - (token === 67174409 ? 1 : 2),
    );
    return token;
  }
  function scanBadTemplate(parser, ch) {
    while (ch !== 96) {
      switch (ch) {
        case 36: {
          const index = parser.index + 1;
          if (index < parser.end && parser.source.charCodeAt(index) === 123) {
            parser.index = index;
            parser.column++;
            return -ch;
          }
          break;
        }
        case 10:
        case 8232:
        case 8233:
          parser.column = -1;
          parser.line++;
      }
      if (parser.index >= parser.end) parser.report(17);
      ch = advanceChar(parser);
    }
    return ch;
  }
  function scanTemplateTail(parser, context) {
    if (parser.index >= parser.end) parser.report(0);
    parser.index--;
    parser.column--;
    return scanTemplate(parser, context);
  }
  const errorMessages = {
    [0]: 'Unexpected token',
    [30]: "Unexpected token: '%0'",
    [1]: 'Octal escape sequences are not allowed in strict mode',
    [2]: 'Octal escape sequences are not allowed in template strings',
    [3]: '\\8 and \\9 are not allowed in template strings',
    [4]: 'Private identifier #%0 is not defined',
    [5]: 'Illegal Unicode escape sequence',
    [6]: 'Invalid code point %0',
    [7]: 'Invalid hexadecimal escape sequence',
    [9]: 'Octal literals are not allowed in strict mode',
    [8]: 'Decimal integer literals with a leading zero are forbidden in strict mode',
    [10]: 'Expected number in radix %0',
    [151]:
      'Invalid left-hand side assignment to a destructible right-hand side',
    [11]: 'Non-number found after exponent indicator',
    [12]: 'Invalid BigIntLiteral',
    [13]: 'No identifiers allowed directly after numeric literal',
    [14]: 'Escapes \\8 or \\9 are not syntactically valid escapes',
    [15]: 'Escapes \\8 or \\9 are not allowed in strict mode',
    [16]: 'Unterminated string literal',
    [17]: 'Unterminated template literal',
    [18]: 'Multiline comment was not closed properly',
    [19]: 'The identifier contained dynamic unicode escape that was not closed',
    [20]: "Illegal character '%0'",
    [21]: 'Missing hexadecimal digits',
    [22]: 'Invalid implicit octal',
    [23]: 'Invalid line break in string literal',
    [24]: 'Only unicode escapes are legal in identifier names',
    [25]: "Expected '%0'",
    [26]: 'Invalid left-hand side in assignment',
    [27]: 'Invalid left-hand side in async arrow',
    [28]: 'Calls to super must be in the "constructor" method of a class expression or class declaration that has a superclass',
    [29]: 'Member access on super must be in a method',
    [31]: 'Await expression not allowed in formal parameter',
    [32]: 'Yield expression not allowed in formal parameter',
    [95]: "Unexpected token: 'escaped keyword'",
    [33]: 'Unary expressions as the left operand of an exponentiation expression must be disambiguated with parentheses',
    [123]:
      'Async functions can only be declared at the top level or inside a block',
    [34]: 'Unterminated regular expression',
    [35]: 'Unexpected regular expression flag',
    [36]: "Duplicate regular expression flag '%0'",
    [37]: '%0 functions must have exactly %1 argument%2',
    [38]: 'Setter function argument must not be a rest parameter',
    [39]: '%0 declaration must have a name in this context',
    [40]: 'Function name may not contain any reserved words or be eval or arguments in strict mode',
    [41]: 'The rest operator is missing an argument',
    [42]: 'A getter cannot be a generator',
    [43]: 'A setter cannot be a generator',
    [44]: 'A computed property name must be followed by a colon or paren',
    [134]:
      'Object literal keys that are strings or numbers must be a method or have a colon',
    [46]: 'Found `* async x(){}` but this should be `async * x(){}`',
    [45]: 'Getters and setters can not be generators',
    [47]: "'%0' can not be generator method",
    [48]: "No line break is allowed after '=>'",
    [49]: 'The left-hand side of the arrow can only be destructed through assignment',
    [50]: 'The binding declaration is not destructible',
    [51]: 'Async arrow can not be followed by new expression',
    [52]: "Classes may not have a static property named 'prototype'",
    [53]: 'Class constructor may not be a %0',
    [54]: 'Duplicate constructor method in class',
    [55]: 'Invalid increment/decrement operand',
    [56]: 'Invalid use of `new` keyword on an increment/decrement expression',
    [57]: '`=>` is an invalid assignment target',
    [58]: 'Rest element may not have a trailing comma',
    [59]: 'Missing initializer in %0 declaration',
    [60]: "'for-%0' loop head declarations can not have an initializer",
    [61]: 'Invalid left-hand side in for-%0 loop: Must have a single binding',
    [62]: 'Invalid shorthand property initializer',
    [63]: 'Property name __proto__ appears more than once in object literal',
    [64]: 'Let is disallowed as a lexically bound name',
    [65]: "Invalid use of '%0' inside new expression",
    [66]: "Illegal 'use strict' directive in function with non-simple parameter list",
    [67]: 'Identifier "let" disallowed as left-hand side expression in strict mode',
    [68]: 'Illegal continue statement',
    [69]: 'Illegal break statement',
    [70]: 'Cannot have `let[...]` as a var name in strict mode',
    [71]: 'Invalid destructuring assignment target',
    [72]: 'Rest parameter may not have a default initializer',
    [73]: 'The rest argument must the be last parameter',
    [74]: 'Invalid rest argument',
    [76]: 'In strict mode code, functions can only be declared at top level or inside a block',
    [77]: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',
    [78]: 'Without web compatibility enabled functions can not be declared at top level, inside a block, or as the body of an if statement',
    [79]: "Class declaration can't appear in single-statement context",
    [80]: 'Invalid left-hand side in for-%0',
    [81]: 'Invalid assignment in for-%0',
    [82]: 'for await (... of ...) is only valid in async functions and async generators',
    [83]: 'The first token after the template expression should be a continuation of the template',
    [85]: '`let` declaration not allowed here and `let` cannot be a regular var name in strict mode',
    [84]: '`let \n [` is a restricted production at the start of a statement',
    [86]: 'Catch clause requires exactly one parameter, not more (and no trailing comma)',
    [87]: 'Catch clause parameter does not support default values',
    [88]: 'Missing catch or finally after try',
    [89]: 'More than one default clause in switch statement',
    [90]: 'Illegal newline after throw',
    [91]: 'Strict mode code may not include a with statement',
    [92]: 'Illegal return statement',
    [93]: 'The left hand side of the for-header binding declaration is not destructible',
    [94]: 'new.target only allowed within functions or static blocks',
    [96]: "'#' not followed by identifier",
    [102]: 'Invalid keyword',
    [101]: "Can not use 'let' as a class name",
    [100]: "'A lexical declaration can't define a 'let' binding",
    [99]: 'Can not use `let` as variable name in strict mode',
    [97]: "'%0' may not be used as an identifier in this context",
    [98]: 'Await is only valid in async functions',
    [103]: 'The %0 keyword can only be used with the module goal',
    [104]: 'Unicode codepoint must not be greater than 0x10FFFF',
    [105]: '%0 source must be string',
    [106]: 'Only a identifier or string can be used to indicate alias',
    [107]: "Only '*' or '{...}' can be imported after default",
    [108]: 'Trailing decorator may be followed by method',
    [109]: "Decorators can't be used with a constructor",
    [110]: 'Can not use `await` as identifier in module or async func',
    [111]: 'Can not use `await` as identifier in module',
    [112]: 'HTML comments are only allowed with web compatibility (Annex B)',
    [113]:
      "The identifier 'let' must not be in expression position in strict mode",
    [114]: 'Cannot assign to `eval` and `arguments` in strict mode',
    [115]: "The left-hand side of a for-of loop may not start with 'let'",
    [116]: 'Block body arrows can not be immediately invoked without a group',
    [117]: 'Block body arrows can not be immediately accessed without a group',
    [118]: 'Unexpected strict mode reserved word',
    [119]: 'Unexpected eval or arguments in strict mode',
    [120]: 'Decorators must not be followed by a semicolon',
    [121]: 'Calling delete on expression not allowed in strict mode',
    [122]: 'Pattern can not have a tail',
    [124]: 'Can not have a `yield` expression on the left side of a ternary',
    [125]: 'An arrow function can not have a postfix update operator',
    [126]: 'Invalid object literal key character after generator star',
    [127]: 'Private fields can not be deleted',
    [129]: 'Classes may not have a field called constructor',
    [128]: 'Classes may not have a private element named constructor',
    [130]:
      'A class field initializer or static block may not contain arguments',
    [131]: 'Generators can only be declared at the top level or inside a block',
    [132]:
      'Async methods are a restricted production and cannot have a newline following it',
    [133]: 'Unexpected character after object literal property name',
    [135]: 'Invalid key token',
    [136]: "Label '%0' has already been declared",
    [137]: 'continue statement must be nested within an iteration statement',
    [138]: "Undefined label '%0'",
    [139]: 'Trailing comma is disallowed inside import(...) arguments',
    [140]: 'Invalid binding in JSON import',
    [141]: 'import() requires exactly one argument',
    [142]: 'Cannot use new with import(...)',
    [143]: '... is not allowed in import()',
    [144]: "Expected '=>'",
    [145]: "Duplicate binding '%0'",
    [146]: 'Duplicate private identifier #%0',
    [147]: "Cannot export a duplicate name '%0'",
    [150]: 'Duplicate %0 for-binding',
    [148]:
      "Exported binding '%0' needs to refer to a top-level declared variable",
    [149]: 'Unexpected private field',
    [153]: 'Numeric separators are not allowed at the end of numeric literals',
    [152]: 'Only one underscore is allowed as numeric separator',
    [154]: 'JSX value should be either an expression or a quoted JSX text',
    [155]: 'Expected corresponding JSX closing tag for %0',
    [156]: 'Adjacent JSX elements must be wrapped in an enclosing tag',
    [157]: "JSX attributes must only be assigned a non-empty 'expression'",
    [158]: "'%0' has already been declared",
    [159]: "'%0' shadowed a catch clause binding",
    [160]: 'Dot property must be an identifier',
    [161]: 'Encountered invalid input after spread/rest argument',
    [162]: 'Catch without try',
    [163]: 'Finally without try',
    [164]: 'Expected corresponding closing tag for JSX fragment',
    [165]:
      'Coalescing and logical operators used together in the same expression must be disambiguated with parentheses',
    [166]: 'Invalid tagged template on optional chain',
    [167]: 'Invalid optional chain from super property',
    [168]: 'Invalid optional chain from new expression',
    [169]: 'Cannot use "import.meta" outside a module',
    [170]: 'Leading decorators must be attached to a class declaration',
    [171]: 'An export name cannot include a lone surrogate, found %0',
    [172]:
      'A string literal cannot be used as an exported binding without `from`',
    [173]: "Private fields can't be accessed on super",
    [174]: "The only valid meta property for import is 'import.meta'",
    [175]: "'import.meta' must not contain escaped characters",
    [176]: 'cannot use "await" as identifier inside an async function',
    [177]: 'cannot use "await" in static blocks',
  };
  class ParseError extends SyntaxError {
    start;
    end;
    range;
    loc;
    description;
    constructor(start, end, type, ...params) {
      const description = errorMessages[type].replace(
        /%(\d+)/g,
        (_, i) => params[i],
      );
      const message =
        '[' +
        start.line +
        ':' +
        start.column +
        '-' +
        end.line +
        ':' +
        end.column +
        ']: ' +
        description;
      super(message);
      this.start = start.index;
      this.end = end.index;
      this.range = [start.index, end.index];
      this.loc = {
        start: { line: start.line, column: start.column },
        end: { line: end.line, column: end.column },
      };
      this.description = description;
    }
  }
  function scanNumber(parser, context, kind) {
    let char = parser.currentChar;
    let value = 0;
    let digit = 9;
    let atStart = kind & 64 ? 0 : 1;
    let digits = 0;
    let allowSeparator = 0;
    if (kind & 64) {
      value = '.' + scanDecimalDigitsOrSeparator(parser, char);
      char = parser.currentChar;
      if (char === 110) parser.report(12);
    } else {
      if (char === 48) {
        char = advanceChar(parser);
        if ((char | 32) === 120) {
          kind = 8 | 128;
          char = advanceChar(parser);
          while (CharTypes[char] & (64 | 4096)) {
            if (char === 95) {
              if (!allowSeparator) parser.report(152);
              allowSeparator = 0;
              char = advanceChar(parser);
              continue;
            }
            allowSeparator = 1;
            value = value * 16 + toHex(char);
            digits++;
            char = advanceChar(parser);
          }
          if (digits === 0 || !allowSeparator) {
            parser.report(digits === 0 ? 21 : 153);
          }
        } else if ((char | 32) === 111) {
          kind = 4 | 128;
          char = advanceChar(parser);
          while (CharTypes[char] & (32 | 4096)) {
            if (char === 95) {
              if (!allowSeparator) {
                parser.report(152);
              }
              allowSeparator = 0;
              char = advanceChar(parser);
              continue;
            }
            allowSeparator = 1;
            value = value * 8 + (char - 48);
            digits++;
            char = advanceChar(parser);
          }
          if (digits === 0 || !allowSeparator) {
            parser.report(digits === 0 ? 0 : 153);
          }
        } else if ((char | 32) === 98) {
          kind = 2 | 128;
          char = advanceChar(parser);
          while (CharTypes[char] & (128 | 4096)) {
            if (char === 95) {
              if (!allowSeparator) {
                parser.report(152);
              }
              allowSeparator = 0;
              char = advanceChar(parser);
              continue;
            }
            allowSeparator = 1;
            value = value * 2 + (char - 48);
            digits++;
            char = advanceChar(parser);
          }
          if (digits === 0 || !allowSeparator) {
            parser.report(digits === 0 ? 0 : 153);
          }
        } else if (CharTypes[char] & 32) {
          if (context & 1) parser.report(1);
          kind = 1;
          while (CharTypes[char] & 16) {
            if (CharTypes[char] & 512) {
              kind = 32;
              atStart = 0;
              break;
            }
            value = value * 8 + (char - 48);
            char = advanceChar(parser);
          }
        } else if (CharTypes[char] & 512) {
          if (context & 1) parser.report(1);
          parser.flags |= 64;
          kind = 32;
        } else if (char === 95) {
          parser.report(0);
        }
      }
      if (kind & 48) {
        if (atStart) {
          while (digit >= 0 && CharTypes[char] & (16 | 4096)) {
            if (char === 95) {
              char = advanceChar(parser);
              if (char === 95 || kind & 32) {
                throw new ParseError(
                  parser.currentLocation,
                  {
                    index: parser.index + 1,
                    line: parser.line,
                    column: parser.column,
                  },
                  152,
                );
              }
              allowSeparator = 1;
              continue;
            }
            allowSeparator = 0;
            value = 10 * value + (char - 48);
            char = advanceChar(parser);
            --digit;
          }
          if (allowSeparator) {
            throw new ParseError(
              parser.currentLocation,
              {
                index: parser.index + 1,
                line: parser.line,
                column: parser.column,
              },
              153,
            );
          }
          if (digit >= 0 && !isIdentifierStart(char) && char !== 46) {
            parser.tokenValue = value;
            if (parser.options.raw)
              parser.tokenRaw = parser.source.slice(
                parser.tokenIndex,
                parser.index,
              );
            return 134283266;
          }
        }
        value += scanDecimalDigitsOrSeparator(parser, char);
        char = parser.currentChar;
        if (char === 46) {
          if (advanceChar(parser) === 95) parser.report(0);
          kind = 64;
          value +=
            '.' + scanDecimalDigitsOrSeparator(parser, parser.currentChar);
          char = parser.currentChar;
        }
      }
    }
    const end = parser.index;
    let isBigInt = 0;
    if (char === 110 && kind & 128) {
      isBigInt = 1;
      char = advanceChar(parser);
    } else {
      if ((char | 32) === 101) {
        char = advanceChar(parser);
        if (CharTypes[char] & 256) char = advanceChar(parser);
        const { index: index } = parser;
        if ((CharTypes[char] & 16) === 0) parser.report(11);
        value +=
          parser.source.substring(end, index) +
          scanDecimalDigitsOrSeparator(parser, char);
        char = parser.currentChar;
      }
    }
    if (
      (parser.index < parser.end && CharTypes[char] & 16) ||
      isIdentifierStart(char)
    ) {
      parser.report(13);
    }
    if (isBigInt) {
      parser.tokenRaw = parser.source.slice(parser.tokenIndex, parser.index);
      parser.tokenValue = BigInt(
        parser.tokenRaw.slice(0, -1).replaceAll('_', ''),
      );
      return 134283388;
    }
    parser.tokenValue =
      kind & (1 | 2 | 8 | 4)
        ? value
        : kind & 32
          ? parseFloat(parser.source.substring(parser.tokenIndex, parser.index))
          : +value;
    if (parser.options.raw)
      parser.tokenRaw = parser.source.slice(parser.tokenIndex, parser.index);
    return 134283266;
  }
  function scanDecimalDigitsOrSeparator(parser, char) {
    let allowSeparator = 0;
    let start = parser.index;
    let ret = '';
    while (CharTypes[char] & (16 | 4096)) {
      if (char === 95) {
        const { index: index } = parser;
        char = advanceChar(parser);
        if (char === 95) {
          throw new ParseError(
            parser.currentLocation,
            {
              index: parser.index + 1,
              line: parser.line,
              column: parser.column,
            },
            152,
          );
        }
        allowSeparator = 1;
        ret += parser.source.substring(start, index);
        start = parser.index;
        continue;
      }
      allowSeparator = 0;
      char = advanceChar(parser);
    }
    if (allowSeparator) {
      throw new ParseError(
        parser.currentLocation,
        { index: parser.index + 1, line: parser.line, column: parser.column },
        153,
      );
    }
    return ret + parser.source.substring(start, parser.index);
  }
  const KeywordDescTable = [
    'end of source',
    'identifier',
    'number',
    'string',
    'regular expression',
    'false',
    'true',
    'null',
    'template continuation',
    'template tail',
    '=>',
    '(',
    '{',
    '.',
    '...',
    '}',
    ')',
    ';',
    ',',
    '[',
    ']',
    ':',
    '?',
    "'",
    '"',
    '++',
    '--',
    '=',
    '<<=',
    '>>=',
    '>>>=',
    '**=',
    '+=',
    '-=',
    '*=',
    '/=',
    '%=',
    '^=',
    '|=',
    '&=',
    '||=',
    '&&=',
    '??=',
    'typeof',
    'delete',
    'void',
    '!',
    '~',
    '+',
    '-',
    'in',
    'instanceof',
    '*',
    '%',
    '/',
    '**',
    '&&',
    '||',
    '===',
    '!==',
    '==',
    '!=',
    '<=',
    '>=',
    '<',
    '>',
    '<<',
    '>>',
    '>>>',
    '&',
    '|',
    '^',
    'var',
    'let',
    'const',
    'break',
    'case',
    'catch',
    'class',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'export',
    'extends',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'new',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'try',
    'while',
    'with',
    'implements',
    'interface',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'as',
    'async',
    'await',
    'constructor',
    'get',
    'set',
    'accessor',
    'from',
    'of',
    'enum',
    'eval',
    'arguments',
    'escaped keyword',
    'escaped future reserved keyword',
    'reserved if strict',
    '#',
    'BigIntLiteral',
    '??',
    '?.',
    'WhiteSpace',
    'Illegal',
    'LineTerminator',
    'PrivateField',
    'Template',
    '@',
    'target',
    'meta',
    'LineFeed',
    'Escaped',
    'JSXText',
  ];
  const descKeywordTable = {
    this: 86111,
    function: 86104,
    if: 20569,
    return: 20572,
    var: 86088,
    else: 20563,
    for: 20567,
    new: 86107,
    in: 8673330,
    typeof: 16863275,
    while: 20578,
    case: 20556,
    break: 20555,
    try: 20577,
    catch: 20557,
    delete: 16863276,
    throw: 86112,
    switch: 86110,
    continue: 20559,
    default: 20561,
    instanceof: 8411187,
    do: 20562,
    void: 16863277,
    finally: 20566,
    async: 209005,
    await: 209006,
    class: 86094,
    const: 86090,
    constructor: 12399,
    debugger: 20560,
    export: 20564,
    extends: 20565,
    false: 86021,
    from: 209011,
    get: 209008,
    implements: 36964,
    import: 86106,
    interface: 36965,
    let: 241737,
    null: 86023,
    of: 471156,
    package: 36966,
    private: 36967,
    protected: 36968,
    public: 36969,
    set: 209009,
    static: 36970,
    super: 86109,
    true: 86022,
    with: 20579,
    yield: 241771,
    enum: 86133,
    eval: 537079926,
    as: 77932,
    arguments: 537079927,
    target: 209029,
    meta: 209030,
    accessor: 12402,
  };
  function matchOrInsertSemicolon(parser, context) {
    if ((parser.flags & 1) === 0 && (parser.getToken() & 1048576) !== 1048576) {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
    if (!consumeOpt(parser, context, 1074790417)) {
      parser.options.onInsertedSemicolon?.(parser.startIndex);
    }
  }
  function isValidStrictMode(parser, index, tokenIndex, tokenValue) {
    if (index - tokenIndex < 13 && tokenValue === 'use strict') {
      if ((parser.getToken() & 1048576) === 1048576 || parser.flags & 1) {
        return 1;
      }
    }
    return 0;
  }
  function optionalBit(parser, context, t) {
    if (parser.getToken() !== t) return 0;
    nextToken(parser, context);
    return 1;
  }
  function consumeOpt(parser, context, t) {
    if (parser.getToken() !== t) return false;
    nextToken(parser, context);
    return true;
  }
  function consume(parser, context, t) {
    if (parser.getToken() !== t) parser.report(25, KeywordDescTable[t & 255]);
    nextToken(parser, context);
  }
  function reinterpretToPattern(parser, node) {
    switch (node.type) {
      case 'ArrayExpression': {
        node.type = 'ArrayPattern';
        const { elements: elements } = node;
        for (let i = 0, n = elements.length; i < n; ++i) {
          const element = elements[i];
          if (element) reinterpretToPattern(parser, element);
        }
        return;
      }
      case 'ObjectExpression': {
        node.type = 'ObjectPattern';
        const { properties: properties } = node;
        for (let i = 0, n = properties.length; i < n; ++i) {
          reinterpretToPattern(parser, properties[i]);
        }
        return;
      }
      case 'AssignmentExpression':
        node.type = 'AssignmentPattern';
        if (node.operator !== '=') parser.report(71);
        delete node.operator;
        reinterpretToPattern(parser, node.left);
        return;
      case 'Property':
        reinterpretToPattern(parser, node.value);
        return;
      case 'SpreadElement':
        node.type = 'RestElement';
        reinterpretToPattern(parser, node.argument);
    }
  }
  function validateBindingIdentifier(
    parser,
    context,
    kind,
    t,
    skipEvalArgCheck,
  ) {
    if (context & 1) {
      if ((t & 36864) === 36864) {
        parser.report(118);
      }
      if (!skipEvalArgCheck && (t & 537079808) === 537079808) {
        parser.report(119);
      }
    }
    if ((t & 20480) === 20480 || t === -2147483528) {
      parser.report(102);
    }
    if (kind & (8 | 16) && (t & 255) === (241737 & 255)) {
      parser.report(100);
    }
    if (context & (2048 | 2) && t === 209006) {
      parser.report(110);
    }
    if (context & (1024 | 1) && t === 241771) {
      parser.report(97, 'yield');
    }
  }
  function validateFunctionName(parser, context, t) {
    if (context & 1) {
      if ((t & 36864) === 36864) {
        parser.report(118);
      }
      if ((t & 537079808) === 537079808) {
        parser.report(119);
      }
      if (t === -2147483527) {
        parser.report(95);
      }
      if (t === -2147483528) {
        parser.report(95);
      }
    }
    if ((t & 20480) === 20480) {
      parser.report(102);
    }
    if (context & (2048 | 2) && t === 209006) {
      parser.report(110);
    }
    if (context & (1024 | 1) && t === 241771) {
      parser.report(97, 'yield');
    }
  }
  function isStrictReservedWord(parser, context, t) {
    if (t === 209006) {
      if (context & (2048 | 2)) parser.report(110);
      parser.destructible |= 128;
    }
    if (t === 241771 && context & 1024) parser.report(97, 'yield');
    return (t & 20480) === 20480 || (t & 36864) === 36864 || t == -2147483527;
  }
  function isPropertyWithPrivateFieldKey(expr) {
    return !expr.property ? false : expr.property.type === 'PrivateIdentifier';
  }
  function isValidLabel(parser, labels, name, isIterationStatement) {
    while (labels) {
      if (labels['$' + name]) {
        if (isIterationStatement) parser.report(137);
        return 1;
      }
      if (isIterationStatement && labels.loop) isIterationStatement = 0;
      labels = labels['$'];
    }
    return 0;
  }
  function validateAndDeclareLabel(parser, labels, name) {
    let set = labels;
    while (set) {
      if (set['$' + name]) parser.report(136, name);
      set = set['$'];
    }
    labels['$' + name] = 1;
  }
  function isEqualTagName(elementName) {
    switch (elementName.type) {
      case 'JSXIdentifier':
        return elementName.name;
      case 'JSXNamespacedName':
        return elementName.namespace + ':' + elementName.name;
      case 'JSXMemberExpression':
        return (
          isEqualTagName(elementName.object) +
          '.' +
          isEqualTagName(elementName.property)
        );
    }
  }
  function isValidIdentifier(context, t) {
    if (context & (1 | 1024)) {
      if (context & 2 && t === 209006) return false;
      if (context & 1024 && t === 241771) return false;
      return (t & 12288) === 12288;
    }
    return (t & 12288) === 12288 || (t & 36864) === 36864;
  }
  function classifyIdentifier(parser, context, t) {
    if ((t & 537079808) === 537079808) {
      if (context & 1) parser.report(119);
      parser.flags |= 512;
    }
    if (!isValidIdentifier(context, t)) parser.report(0);
  }
  function getOwnProperty(object, key) {
    return Object.hasOwn(object, key) ? object[key] : undefined;
  }
  function scanIdentifier(parser, context, isValidAsKeyword) {
    while (isIdPart[advanceChar(parser)]);
    parser.tokenValue = parser.source.slice(parser.tokenIndex, parser.index);
    return parser.currentChar !== 92 && parser.currentChar <= 126
      ? (getOwnProperty(descKeywordTable, parser.tokenValue) ?? 208897)
      : scanIdentifierSlowCase(parser, context, 0, isValidAsKeyword);
  }
  function scanUnicodeIdentifier(parser, context) {
    const cookedChar = scanIdentifierUnicodeEscape(parser);
    if (!isIdentifierStart(cookedChar)) parser.report(5);
    parser.tokenValue = String.fromCodePoint(cookedChar);
    return scanIdentifierSlowCase(
      parser,
      context,
      1,
      CharTypes[cookedChar] & 4,
    );
  }
  function scanIdentifierSlowCase(
    parser,
    context,
    hasEscape,
    isValidAsKeyword,
  ) {
    let start = parser.index;
    while (parser.index < parser.end) {
      if (parser.currentChar === 92) {
        parser.tokenValue += parser.source.slice(start, parser.index);
        hasEscape = 1;
        const code = scanIdentifierUnicodeEscape(parser);
        if (!isIdentifierPart(code)) parser.report(5);
        isValidAsKeyword = isValidAsKeyword && CharTypes[code] & 4;
        parser.tokenValue += String.fromCodePoint(code);
        start = parser.index;
      } else {
        const merged = consumePossibleSurrogatePair(parser);
        if (merged > 0) {
          if (!isIdentifierPart(merged)) {
            parser.report(20, String.fromCodePoint(merged));
          }
          parser.currentChar = merged;
          parser.index++;
          parser.column++;
        } else if (!isIdentifierPart(parser.currentChar)) {
          break;
        }
        advanceChar(parser);
      }
    }
    if (parser.index <= parser.end) {
      parser.tokenValue += parser.source.slice(start, parser.index);
    }
    const { length: length } = parser.tokenValue;
    if (isValidAsKeyword && length >= 2 && length <= 11) {
      const token = getOwnProperty(descKeywordTable, parser.tokenValue);
      if (token === void 0) return 208897 | (hasEscape ? -2147483648 : 0);
      if (!hasEscape) return token;
      if (token === 209006) {
        if ((context & (2 | 2048)) === 0) {
          return token | -2147483648;
        }
        return -2147483528;
      }
      if (context & 1) {
        if (token === 36970) {
          return -2147483527;
        }
        if ((token & 36864) === 36864) {
          return -2147483527;
        }
        if ((token & 20480) === 20480) {
          if (context & 262144 && (context & 8) === 0) {
            return token | -2147483648;
          } else {
            return -2147483528;
          }
        }
        return 209018 | -2147483648;
      }
      if (
        context & 262144 &&
        (context & 8) === 0 &&
        (token & 20480) === 20480
      ) {
        return token | -2147483648;
      }
      if (token === 241771) {
        return context & 262144
          ? 209018 | -2147483648
          : context & 1024
            ? -2147483528
            : token | -2147483648;
      }
      if (token === 209005) {
        return 209018 | -2147483648;
      }
      if ((token & 36864) === 36864) {
        return token | 12288 | -2147483648;
      }
      return -2147483528;
    }
    return 208897 | (hasEscape ? -2147483648 : 0);
  }
  function scanPrivateIdentifier(parser) {
    let char = advanceChar(parser);
    if (char === 92) return 130;
    const merged = consumePossibleSurrogatePair(parser);
    if (merged) char = merged;
    if (!isIdentifierStart(char)) parser.report(96);
    return 130;
  }
  function scanIdentifierUnicodeEscape(parser) {
    if (parser.source.charCodeAt(parser.index + 1) !== 117) {
      parser.report(5);
    }
    parser.currentChar = parser.source.charCodeAt((parser.index += 2));
    parser.column += 2;
    return scanUnicodeEscape(parser);
  }
  function scanUnicodeEscape(parser) {
    let codePoint = 0;
    const char = parser.currentChar;
    if (char === 123) {
      const begin = parser.index - 2;
      while (CharTypes[advanceChar(parser)] & 64) {
        codePoint = (codePoint << 4) | toHex(parser.currentChar);
        if (codePoint > 1114111)
          throw new ParseError(
            { index: begin, line: parser.line, column: parser.column },
            parser.currentLocation,
            104,
          );
      }
      if (parser.currentChar !== 125) {
        throw new ParseError(
          { index: begin, line: parser.line, column: parser.column },
          parser.currentLocation,
          7,
        );
      }
      advanceChar(parser);
      return codePoint;
    }
    if ((CharTypes[char] & 64) === 0) parser.report(7);
    const char2 = parser.source.charCodeAt(parser.index + 1);
    if ((CharTypes[char2] & 64) === 0) parser.report(7);
    const char3 = parser.source.charCodeAt(parser.index + 2);
    if ((CharTypes[char3] & 64) === 0) parser.report(7);
    const char4 = parser.source.charCodeAt(parser.index + 3);
    if ((CharTypes[char4] & 64) === 0) parser.report(7);
    codePoint =
      (toHex(char) << 12) |
      (toHex(char2) << 8) |
      (toHex(char3) << 4) |
      toHex(char4);
    parser.currentChar = parser.source.charCodeAt((parser.index += 4));
    parser.column += 4;
    return codePoint;
  }
  const TokenLookup = [
    128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 135, 127, 127, 129, 128,
    128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 127, 16842798, 134283267, 130, 208897, 8391477, 8390213,
    134283267, 67174411, 16, 8391476, 25233968, 18, 25233969, 67108877, 8457014,
    134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266,
    134283266, 134283266, 134283266, 21, 1074790417, 8456256, 1077936155,
    8390721, 22, 132, 208897, 208897, 208897, 208897, 208897, 208897, 208897,
    208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897,
    208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897,
    208897, 69271571, 136, 20, 8389959, 208897, 131, 4096, 4096, 4096, 4096,
    4096, 4096, 4096, 208897, 4096, 208897, 208897, 4096, 208897, 4096, 208897,
    4096, 208897, 4096, 4096, 4096, 208897, 4096, 4096, 208897, 4096, 4096,
    2162700, 8389702, 1074790415, 16842799, 128,
  ];
  function nextToken(parser, context) {
    parser.flags = (parser.flags | 1) ^ 1;
    parser.startIndex = parser.index;
    parser.startColumn = parser.column;
    parser.startLine = parser.line;
    parser.setToken(scanSingleToken(parser, context, 0));
  }
  function scanSingleToken(parser, context, state) {
    const isStartOfLine = parser.index === 0;
    const { source: source } = parser;
    let start = parser.currentLocation;
    while (parser.index < parser.end) {
      parser.tokenIndex = parser.index;
      parser.tokenColumn = parser.column;
      parser.tokenLine = parser.line;
      let char = parser.currentChar;
      if (char <= 126) {
        const token = TokenLookup[char];
        switch (token) {
          case 67174411:
          case 16:
          case 2162700:
          case 1074790415:
          case 69271571:
          case 20:
          case 21:
          case 1074790417:
          case 18:
          case 16842799:
          case 132:
          case 128:
            advanceChar(parser);
            return token;
          case 208897:
            return scanIdentifier(parser, context, 0);
          case 4096:
            return scanIdentifier(parser, context, 1);
          case 134283266:
            return scanNumber(parser, context, 16 | 128);
          case 134283267:
            return scanString(parser, context, char);
          case 131:
            return scanTemplate(parser, context);
          case 136:
            return scanUnicodeIdentifier(parser, context);
          case 130:
            return scanPrivateIdentifier(parser);
          case 127:
            advanceChar(parser);
            break;
          case 129:
            state |= 1 | 4;
            scanNewLine(parser);
            break;
          case 135:
            consumeLineFeed(parser, state);
            state = (state & -5) | 1;
            break;
          case 8456256: {
            const ch = advanceChar(parser);
            if (parser.index < parser.end) {
              if (ch === 60) {
                if (parser.index < parser.end && advanceChar(parser) === 61) {
                  advanceChar(parser);
                  return 4194332;
                }
                return 8390978;
              } else if (ch === 61) {
                advanceChar(parser);
                return 8390718;
              }
              if (ch === 33) {
                const index = parser.index + 1;
                if (
                  index + 1 < parser.end &&
                  source.charCodeAt(index) === 45 &&
                  source.charCodeAt(index + 1) == 45
                ) {
                  parser.column += 3;
                  parser.currentChar = source.charCodeAt((parser.index += 3));
                  state = skipSingleHTMLComment(
                    parser,
                    source,
                    state,
                    context,
                    2,
                    parser.tokenStart,
                  );
                  start = parser.tokenStart;
                  continue;
                }
                return 8456256;
              }
            }
            return 8456256;
          }
          case 1077936155: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 61) {
              if (advanceChar(parser) === 61) {
                advanceChar(parser);
                return 8390458;
              }
              return 8390460;
            }
            if (ch === 62) {
              advanceChar(parser);
              return 10;
            }
            return 1077936155;
          }
          case 16842798:
            if (advanceChar(parser) !== 61) {
              return 16842798;
            }
            if (advanceChar(parser) !== 61) {
              return 8390461;
            }
            advanceChar(parser);
            return 8390459;
          case 8391477:
            if (advanceChar(parser) !== 61) return 8391477;
            advanceChar(parser);
            return 4194340;
          case 8391476: {
            advanceChar(parser);
            if (parser.index >= parser.end) return 8391476;
            const ch = parser.currentChar;
            if (ch === 61) {
              advanceChar(parser);
              return 4194338;
            }
            if (ch !== 42) return 8391476;
            if (advanceChar(parser) !== 61) return 8391735;
            advanceChar(parser);
            return 4194335;
          }
          case 8389959:
            if (advanceChar(parser) !== 61) return 8389959;
            advanceChar(parser);
            return 4194341;
          case 25233968: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 43) {
              advanceChar(parser);
              return 33619993;
            }
            if (ch === 61) {
              advanceChar(parser);
              return 4194336;
            }
            return 25233968;
          }
          case 25233969: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 45) {
              advanceChar(parser);
              if ((state & 1 || isStartOfLine) && parser.currentChar === 62) {
                if (!parser.options.webcompat) parser.report(112);
                advanceChar(parser);
                state = skipSingleHTMLComment(
                  parser,
                  source,
                  state,
                  context,
                  3,
                  start,
                );
                start = parser.tokenStart;
                continue;
              }
              return 33619994;
            }
            if (ch === 61) {
              advanceChar(parser);
              return 4194337;
            }
            return 25233969;
          }
          case 8457014: {
            advanceChar(parser);
            if (parser.index < parser.end) {
              const ch = parser.currentChar;
              if (ch === 47) {
                advanceChar(parser);
                state = skipSingleLineComment(
                  parser,
                  source,
                  state,
                  0,
                  parser.tokenStart,
                );
                start = parser.tokenStart;
                continue;
              }
              if (ch === 42) {
                advanceChar(parser);
                state = skipMultiLineComment(parser, source, state);
                start = parser.tokenStart;
                continue;
              }
              if (context & 32) {
                return scanRegularExpression(parser);
              }
              if (ch === 61) {
                advanceChar(parser);
                return 4259875;
              }
            }
            return 8457014;
          }
          case 67108877: {
            const next = advanceChar(parser);
            if (next >= 48 && next <= 57)
              return scanNumber(parser, context, 64 | 16);
            if (next === 46) {
              const index = parser.index + 1;
              if (index < parser.end && source.charCodeAt(index) === 46) {
                parser.column += 2;
                parser.currentChar = source.charCodeAt((parser.index += 2));
                return 14;
              }
            }
            return 67108877;
          }
          case 8389702: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 124) {
              advanceChar(parser);
              if (parser.currentChar === 61) {
                advanceChar(parser);
                return 4194344;
              }
              return 8913465;
            }
            if (ch === 61) {
              advanceChar(parser);
              return 4194342;
            }
            return 8389702;
          }
          case 8390721: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 61) {
              advanceChar(parser);
              return 8390719;
            }
            if (ch !== 62) return 8390721;
            advanceChar(parser);
            if (parser.index < parser.end) {
              const ch = parser.currentChar;
              if (ch === 62) {
                if (advanceChar(parser) === 61) {
                  advanceChar(parser);
                  return 4194334;
                }
                return 8390980;
              }
              if (ch === 61) {
                advanceChar(parser);
                return 4194333;
              }
            }
            return 8390979;
          }
          case 8390213: {
            advanceChar(parser);
            const ch = parser.currentChar;
            if (ch === 38) {
              advanceChar(parser);
              if (parser.currentChar === 61) {
                advanceChar(parser);
                return 4194345;
              }
              return 8913720;
            }
            if (ch === 61) {
              advanceChar(parser);
              return 4194343;
            }
            return 8390213;
          }
          case 22: {
            let ch = advanceChar(parser);
            if (ch === 63) {
              advanceChar(parser);
              if (parser.currentChar === 61) {
                advanceChar(parser);
                return 4194346;
              }
              return 276824445;
            }
            if (ch === 46) {
              const index = parser.index + 1;
              if (index < parser.end) {
                ch = source.charCodeAt(index);
                if (!(ch >= 48 && ch <= 57)) {
                  advanceChar(parser);
                  return 67108990;
                }
              }
            }
            return 22;
          }
        }
      } else {
        if ((char ^ 8232) <= 1) {
          state = (state & -5) | 1;
          scanNewLine(parser);
          continue;
        }
        const merged = consumePossibleSurrogatePair(parser);
        if (merged > 0) char = merged;
        if (isIDStart(char)) {
          parser.tokenValue = '';
          return scanIdentifierSlowCase(parser, context, 0, 0);
        }
        if (isExoticECMAScriptWhitespace(char)) {
          advanceChar(parser);
          continue;
        }
        parser.report(20, String.fromCodePoint(char));
      }
    }
    return 1048576;
  }
  const entities = {
    AElig: '',
    AMP: '&',
    Aacute: '',
    Abreve: '',
    Acirc: '',
    Acy: '',
    Afr: '',
    Agrave: '',
    Alpha: '',
    Amacr: '',
    And: '',
    Aogon: '',
    Aopf: '',
    ApplyFunction: '',
    Aring: '',
    Ascr: '',
    Assign: '',
    Atilde: '',
    Auml: '',
    Backslash: '',
    Barv: '',
    Barwed: '',
    Bcy: '',
    Because: '',
    Bernoullis: '',
    Beta: '',
    Bfr: '',
    Bopf: '',
    Breve: '',
    Bscr: '',
    Bumpeq: '',
    CHcy: '',
    COPY: '',
    Cacute: '',
    Cap: '',
    CapitalDifferentialD: '',
    Cayleys: '',
    Ccaron: '',
    Ccedil: '',
    Ccirc: '',
    Cconint: '',
    Cdot: '',
    Cedilla: '',
    CenterDot: '',
    Cfr: '',
    Chi: '',
    CircleDot: '',
    CircleMinus: '',
    CirclePlus: '',
    CircleTimes: '',
    ClockwiseContourIntegral: '',
    CloseCurlyDoubleQuote: '',
    CloseCurlyQuote: '',
    Colon: '',
    Colone: '',
    Congruent: '',
    Conint: '',
    ContourIntegral: '',
    Copf: '',
    Coproduct: '',
    CounterClockwiseContourIntegral: '',
    Cross: '',
    Cscr: '',
    Cup: '',
    CupCap: '',
    DD: '',
    DDotrahd: '',
    DJcy: '',
    DScy: '',
    DZcy: '',
    Dagger: '',
    Darr: '',
    Dashv: '',
    Dcaron: '',
    Dcy: '',
    Del: '',
    Delta: '',
    Dfr: '',
    DiacriticalAcute: '',
    DiacriticalDot: '',
    DiacriticalDoubleAcute: '',
    DiacriticalGrave: '`',
    DiacriticalTilde: '',
    Diamond: '',
    DifferentialD: '',
    Dopf: '',
    Dot: '',
    DotDot: '',
    DotEqual: '',
    DoubleContourIntegral: '',
    DoubleDot: '',
    DoubleDownArrow: '',
    DoubleLeftArrow: '',
    DoubleLeftRightArrow: '',
    DoubleLeftTee: '',
    DoubleLongLeftArrow: '',
    DoubleLongLeftRightArrow: '',
    DoubleLongRightArrow: '',
    DoubleRightArrow: '',
    DoubleRightTee: '',
    DoubleUpArrow: '',
    DoubleUpDownArrow: '',
    DoubleVerticalBar: '',
    DownArrow: '',
    DownArrowBar: '',
    DownArrowUpArrow: '',
    DownBreve: '',
    DownLeftRightVector: '',
    DownLeftTeeVector: '',
    DownLeftVector: '',
    DownLeftVectorBar: '',
    DownRightTeeVector: '',
    DownRightVector: '',
    DownRightVectorBar: '',
    DownTee: '',
    DownTeeArrow: '',
    Downarrow: '',
    Dscr: '',
    Dstrok: '',
    ENG: '',
    ETH: '',
    Eacute: '',
    Ecaron: '',
    Ecirc: '',
    Ecy: '',
    Edot: '',
    Efr: '',
    Egrave: '',
    Element: '',
    Emacr: '',
    EmptySmallSquare: '',
    EmptyVerySmallSquare: '',
    Eogon: '',
    Eopf: '',
    Epsilon: '',
    Equal: '',
    EqualTilde: '',
    Equilibrium: '',
    Escr: '',
    Esim: '',
    Eta: '',
    Euml: '',
    Exists: '',
    ExponentialE: '',
    Fcy: '',
    Ffr: '',
    FilledSmallSquare: '',
    FilledVerySmallSquare: '',
    Fopf: '',
    ForAll: '',
    Fouriertrf: '',
    Fscr: '',
    GJcy: '',
    GT: '>',
    Gamma: '',
    Gammad: '',
    Gbreve: '',
    Gcedil: '',
    Gcirc: '',
    Gcy: '',
    Gdot: '',
    Gfr: '',
    Gg: '',
    Gopf: '',
    GreaterEqual: '',
    GreaterEqualLess: '',
    GreaterFullEqual: '',
    GreaterGreater: '',
    GreaterLess: '',
    GreaterSlantEqual: '',
    GreaterTilde: '',
    Gscr: '',
    Gt: '',
    HARDcy: '',
    Hacek: '',
    Hat: '^',
    Hcirc: '',
    Hfr: '',
    HilbertSpace: '',
    Hopf: '',
    HorizontalLine: '',
    Hscr: '',
    Hstrok: '',
    HumpDownHump: '',
    HumpEqual: '',
    IEcy: '',
    IJlig: '',
    IOcy: '',
    Iacute: '',
    Icirc: '',
    Icy: '',
    Idot: '',
    Ifr: '',
    Igrave: '',
    Im: '',
    Imacr: '',
    ImaginaryI: '',
    Implies: '',
    Int: '',
    Integral: '',
    Intersection: '',
    InvisibleComma: '',
    InvisibleTimes: '',
    Iogon: '',
    Iopf: '',
    Iota: '',
    Iscr: '',
    Itilde: '',
    Iukcy: '',
    Iuml: '',
    Jcirc: '',
    Jcy: '',
    Jfr: '',
    Jopf: '',
    Jscr: '',
    Jsercy: '',
    Jukcy: '',
    KHcy: '',
    KJcy: '',
    Kappa: '',
    Kcedil: '',
    Kcy: '',
    Kfr: '',
    Kopf: '',
    Kscr: '',
    LJcy: '',
    LT: '<',
    Lacute: '',
    Lambda: '',
    Lang: '',
    Laplacetrf: '',
    Larr: '',
    Lcaron: '',
    Lcedil: '',
    Lcy: '',
    LeftAngleBracket: '',
    LeftArrow: '',
    LeftArrowBar: '',
    LeftArrowRightArrow: '',
    LeftCeiling: '',
    LeftDoubleBracket: '',
    LeftDownTeeVector: '',
    LeftDownVector: '',
    LeftDownVectorBar: '',
    LeftFloor: '',
    LeftRightArrow: '',
    LeftRightVector: '',
    LeftTee: '',
    LeftTeeArrow: '',
    LeftTeeVector: '',
    LeftTriangle: '',
    LeftTriangleBar: '',
    LeftTriangleEqual: '',
    LeftUpDownVector: '',
    LeftUpTeeVector: '',
    LeftUpVector: '',
    LeftUpVectorBar: '',
    LeftVector: '',
    LeftVectorBar: '',
    Leftarrow: '',
    Leftrightarrow: '',
    LessEqualGreater: '',
    LessFullEqual: '',
    LessGreater: '',
    LessLess: '',
    LessSlantEqual: '',
    LessTilde: '',
    Lfr: '',
    Ll: '',
    Lleftarrow: '',
    Lmidot: '',
    LongLeftArrow: '',
    LongLeftRightArrow: '',
    LongRightArrow: '',
    Longleftarrow: '',
    Longleftrightarrow: '',
    Longrightarrow: '',
    Lopf: '',
    LowerLeftArrow: '',
    LowerRightArrow: '',
    Lscr: '',
    Lsh: '',
    Lstrok: '',
    Lt: '',
    Map: '',
    Mcy: '',
    MediumSpace: '',
    Mellintrf: '',
    Mfr: '',
    MinusPlus: '',
    Mopf: '',
    Mscr: '',
    Mu: '',
    NJcy: '',
    Nacute: '',
    Ncaron: '',
    Ncedil: '',
    Ncy: '',
    NegativeMediumSpace: '',
    NegativeThickSpace: '',
    NegativeThinSpace: '',
    NegativeVeryThinSpace: '',
    NestedGreaterGreater: '',
    NestedLessLess: '',
    NewLine: '\n',
    Nfr: '',
    NoBreak: '',
    NonBreakingSpace: '',
    Nopf: '',
    Not: '',
    NotCongruent: '',
    NotCupCap: '',
    NotDoubleVerticalBar: '',
    NotElement: '',
    NotEqual: '',
    NotEqualTilde: '',
    NotExists: '',
    NotGreater: '',
    NotGreaterEqual: '',
    NotGreaterFullEqual: '',
    NotGreaterGreater: '',
    NotGreaterLess: '',
    NotGreaterSlantEqual: '',
    NotGreaterTilde: '',
    NotHumpDownHump: '',
    NotHumpEqual: '',
    NotLeftTriangle: '',
    NotLeftTriangleBar: '',
    NotLeftTriangleEqual: '',
    NotLess: '',
    NotLessEqual: '',
    NotLessGreater: '',
    NotLessLess: '',
    NotLessSlantEqual: '',
    NotLessTilde: '',
    NotNestedGreaterGreater: '',
    NotNestedLessLess: '',
    NotPrecedes: '',
    NotPrecedesEqual: '',
    NotPrecedesSlantEqual: '',
    NotReverseElement: '',
    NotRightTriangle: '',
    NotRightTriangleBar: '',
    NotRightTriangleEqual: '',
    NotSquareSubset: '',
    NotSquareSubsetEqual: '',
    NotSquareSuperset: '',
    NotSquareSupersetEqual: '',
    NotSubset: '',
    NotSubsetEqual: '',
    NotSucceeds: '',
    NotSucceedsEqual: '',
    NotSucceedsSlantEqual: '',
    NotSucceedsTilde: '',
    NotSuperset: '',
    NotSupersetEqual: '',
    NotTilde: '',
    NotTildeEqual: '',
    NotTildeFullEqual: '',
    NotTildeTilde: '',
    NotVerticalBar: '',
    Nscr: '',
    Ntilde: '',
    Nu: '',
    OElig: '',
    Oacute: '',
    Ocirc: '',
    Ocy: '',
    Odblac: '',
    Ofr: '',
    Ograve: '',
    Omacr: '',
    Omega: '',
    Omicron: '',
    Oopf: '',
    OpenCurlyDoubleQuote: '',
    OpenCurlyQuote: '',
    Or: '',
    Oscr: '',
    Oslash: '',
    Otilde: '',
    Otimes: '',
    Ouml: '',
    OverBar: '',
    OverBrace: '',
    OverBracket: '',
    OverParenthesis: '',
    PartialD: '',
    Pcy: '',
    Pfr: '',
    Phi: '',
    Pi: '',
    PlusMinus: '',
    Poincareplane: '',
    Popf: '',
    Pr: '',
    Precedes: '',
    PrecedesEqual: '',
    PrecedesSlantEqual: '',
    PrecedesTilde: '',
    Prime: '',
    Product: '',
    Proportion: '',
    Proportional: '',
    Pscr: '',
    Psi: '',
    QUOT: '"',
    Qfr: '',
    Qopf: '',
    Qscr: '',
    RBarr: '',
    REG: '',
    Racute: '',
    Rang: '',
    Rarr: '',
    Rarrtl: '',
    Rcaron: '',
    Rcedil: '',
    Rcy: '',
    Re: '',
    ReverseElement: '',
    ReverseEquilibrium: '',
    ReverseUpEquilibrium: '',
    Rfr: '',
    Rho: '',
    RightAngleBracket: '',
    RightArrow: '',
    RightArrowBar: '',
    RightArrowLeftArrow: '',
    RightCeiling: '',
    RightDoubleBracket: '',
    RightDownTeeVector: '',
    RightDownVector: '',
    RightDownVectorBar: '',
    RightFloor: '',
    RightTee: '',
    RightTeeArrow: '',
    RightTeeVector: '',
    RightTriangle: '',
    RightTriangleBar: '',
    RightTriangleEqual: '',
    RightUpDownVector: '',
    RightUpTeeVector: '',
    RightUpVector: '',
    RightUpVectorBar: '',
    RightVector: '',
    RightVectorBar: '',
    Rightarrow: '',
    Ropf: '',
    RoundImplies: '',
    Rrightarrow: '',
    Rscr: '',
    Rsh: '',
    RuleDelayed: '',
    SHCHcy: '',
    SHcy: '',
    SOFTcy: '',
    Sacute: '',
    Sc: '',
    Scaron: '',
    Scedil: '',
    Scirc: '',
    Scy: '',
    Sfr: '',
    ShortDownArrow: '',
    ShortLeftArrow: '',
    ShortRightArrow: '',
    ShortUpArrow: '',
    Sigma: '',
    SmallCircle: '',
    Sopf: '',
    Sqrt: '',
    Square: '',
    SquareIntersection: '',
    SquareSubset: '',
    SquareSubsetEqual: '',
    SquareSuperset: '',
    SquareSupersetEqual: '',
    SquareUnion: '',
    Sscr: '',
    Star: '',
    Sub: '',
    Subset: '',
    SubsetEqual: '',
    Succeeds: '',
    SucceedsEqual: '',
    SucceedsSlantEqual: '',
    SucceedsTilde: '',
    SuchThat: '',
    Sum: '',
    Sup: '',
    Superset: '',
    SupersetEqual: '',
    Supset: '',
    THORN: '',
    TRADE: '',
    TSHcy: '',
    TScy: '',
    Tab: '\t',
    Tau: '',
    Tcaron: '',
    Tcedil: '',
    Tcy: '',
    Tfr: '',
    Therefore: '',
    Theta: '',
    ThickSpace: '',
    ThinSpace: '',
    Tilde: '',
    TildeEqual: '',
    TildeFullEqual: '',
    TildeTilde: '',
    Topf: '',
    TripleDot: '',
    Tscr: '',
    Tstrok: '',
    Uacute: '',
    Uarr: '',
    Uarrocir: '',
    Ubrcy: '',
    Ubreve: '',
    Ucirc: '',
    Ucy: '',
    Udblac: '',
    Ufr: '',
    Ugrave: '',
    Umacr: '',
    UnderBar: '_',
    UnderBrace: '',
    UnderBracket: '',
    UnderParenthesis: '',
    Union: '',
    UnionPlus: '',
    Uogon: '',
    Uopf: '',
    UpArrow: '',
    UpArrowBar: '',
    UpArrowDownArrow: '',
    UpDownArrow: '',
    UpEquilibrium: '',
    UpTee: '',
    UpTeeArrow: '',
    Uparrow: '',
    Updownarrow: '',
    UpperLeftArrow: '',
    UpperRightArrow: '',
    Upsi: '',
    Upsilon: '',
    Uring: '',
    Uscr: '',
    Utilde: '',
    Uuml: '',
    VDash: '',
    Vbar: '',
    Vcy: '',
    Vdash: '',
    Vdashl: '',
    Vee: '',
    Verbar: '',
    Vert: '',
    VerticalBar: '',
    VerticalLine: '|',
    VerticalSeparator: '',
    VerticalTilde: '',
    VeryThinSpace: '',
    Vfr: '',
    Vopf: '',
    Vscr: '',
    Vvdash: '',
    Wcirc: '',
    Wedge: '',
    Wfr: '',
    Wopf: '',
    Wscr: '',
    Xfr: '',
    Xi: '',
    Xopf: '',
    Xscr: '',
    YAcy: '',
    YIcy: '',
    YUcy: '',
    Yacute: '',
    Ycirc: '',
    Ycy: '',
    Yfr: '',
    Yopf: '',
    Yscr: '',
    Yuml: '',
    ZHcy: '',
    Zacute: '',
    Zcaron: '',
    Zcy: '',
    Zdot: '',
    ZeroWidthSpace: '',
    Zeta: '',
    Zfr: '',
    Zopf: '',
    Zscr: '',
    aacute: '',
    abreve: '',
    ac: '',
    acE: '',
    acd: '',
    acirc: '',
    acute: '',
    acy: '',
    aelig: '',
    af: '',
    afr: '',
    agrave: '',
    alefsym: '',
    aleph: '',
    alpha: '',
    amacr: '',
    amalg: '',
    amp: '&',
    and: '',
    andand: '',
    andd: '',
    andslope: '',
    andv: '',
    ang: '',
    ange: '',
    angle: '',
    angmsd: '',
    angmsdaa: '',
    angmsdab: '',
    angmsdac: '',
    angmsdad: '',
    angmsdae: '',
    angmsdaf: '',
    angmsdag: '',
    angmsdah: '',
    angrt: '',
    angrtvb: '',
    angrtvbd: '',
    angsph: '',
    angst: '',
    angzarr: '',
    aogon: '',
    aopf: '',
    ap: '',
    apE: '',
    apacir: '',
    ape: '',
    apid: '',
    apos: "'",
    approx: '',
    approxeq: '',
    aring: '',
    ascr: '',
    ast: '*',
    asymp: '',
    asympeq: '',
    atilde: '',
    auml: '',
    awconint: '',
    awint: '',
    bNot: '',
    backcong: '',
    backepsilon: '',
    backprime: '',
    backsim: '',
    backsimeq: '',
    barvee: '',
    barwed: '',
    barwedge: '',
    bbrk: '',
    bbrktbrk: '',
    bcong: '',
    bcy: '',
    bdquo: '',
    becaus: '',
    because: '',
    bemptyv: '',
    bepsi: '',
    bernou: '',
    beta: '',
    beth: '',
    between: '',
    bfr: '',
    bigcap: '',
    bigcirc: '',
    bigcup: '',
    bigodot: '',
    bigoplus: '',
    bigotimes: '',
    bigsqcup: '',
    bigstar: '',
    bigtriangledown: '',
    bigtriangleup: '',
    biguplus: '',
    bigvee: '',
    bigwedge: '',
    bkarow: '',
    blacklozenge: '',
    blacksquare: '',
    blacktriangle: '',
    blacktriangledown: '',
    blacktriangleleft: '',
    blacktriangleright: '',
    blank: '',
    blk12: '',
    blk14: '',
    blk34: '',
    block: '',
    bne: '=',
    bnequiv: '',
    bnot: '',
    bopf: '',
    bot: '',
    bottom: '',
    bowtie: '',
    boxDL: '',
    boxDR: '',
    boxDl: '',
    boxDr: '',
    boxH: '',
    boxHD: '',
    boxHU: '',
    boxHd: '',
    boxHu: '',
    boxUL: '',
    boxUR: '',
    boxUl: '',
    boxUr: '',
    boxV: '',
    boxVH: '',
    boxVL: '',
    boxVR: '',
    boxVh: '',
    boxVl: '',
    boxVr: '',
    boxbox: '',
    boxdL: '',
    boxdR: '',
    boxdl: '',
    boxdr: '',
    boxh: '',
    boxhD: '',
    boxhU: '',
    boxhd: '',
    boxhu: '',
    boxminus: '',
    boxplus: '',
    boxtimes: '',
    boxuL: '',
    boxuR: '',
    boxul: '',
    boxur: '',
    boxv: '',
    boxvH: '',
    boxvL: '',
    boxvR: '',
    boxvh: '',
    boxvl: '',
    boxvr: '',
    bprime: '',
    breve: '',
    brvbar: '',
    bscr: '',
    bsemi: '',
    bsim: '',
    bsime: '',
    bsol: '\\',
    bsolb: '',
    bsolhsub: '',
    bull: '',
    bullet: '',
    bump: '',
    bumpE: '',
    bumpe: '',
    bumpeq: '',
    cacute: '',
    cap: '',
    capand: '',
    capbrcup: '',
    capcap: '',
    capcup: '',
    capdot: '',
    caps: '',
    caret: '',
    caron: '',
    ccaps: '',
    ccaron: '',
    ccedil: '',
    ccirc: '',
    ccups: '',
    ccupssm: '',
    cdot: '',
    cedil: '',
    cemptyv: '',
    cent: '',
    centerdot: '',
    cfr: '',
    chcy: '',
    check: '',
    checkmark: '',
    chi: '',
    cir: '',
    cirE: '',
    circ: '',
    circeq: '',
    circlearrowleft: '',
    circlearrowright: '',
    circledR: '',
    circledS: '',
    circledast: '',
    circledcirc: '',
    circleddash: '',
    cire: '',
    cirfnint: '',
    cirmid: '',
    cirscir: '',
    clubs: '',
    clubsuit: '',
    colon: ':',
    colone: '',
    coloneq: '',
    comma: ',',
    commat: '@',
    comp: '',
    compfn: '',
    complement: '',
    complexes: '',
    cong: '',
    congdot: '',
    conint: '',
    copf: '',
    coprod: '',
    copy: '',
    copysr: '',
    crarr: '',
    cross: '',
    cscr: '',
    csub: '',
    csube: '',
    csup: '',
    csupe: '',
    ctdot: '',
    cudarrl: '',
    cudarrr: '',
    cuepr: '',
    cuesc: '',
    cularr: '',
    cularrp: '',
    cup: '',
    cupbrcap: '',
    cupcap: '',
    cupcup: '',
    cupdot: '',
    cupor: '',
    cups: '',
    curarr: '',
    curarrm: '',
    curlyeqprec: '',
    curlyeqsucc: '',
    curlyvee: '',
    curlywedge: '',
    curren: '',
    curvearrowleft: '',
    curvearrowright: '',
    cuvee: '',
    cuwed: '',
    cwconint: '',
    cwint: '',
    cylcty: '',
    dArr: '',
    dHar: '',
    dagger: '',
    daleth: '',
    darr: '',
    dash: '',
    dashv: '',
    dbkarow: '',
    dblac: '',
    dcaron: '',
    dcy: '',
    dd: '',
    ddagger: '',
    ddarr: '',
    ddotseq: '',
    deg: '',
    delta: '',
    demptyv: '',
    dfisht: '',
    dfr: '',
    dharl: '',
    dharr: '',
    diam: '',
    diamond: '',
    diamondsuit: '',
    diams: '',
    die: '',
    digamma: '',
    disin: '',
    div: '',
    divide: '',
    divideontimes: '',
    divonx: '',
    djcy: '',
    dlcorn: '',
    dlcrop: '',
    dollar: '$',
    dopf: '',
    dot: '',
    doteq: '',
    doteqdot: '',
    dotminus: '',
    dotplus: '',
    dotsquare: '',
    doublebarwedge: '',
    downarrow: '',
    downdownarrows: '',
    downharpoonleft: '',
    downharpoonright: '',
    drbkarow: '',
    drcorn: '',
    drcrop: '',
    dscr: '',
    dscy: '',
    dsol: '',
    dstrok: '',
    dtdot: '',
    dtri: '',
    dtrif: '',
    duarr: '',
    duhar: '',
    dwangle: '',
    dzcy: '',
    dzigrarr: '',
    eDDot: '',
    eDot: '',
    eacute: '',
    easter: '',
    ecaron: '',
    ecir: '',
    ecirc: '',
    ecolon: '',
    ecy: '',
    edot: '',
    ee: '',
    efDot: '',
    efr: '',
    eg: '',
    egrave: '',
    egs: '',
    egsdot: '',
    el: '',
    elinters: '',
    ell: '',
    els: '',
    elsdot: '',
    emacr: '',
    empty: '',
    emptyset: '',
    emptyv: '',
    emsp13: '',
    emsp14: '',
    emsp: '',
    eng: '',
    ensp: '',
    eogon: '',
    eopf: '',
    epar: '',
    eparsl: '',
    eplus: '',
    epsi: '',
    epsilon: '',
    epsiv: '',
    eqcirc: '',
    eqcolon: '',
    eqsim: '',
    eqslantgtr: '',
    eqslantless: '',
    equals: '=',
    equest: '',
    equiv: '',
    equivDD: '',
    eqvparsl: '',
    erDot: '',
    erarr: '',
    escr: '',
    esdot: '',
    esim: '',
    eta: '',
    eth: '',
    euml: '',
    euro: '',
    excl: '!',
    exist: '',
    expectation: '',
    exponentiale: '',
    fallingdotseq: '',
    fcy: '',
    female: '',
    ffilig: '',
    fflig: '',
    ffllig: '',
    ffr: '',
    filig: '',
    fjlig: 'fj',
    flat: '',
    fllig: '',
    fltns: '',
    fnof: '',
    fopf: '',
    forall: '',
    fork: '',
    forkv: '',
    fpartint: '',
    frac12: '',
    frac13: '',
    frac14: '',
    frac15: '',
    frac16: '',
    frac18: '',
    frac23: '',
    frac25: '',
    frac34: '',
    frac35: '',
    frac38: '',
    frac45: '',
    frac56: '',
    frac58: '',
    frac78: '',
    frasl: '',
    frown: '',
    fscr: '',
    gE: '',
    gEl: '',
    gacute: '',
    gamma: '',
    gammad: '',
    gap: '',
    gbreve: '',
    gcirc: '',
    gcy: '',
    gdot: '',
    ge: '',
    gel: '',
    geq: '',
    geqq: '',
    geqslant: '',
    ges: '',
    gescc: '',
    gesdot: '',
    gesdoto: '',
    gesdotol: '',
    gesl: '',
    gesles: '',
    gfr: '',
    gg: '',
    ggg: '',
    gimel: '',
    gjcy: '',
    gl: '',
    glE: '',
    gla: '',
    glj: '',
    gnE: '',
    gnap: '',
    gnapprox: '',
    gne: '',
    gneq: '',
    gneqq: '',
    gnsim: '',
    gopf: '',
    grave: '`',
    gscr: '',
    gsim: '',
    gsime: '',
    gsiml: '',
    gt: '>',
    gtcc: '',
    gtcir: '',
    gtdot: '',
    gtlPar: '',
    gtquest: '',
    gtrapprox: '',
    gtrarr: '',
    gtrdot: '',
    gtreqless: '',
    gtreqqless: '',
    gtrless: '',
    gtrsim: '',
    gvertneqq: '',
    gvnE: '',
    hArr: '',
    hairsp: '',
    half: '',
    hamilt: '',
    hardcy: '',
    harr: '',
    harrcir: '',
    harrw: '',
    hbar: '',
    hcirc: '',
    hearts: '',
    heartsuit: '',
    hellip: '',
    hercon: '',
    hfr: '',
    hksearow: '',
    hkswarow: '',
    hoarr: '',
    homtht: '',
    hookleftarrow: '',
    hookrightarrow: '',
    hopf: '',
    horbar: '',
    hscr: '',
    hslash: '',
    hstrok: '',
    hybull: '',
    hyphen: '',
    iacute: '',
    ic: '',
    icirc: '',
    icy: '',
    iecy: '',
    iexcl: '',
    iff: '',
    ifr: '',
    igrave: '',
    ii: '',
    iiiint: '',
    iiint: '',
    iinfin: '',
    iiota: '',
    ijlig: '',
    imacr: '',
    image: '',
    imagline: '',
    imagpart: '',
    imath: '',
    imof: '',
    imped: '',
    in: '',
    incare: '',
    infin: '',
    infintie: '',
    inodot: '',
    int: '',
    intcal: '',
    integers: '',
    intercal: '',
    intlarhk: '',
    intprod: '',
    iocy: '',
    iogon: '',
    iopf: '',
    iota: '',
    iprod: '',
    iquest: '',
    iscr: '',
    isin: '',
    isinE: '',
    isindot: '',
    isins: '',
    isinsv: '',
    isinv: '',
    it: '',
    itilde: '',
    iukcy: '',
    iuml: '',
    jcirc: '',
    jcy: '',
    jfr: '',
    jmath: '',
    jopf: '',
    jscr: '',
    jsercy: '',
    jukcy: '',
    kappa: '',
    kappav: '',
    kcedil: '',
    kcy: '',
    kfr: '',
    kgreen: '',
    khcy: '',
    kjcy: '',
    kopf: '',
    kscr: '',
    lAarr: '',
    lArr: '',
    lAtail: '',
    lBarr: '',
    lE: '',
    lEg: '',
    lHar: '',
    lacute: '',
    laemptyv: '',
    lagran: '',
    lambda: '',
    lang: '',
    langd: '',
    langle: '',
    lap: '',
    laquo: '',
    larr: '',
    larrb: '',
    larrbfs: '',
    larrfs: '',
    larrhk: '',
    larrlp: '',
    larrpl: '',
    larrsim: '',
    larrtl: '',
    lat: '',
    latail: '',
    late: '',
    lates: '',
    lbarr: '',
    lbbrk: '',
    lbrace: '{',
    lbrack: '[',
    lbrke: '',
    lbrksld: '',
    lbrkslu: '',
    lcaron: '',
    lcedil: '',
    lceil: '',
    lcub: '{',
    lcy: '',
    ldca: '',
    ldquo: '',
    ldquor: '',
    ldrdhar: '',
    ldrushar: '',
    ldsh: '',
    le: '',
    leftarrow: '',
    leftarrowtail: '',
    leftharpoondown: '',
    leftharpoonup: '',
    leftleftarrows: '',
    leftrightarrow: '',
    leftrightarrows: '',
    leftrightharpoons: '',
    leftrightsquigarrow: '',
    leftthreetimes: '',
    leg: '',
    leq: '',
    leqq: '',
    leqslant: '',
    les: '',
    lescc: '',
    lesdot: '',
    lesdoto: '',
    lesdotor: '',
    lesg: '',
    lesges: '',
    lessapprox: '',
    lessdot: '',
    lesseqgtr: '',
    lesseqqgtr: '',
    lessgtr: '',
    lesssim: '',
    lfisht: '',
    lfloor: '',
    lfr: '',
    lg: '',
    lgE: '',
    lhard: '',
    lharu: '',
    lharul: '',
    lhblk: '',
    ljcy: '',
    ll: '',
    llarr: '',
    llcorner: '',
    llhard: '',
    lltri: '',
    lmidot: '',
    lmoust: '',
    lmoustache: '',
    lnE: '',
    lnap: '',
    lnapprox: '',
    lne: '',
    lneq: '',
    lneqq: '',
    lnsim: '',
    loang: '',
    loarr: '',
    lobrk: '',
    longleftarrow: '',
    longleftrightarrow: '',
    longmapsto: '',
    longrightarrow: '',
    looparrowleft: '',
    looparrowright: '',
    lopar: '',
    lopf: '',
    loplus: '',
    lotimes: '',
    lowast: '',
    lowbar: '_',
    loz: '',
    lozenge: '',
    lozf: '',
    lpar: '(',
    lparlt: '',
    lrarr: '',
    lrcorner: '',
    lrhar: '',
    lrhard: '',
    lrm: '',
    lrtri: '',
    lsaquo: '',
    lscr: '',
    lsh: '',
    lsim: '',
    lsime: '',
    lsimg: '',
    lsqb: '[',
    lsquo: '',
    lsquor: '',
    lstrok: '',
    lt: '<',
    ltcc: '',
    ltcir: '',
    ltdot: '',
    lthree: '',
    ltimes: '',
    ltlarr: '',
    ltquest: '',
    ltrPar: '',
    ltri: '',
    ltrie: '',
    ltrif: '',
    lurdshar: '',
    luruhar: '',
    lvertneqq: '',
    lvnE: '',
    mDDot: '',
    macr: '',
    male: '',
    malt: '',
    maltese: '',
    map: '',
    mapsto: '',
    mapstodown: '',
    mapstoleft: '',
    mapstoup: '',
    marker: '',
    mcomma: '',
    mcy: '',
    mdash: '',
    measuredangle: '',
    mfr: '',
    mho: '',
    micro: '',
    mid: '',
    midast: '*',
    midcir: '',
    middot: '',
    minus: '',
    minusb: '',
    minusd: '',
    minusdu: '',
    mlcp: '',
    mldr: '',
    mnplus: '',
    models: '',
    mopf: '',
    mp: '',
    mscr: '',
    mstpos: '',
    mu: '',
    multimap: '',
    mumap: '',
    nGg: '',
    nGt: '',
    nGtv: '',
    nLeftarrow: '',
    nLeftrightarrow: '',
    nLl: '',
    nLt: '',
    nLtv: '',
    nRightarrow: '',
    nVDash: '',
    nVdash: '',
    nabla: '',
    nacute: '',
    nang: '',
    nap: '',
    napE: '',
    napid: '',
    napos: '',
    napprox: '',
    natur: '',
    natural: '',
    naturals: '',
    nbsp: '',
    nbump: '',
    nbumpe: '',
    ncap: '',
    ncaron: '',
    ncedil: '',
    ncong: '',
    ncongdot: '',
    ncup: '',
    ncy: '',
    ndash: '',
    ne: '',
    neArr: '',
    nearhk: '',
    nearr: '',
    nearrow: '',
    nedot: '',
    nequiv: '',
    nesear: '',
    nesim: '',
    nexist: '',
    nexists: '',
    nfr: '',
    ngE: '',
    nge: '',
    ngeq: '',
    ngeqq: '',
    ngeqslant: '',
    nges: '',
    ngsim: '',
    ngt: '',
    ngtr: '',
    nhArr: '',
    nharr: '',
    nhpar: '',
    ni: '',
    nis: '',
    nisd: '',
    niv: '',
    njcy: '',
    nlArr: '',
    nlE: '',
    nlarr: '',
    nldr: '',
    nle: '',
    nleftarrow: '',
    nleftrightarrow: '',
    nleq: '',
    nleqq: '',
    nleqslant: '',
    nles: '',
    nless: '',
    nlsim: '',
    nlt: '',
    nltri: '',
    nltrie: '',
    nmid: '',
    nopf: '',
    not: '',
    notin: '',
    notinE: '',
    notindot: '',
    notinva: '',
    notinvb: '',
    notinvc: '',
    notni: '',
    notniva: '',
    notnivb: '',
    notnivc: '',
    npar: '',
    nparallel: '',
    nparsl: '',
    npart: '',
    npolint: '',
    npr: '',
    nprcue: '',
    npre: '',
    nprec: '',
    npreceq: '',
    nrArr: '',
    nrarr: '',
    nrarrc: '',
    nrarrw: '',
    nrightarrow: '',
    nrtri: '',
    nrtrie: '',
    nsc: '',
    nsccue: '',
    nsce: '',
    nscr: '',
    nshortmid: '',
    nshortparallel: '',
    nsim: '',
    nsime: '',
    nsimeq: '',
    nsmid: '',
    nspar: '',
    nsqsube: '',
    nsqsupe: '',
    nsub: '',
    nsubE: '',
    nsube: '',
    nsubset: '',
    nsubseteq: '',
    nsubseteqq: '',
    nsucc: '',
    nsucceq: '',
    nsup: '',
    nsupE: '',
    nsupe: '',
    nsupset: '',
    nsupseteq: '',
    nsupseteqq: '',
    ntgl: '',
    ntilde: '',
    ntlg: '',
    ntriangleleft: '',
    ntrianglelefteq: '',
    ntriangleright: '',
    ntrianglerighteq: '',
    nu: '',
    num: '#',
    numero: '',
    numsp: '',
    nvDash: '',
    nvHarr: '',
    nvap: '',
    nvdash: '',
    nvge: '',
    nvgt: '>',
    nvinfin: '',
    nvlArr: '',
    nvle: '',
    nvlt: '<',
    nvltrie: '',
    nvrArr: '',
    nvrtrie: '',
    nvsim: '',
    nwArr: '',
    nwarhk: '',
    nwarr: '',
    nwarrow: '',
    nwnear: '',
    oS: '',
    oacute: '',
    oast: '',
    ocir: '',
    ocirc: '',
    ocy: '',
    odash: '',
    odblac: '',
    odiv: '',
    odot: '',
    odsold: '',
    oelig: '',
    ofcir: '',
    ofr: '',
    ogon: '',
    ograve: '',
    ogt: '',
    ohbar: '',
    ohm: '',
    oint: '',
    olarr: '',
    olcir: '',
    olcross: '',
    oline: '',
    olt: '',
    omacr: '',
    omega: '',
    omicron: '',
    omid: '',
    ominus: '',
    oopf: '',
    opar: '',
    operp: '',
    oplus: '',
    or: '',
    orarr: '',
    ord: '',
    order: '',
    orderof: '',
    ordf: '',
    ordm: '',
    origof: '',
    oror: '',
    orslope: '',
    orv: '',
    oscr: '',
    oslash: '',
    osol: '',
    otilde: '',
    otimes: '',
    otimesas: '',
    ouml: '',
    ovbar: '',
    par: '',
    para: '',
    parallel: '',
    parsim: '',
    parsl: '',
    part: '',
    pcy: '',
    percnt: '%',
    period: '.',
    permil: '',
    perp: '',
    pertenk: '',
    pfr: '',
    phi: '',
    phiv: '',
    phmmat: '',
    phone: '',
    pi: '',
    pitchfork: '',
    piv: '',
    planck: '',
    planckh: '',
    plankv: '',
    plus: '+',
    plusacir: '',
    plusb: '',
    pluscir: '',
    plusdo: '',
    plusdu: '',
    pluse: '',
    plusmn: '',
    plussim: '',
    plustwo: '',
    pm: '',
    pointint: '',
    popf: '',
    pound: '',
    pr: '',
    prE: '',
    prap: '',
    prcue: '',
    pre: '',
    prec: '',
    precapprox: '',
    preccurlyeq: '',
    preceq: '',
    precnapprox: '',
    precneqq: '',
    precnsim: '',
    precsim: '',
    prime: '',
    primes: '',
    prnE: '',
    prnap: '',
    prnsim: '',
    prod: '',
    profalar: '',
    profline: '',
    profsurf: '',
    prop: '',
    propto: '',
    prsim: '',
    prurel: '',
    pscr: '',
    psi: '',
    puncsp: '',
    qfr: '',
    qint: '',
    qopf: '',
    qprime: '',
    qscr: '',
    quaternions: '',
    quatint: '',
    quest: '?',
    questeq: '',
    quot: '"',
    rAarr: '',
    rArr: '',
    rAtail: '',
    rBarr: '',
    rHar: '',
    race: '',
    racute: '',
    radic: '',
    raemptyv: '',
    rang: '',
    rangd: '',
    range: '',
    rangle: '',
    raquo: '',
    rarr: '',
    rarrap: '',
    rarrb: '',
    rarrbfs: '',
    rarrc: '',
    rarrfs: '',
    rarrhk: '',
    rarrlp: '',
    rarrpl: '',
    rarrsim: '',
    rarrtl: '',
    rarrw: '',
    ratail: '',
    ratio: '',
    rationals: '',
    rbarr: '',
    rbbrk: '',
    rbrace: '}',
    rbrack: ']',
    rbrke: '',
    rbrksld: '',
    rbrkslu: '',
    rcaron: '',
    rcedil: '',
    rceil: '',
    rcub: '}',
    rcy: '',
    rdca: '',
    rdldhar: '',
    rdquo: '',
    rdquor: '',
    rdsh: '',
    real: '',
    realine: '',
    realpart: '',
    reals: '',
    rect: '',
    reg: '',
    rfisht: '',
    rfloor: '',
    rfr: '',
    rhard: '',
    rharu: '',
    rharul: '',
    rho: '',
    rhov: '',
    rightarrow: '',
    rightarrowtail: '',
    rightharpoondown: '',
    rightharpoonup: '',
    rightleftarrows: '',
    rightleftharpoons: '',
    rightrightarrows: '',
    rightsquigarrow: '',
    rightthreetimes: '',
    ring: '',
    risingdotseq: '',
    rlarr: '',
    rlhar: '',
    rlm: '',
    rmoust: '',
    rmoustache: '',
    rnmid: '',
    roang: '',
    roarr: '',
    robrk: '',
    ropar: '',
    ropf: '',
    roplus: '',
    rotimes: '',
    rpar: ')',
    rpargt: '',
    rppolint: '',
    rrarr: '',
    rsaquo: '',
    rscr: '',
    rsh: '',
    rsqb: ']',
    rsquo: '',
    rsquor: '',
    rthree: '',
    rtimes: '',
    rtri: '',
    rtrie: '',
    rtrif: '',
    rtriltri: '',
    ruluhar: '',
    rx: '',
    sacute: '',
    sbquo: '',
    sc: '',
    scE: '',
    scap: '',
    scaron: '',
    sccue: '',
    sce: '',
    scedil: '',
    scirc: '',
    scnE: '',
    scnap: '',
    scnsim: '',
    scpolint: '',
    scsim: '',
    scy: '',
    sdot: '',
    sdotb: '',
    sdote: '',
    seArr: '',
    searhk: '',
    searr: '',
    searrow: '',
    sect: '',
    semi: ';',
    seswar: '',
    setminus: '',
    setmn: '',
    sext: '',
    sfr: '',
    sfrown: '',
    sharp: '',
    shchcy: '',
    shcy: '',
    shortmid: '',
    shortparallel: '',
    shy: '',
    sigma: '',
    sigmaf: '',
    sigmav: '',
    sim: '',
    simdot: '',
    sime: '',
    simeq: '',
    simg: '',
    simgE: '',
    siml: '',
    simlE: '',
    simne: '',
    simplus: '',
    simrarr: '',
    slarr: '',
    smallsetminus: '',
    smashp: '',
    smeparsl: '',
    smid: '',
    smile: '',
    smt: '',
    smte: '',
    smtes: '',
    softcy: '',
    sol: '/',
    solb: '',
    solbar: '',
    sopf: '',
    spades: '',
    spadesuit: '',
    spar: '',
    sqcap: '',
    sqcaps: '',
    sqcup: '',
    sqcups: '',
    sqsub: '',
    sqsube: '',
    sqsubset: '',
    sqsubseteq: '',
    sqsup: '',
    sqsupe: '',
    sqsupset: '',
    sqsupseteq: '',
    squ: '',
    square: '',
    squarf: '',
    squf: '',
    srarr: '',
    sscr: '',
    ssetmn: '',
    ssmile: '',
    sstarf: '',
    star: '',
    starf: '',
    straightepsilon: '',
    straightphi: '',
    strns: '',
    sub: '',
    subE: '',
    subdot: '',
    sube: '',
    subedot: '',
    submult: '',
    subnE: '',
    subne: '',
    subplus: '',
    subrarr: '',
    subset: '',
    subseteq: '',
    subseteqq: '',
    subsetneq: '',
    subsetneqq: '',
    subsim: '',
    subsub: '',
    subsup: '',
    succ: '',
    succapprox: '',
    succcurlyeq: '',
    succeq: '',
    succnapprox: '',
    succneqq: '',
    succnsim: '',
    succsim: '',
    sum: '',
    sung: '',
    sup1: '',
    sup2: '',
    sup3: '',
    sup: '',
    supE: '',
    supdot: '',
    supdsub: '',
    supe: '',
    supedot: '',
    suphsol: '',
    suphsub: '',
    suplarr: '',
    supmult: '',
    supnE: '',
    supne: '',
    supplus: '',
    supset: '',
    supseteq: '',
    supseteqq: '',
    supsetneq: '',
    supsetneqq: '',
    supsim: '',
    supsub: '',
    supsup: '',
    swArr: '',
    swarhk: '',
    swarr: '',
    swarrow: '',
    swnwar: '',
    szlig: '',
    target: '',
    tau: '',
    tbrk: '',
    tcaron: '',
    tcedil: '',
    tcy: '',
    tdot: '',
    telrec: '',
    tfr: '',
    there4: '',
    therefore: '',
    theta: '',
    thetasym: '',
    thetav: '',
    thickapprox: '',
    thicksim: '',
    thinsp: '',
    thkap: '',
    thksim: '',
    thorn: '',
    tilde: '',
    times: '',
    timesb: '',
    timesbar: '',
    timesd: '',
    tint: '',
    toea: '',
    top: '',
    topbot: '',
    topcir: '',
    topf: '',
    topfork: '',
    tosa: '',
    tprime: '',
    trade: '',
    triangle: '',
    triangledown: '',
    triangleleft: '',
    trianglelefteq: '',
    triangleq: '',
    triangleright: '',
    trianglerighteq: '',
    tridot: '',
    trie: '',
    triminus: '',
    triplus: '',
    trisb: '',
    tritime: '',
    trpezium: '',
    tscr: '',
    tscy: '',
    tshcy: '',
    tstrok: '',
    twixt: '',
    twoheadleftarrow: '',
    twoheadrightarrow: '',
    uArr: '',
    uHar: '',
    uacute: '',
    uarr: '',
    ubrcy: '',
    ubreve: '',
    ucirc: '',
    ucy: '',
    udarr: '',
    udblac: '',
    udhar: '',
    ufisht: '',
    ufr: '',
    ugrave: '',
    uharl: '',
    uharr: '',
    uhblk: '',
    ulcorn: '',
    ulcorner: '',
    ulcrop: '',
    ultri: '',
    umacr: '',
    uml: '',
    uogon: '',
    uopf: '',
    uparrow: '',
    updownarrow: '',
    upharpoonleft: '',
    upharpoonright: '',
    uplus: '',
    upsi: '',
    upsih: '',
    upsilon: '',
    upuparrows: '',
    urcorn: '',
    urcorner: '',
    urcrop: '',
    uring: '',
    urtri: '',
    uscr: '',
    utdot: '',
    utilde: '',
    utri: '',
    utrif: '',
    uuarr: '',
    uuml: '',
    uwangle: '',
    vArr: '',
    vBar: '',
    vBarv: '',
    vDash: '',
    vangrt: '',
    varepsilon: '',
    varkappa: '',
    varnothing: '',
    varphi: '',
    varpi: '',
    varpropto: '',
    varr: '',
    varrho: '',
    varsigma: '',
    varsubsetneq: '',
    varsubsetneqq: '',
    varsupsetneq: '',
    varsupsetneqq: '',
    vartheta: '',
    vartriangleleft: '',
    vartriangleright: '',
    vcy: '',
    vdash: '',
    vee: '',
    veebar: '',
    veeeq: '',
    vellip: '',
    verbar: '|',
    vert: '|',
    vfr: '',
    vltri: '',
    vnsub: '',
    vnsup: '',
    vopf: '',
    vprop: '',
    vrtri: '',
    vscr: '',
    vsubnE: '',
    vsubne: '',
    vsupnE: '',
    vsupne: '',
    vzigzag: '',
    wcirc: '',
    wedbar: '',
    wedge: '',
    wedgeq: '',
    weierp: '',
    wfr: '',
    wopf: '',
    wp: '',
    wr: '',
    wreath: '',
    wscr: '',
    xcap: '',
    xcirc: '',
    xcup: '',
    xdtri: '',
    xfr: '',
    xhArr: '',
    xharr: '',
    xi: '',
    xlArr: '',
    xlarr: '',
    xmap: '',
    xnis: '',
    xodot: '',
    xopf: '',
    xoplus: '',
    xotime: '',
    xrArr: '',
    xrarr: '',
    xscr: '',
    xsqcup: '',
    xuplus: '',
    xutri: '',
    xvee: '',
    xwedge: '',
    yacute: '',
    yacy: '',
    ycirc: '',
    ycy: '',
    yen: '',
    yfr: '',
    yicy: '',
    yopf: '',
    yscr: '',
    yucy: '',
    yuml: '',
    zacute: '',
    zcaron: '',
    zcy: '',
    zdot: '',
    zeetrf: '',
    zeta: '',
    zfr: '',
    zhcy: '',
    zigrarr: '',
    zopf: '',
    zscr: '',
    zwj: '',
    zwnj: '',
  };
  const decodeMap = {
    0: 65533,
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376,
  };
  function decodeHTMLStrict(text) {
    return text.replace(/&(?:[a-zA-Z]+|#[xX][\da-fA-F]+|#\d+);/g, (key) => {
      if (key.charAt(1) === '#') {
        const secondChar = key.charAt(2);
        const codePoint =
          secondChar === 'X' || secondChar === 'x'
            ? parseInt(key.slice(3), 16)
            : parseInt(key.slice(2), 10);
        return decodeCodePoint(codePoint);
      }
      return getOwnProperty(entities, key.slice(1, -1)) ?? key;
    });
  }
  function decodeCodePoint(codePoint) {
    if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
      return '';
    }
    return String.fromCodePoint(
      getOwnProperty(decodeMap, codePoint) ?? codePoint,
    );
  }
  function scanJSXAttributeValue(parser, context) {
    parser.startIndex = parser.tokenIndex = parser.index;
    parser.startColumn = parser.tokenColumn = parser.column;
    parser.startLine = parser.tokenLine = parser.line;
    parser.setToken(
      CharTypes[parser.currentChar] & 8192
        ? scanJSXString(parser)
        : scanSingleToken(parser, context, 0),
    );
    return parser.getToken();
  }
  function scanJSXString(parser) {
    const quote = parser.currentChar;
    let char = advanceChar(parser);
    const start = parser.index;
    while (char !== quote) {
      if (parser.index >= parser.end) parser.report(16);
      char = advanceChar(parser);
    }
    if (char !== quote) parser.report(16);
    parser.tokenValue = parser.source.slice(start, parser.index);
    advanceChar(parser);
    if (parser.options.raw)
      parser.tokenRaw = parser.source.slice(parser.tokenIndex, parser.index);
    return 134283267;
  }
  function nextJSXToken(parser) {
    parser.startIndex = parser.tokenIndex = parser.index;
    parser.startColumn = parser.tokenColumn = parser.column;
    parser.startLine = parser.tokenLine = parser.line;
    if (parser.index >= parser.end) {
      parser.setToken(1048576);
      return;
    }
    if (parser.currentChar === 60) {
      advanceChar(parser);
      parser.setToken(8456256);
      return;
    }
    if (parser.currentChar === 123) {
      advanceChar(parser);
      parser.setToken(2162700);
      return;
    }
    let state = 0;
    while (parser.index < parser.end) {
      const type = CharTypes[parser.source.charCodeAt(parser.index)];
      if (type & 1024) {
        state |= 1 | 4;
        scanNewLine(parser);
      } else if (type & 2048) {
        consumeLineFeed(parser, state);
        state = (state & -5) | 1;
      } else {
        advanceChar(parser);
      }
      if (CharTypes[parser.currentChar] & 16384) break;
    }
    if (parser.tokenIndex === parser.index) parser.report(0);
    const raw = parser.source.slice(parser.tokenIndex, parser.index);
    if (parser.options.raw) parser.tokenRaw = raw;
    parser.tokenValue = decodeHTMLStrict(raw);
    parser.setToken(137);
  }
  function rescanJSXIdentifier(parser) {
    if ((parser.getToken() & 143360) === 143360) {
      const { index: index } = parser;
      let char = parser.currentChar;
      while (CharTypes[char] & (32768 | 2)) {
        char = advanceChar(parser);
      }
      parser.tokenValue += parser.source.slice(index, parser.index);
      parser.setToken(208897, true);
    }
    return parser.getToken();
  }
  class Scope {
    parser;
    type;
    parent;
    scopeError;
    variableBindings = new Map();
    constructor(parser, type = 2, parent) {
      this.parser = parser;
      this.type = type;
      this.parent = parent;
    }
    createChildScope(type) {
      return new Scope(this.parser, type, this);
    }
    addVarOrBlock(context, name, kind, origin) {
      if (kind & 4) {
        this.addVarName(context, name, kind);
      } else {
        this.addBlockName(context, name, kind, origin);
      }
      if (origin & 64) {
        this.parser.declareUnboundVariable(name);
      }
    }
    addVarName(context, name, kind) {
      const { parser: parser } = this;
      let currentScope = this;
      while (currentScope && (currentScope.type & 128) === 0) {
        const { variableBindings: variableBindings } = currentScope;
        const value = variableBindings.get(name);
        if (value && value & 248) {
          if (
            parser.options.webcompat &&
            (context & 1) === 0 &&
            ((kind & 128 && value & 68) || (value & 128 && kind & 68))
          );
          else {
            parser.report(145, name);
          }
        }
        if (currentScope === this) {
          if (value && value & 1 && kind & 1) {
            currentScope.recordScopeError(145, name);
          }
        }
        if (
          value &&
          (value & 256 || (value & 512 && !parser.options.webcompat))
        ) {
          parser.report(145, name);
        }
        currentScope.variableBindings.set(name, kind);
        currentScope = currentScope.parent;
      }
    }
    hasVariable(name) {
      return this.variableBindings.has(name);
    }
    addBlockName(context, name, kind, origin) {
      const { parser: parser } = this;
      const value = this.variableBindings.get(name);
      if (value && (value & 2) === 0) {
        if (kind & 1) {
          this.recordScopeError(145, name);
        } else if (
          parser.options.webcompat &&
          (context & 1) === 0 &&
          origin & 2 &&
          value === 64 &&
          kind === 64
        );
        else {
          parser.report(145, name);
        }
      }
      if (
        this.type & 64 &&
        this.parent?.hasVariable(name) &&
        (this.parent.variableBindings.get(name) & 2) === 0
      ) {
        parser.report(145, name);
      }
      if (this.type & 512 && value && (value & 2) === 0) {
        if (kind & 1) {
          this.recordScopeError(145, name);
        }
      }
      if (this.type & 32) {
        if (this.parent.variableBindings.get(name) & 768)
          parser.report(159, name);
      }
      this.variableBindings.set(name, kind);
    }
    recordScopeError(type, ...params) {
      this.scopeError = {
        type: type,
        params: params,
        start: this.parser.tokenStart,
        end: this.parser.currentLocation,
      };
    }
    reportScopeError() {
      const { scopeError: scopeError } = this;
      if (!scopeError) {
        return;
      }
      throw new ParseError(
        scopeError.start,
        scopeError.end,
        scopeError.type,
        ...scopeError.params,
      );
    }
  }
  function createArrowHeadParsingScope(parser, context, value) {
    const scope = parser.createScope().createChildScope(512);
    scope.addBlockName(context, value, 1, 0);
    return scope;
  }
  class PrivateScope {
    parser;
    parent;
    refs = Object.create(null);
    privateIdentifiers = new Map();
    constructor(parser, parent) {
      this.parser = parser;
      this.parent = parent;
    }
    addPrivateIdentifier(name, kind) {
      const { privateIdentifiers: privateIdentifiers } = this;
      let focusKind = kind & (32 | 768);
      if (!(focusKind & 768)) focusKind |= 768;
      const value = privateIdentifiers.get(name);
      if (
        this.hasPrivateIdentifier(name) &&
        ((value & 32) !== (focusKind & 32) || value & focusKind & 768)
      ) {
        this.parser.report(146, name);
      }
      privateIdentifiers.set(
        name,
        this.hasPrivateIdentifier(name) ? value | focusKind : focusKind,
      );
    }
    addPrivateIdentifierRef(name) {
      this.refs[name] ??= [];
      this.refs[name].push(this.parser.tokenStart);
    }
    isPrivateIdentifierDefined(name) {
      return (
        this.hasPrivateIdentifier(name) ||
        Boolean(this.parent?.isPrivateIdentifierDefined(name))
      );
    }
    validatePrivateIdentifierRefs() {
      for (const name in this.refs) {
        if (!this.isPrivateIdentifierDefined(name)) {
          const {
            index: index,
            line: line,
            column: column,
          } = this.refs[name][0];
          throw new ParseError(
            { index: index, line: line, column: column },
            {
              index: index + name.length,
              line: line,
              column: column + name.length,
            },
            4,
            name,
          );
        }
      }
    }
    hasPrivateIdentifier(name) {
      return this.privateIdentifiers.has(name);
    }
  }
  class Parser {
    source;
    options;
    lastOnToken = null;
    token = 1048576;
    flags = 0;
    index = 0;
    line = 1;
    column = 0;
    startIndex = 0;
    end = 0;
    tokenIndex = 0;
    startColumn = 0;
    tokenColumn = 0;
    tokenLine = 1;
    startLine = 1;
    tokenValue = '';
    tokenRaw = '';
    tokenRegExp = void 0;
    currentChar = 0;
    exportedNames = new Set();
    exportedBindings = new Set();
    assignable = 1;
    destructible = 0;
    leadingDecorators = { decorators: [] };
    constructor(source, options = {}) {
      this.source = source;
      this.options = options;
      this.end = source.length;
      this.currentChar = source.charCodeAt(0);
    }
    getToken() {
      return this.token;
    }
    setToken(value, replaceLast = false) {
      this.token = value;
      const { onToken: onToken } = this.options;
      if (onToken) {
        if (value !== 1048576) {
          const loc = {
            start: { line: this.tokenLine, column: this.tokenColumn },
            end: { line: this.line, column: this.column },
          };
          if (!replaceLast && this.lastOnToken) {
            onToken(...this.lastOnToken);
          }
          this.lastOnToken = [
            convertTokenType(value),
            this.tokenIndex,
            this.index,
            loc,
          ];
        } else {
          if (this.lastOnToken) {
            onToken(...this.lastOnToken);
            this.lastOnToken = null;
          }
        }
      }
      return value;
    }
    get tokenStart() {
      return {
        index: this.tokenIndex,
        line: this.tokenLine,
        column: this.tokenColumn,
      };
    }
    get currentLocation() {
      return { index: this.index, line: this.line, column: this.column };
    }
    finishNode(node, start, end) {
      if (this.options.ranges) {
        node.start = start.index;
        const endIndex = end ? end.index : this.startIndex;
        node.end = endIndex;
        node.range = [start.index, endIndex];
      }
      if (this.options.loc) {
        node.loc = {
          start: { line: start.line, column: start.column },
          end: end
            ? { line: end.line, column: end.column }
            : { line: this.startLine, column: this.startColumn },
        };
        if (this.options.source) {
          node.loc.source = this.options.source;
        }
      }
      return node;
    }
    addBindingToExports(name) {
      this.exportedBindings.add(name);
    }
    declareUnboundVariable(name) {
      const { exportedNames: exportedNames } = this;
      if (exportedNames.has(name)) {
        this.report(147, name);
      }
      exportedNames.add(name);
    }
    report(type, ...params) {
      throw new ParseError(
        this.tokenStart,
        this.currentLocation,
        type,
        ...params,
      );
    }
    createScopeIfLexical(type, parent) {
      if (this.options.lexical) {
        return this.createScope(type, parent);
      }
      return undefined;
    }
    createScope(type, parent) {
      return new Scope(this, type, parent);
    }
    createPrivateScopeIfLexical(parent) {
      if (this.options.lexical) {
        return new PrivateScope(this, parent);
      }
      return undefined;
    }
  }
  function pushComment(comments, options) {
    return function (type, value, start, end, loc) {
      const comment = { type: type, value: value };
      if (options.ranges) {
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
      }
      if (options.loc) {
        comment.loc = loc;
      }
      comments.push(comment);
    };
  }
  function pushToken(tokens, options) {
    return function (type, start, end, loc) {
      const token = { token: type };
      if (options.ranges) {
        token.start = start;
        token.end = end;
        token.range = [start, end];
      }
      if (options.loc) {
        token.loc = loc;
      }
      tokens.push(token);
    };
  }
  function normalizeOptions(rawOptions) {
    const options = { ...rawOptions };
    if (options.onComment) {
      options.onComment = Array.isArray(options.onComment)
        ? pushComment(options.onComment, options)
        : options.onComment;
    }
    if (options.onToken) {
      options.onToken = Array.isArray(options.onToken)
        ? pushToken(options.onToken, options)
        : options.onToken;
    }
    return options;
  }
  function parseSource(source, rawOptions = {}, context = 0) {
    const options = normalizeOptions(rawOptions);
    if (options.module) context |= 2 | 1;
    if (options.globalReturn) context |= 4096;
    if (options.impliedStrict) context |= 1;
    const parser = new Parser(source, options);
    skipHashBang(parser);
    const scope = parser.createScopeIfLexical();
    let body = [];
    let sourceType = 'script';
    if (context & 2) {
      sourceType = 'module';
      body = parseModuleItemList(parser, context | 8, scope);
      if (scope) {
        for (const name of parser.exportedBindings) {
          if (!scope.hasVariable(name)) parser.report(148, name);
        }
      }
    } else {
      body = parseStatementList(parser, context | 8, scope);
    }
    return parser.finishNode(
      { type: 'Program', sourceType: sourceType, body: body },
      { index: 0, line: 1, column: 0 },
      parser.currentLocation,
    );
  }
  function parseStatementList(parser, context, scope) {
    nextToken(parser, context | 32 | 262144);
    const statements = [];
    while (parser.getToken() === 134283267) {
      const {
        index: index,
        tokenValue: tokenValue,
        tokenStart: tokenStart,
        tokenIndex: tokenIndex,
      } = parser;
      const token = parser.getToken();
      const expr = parseLiteral(parser, context);
      if (isValidStrictMode(parser, index, tokenIndex, tokenValue)) {
        context |= 1;
        if (parser.flags & 64) {
          throw new ParseError(parser.tokenStart, parser.currentLocation, 9);
        }
        if (parser.flags & 4096) {
          throw new ParseError(parser.tokenStart, parser.currentLocation, 15);
        }
      }
      statements.push(parseDirective(parser, context, expr, token, tokenStart));
    }
    while (parser.getToken() !== 1048576) {
      statements.push(
        parseStatementListItem(parser, context, scope, undefined, 4, {}),
      );
    }
    return statements;
  }
  function parseModuleItemList(parser, context, scope) {
    nextToken(parser, context | 32);
    const statements = [];
    while (parser.getToken() === 134283267) {
      const { tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      statements.push(
        parseDirective(
          parser,
          context,
          parseLiteral(parser, context),
          token,
          tokenStart,
        ),
      );
    }
    while (parser.getToken() !== 1048576) {
      statements.push(parseModuleItem(parser, context, scope));
    }
    return statements;
  }
  function parseModuleItem(parser, context, scope) {
    if (parser.getToken() === 132) {
      Object.assign(parser.leadingDecorators, {
        start: parser.tokenStart,
        decorators: parseDecorators(parser, context, undefined),
      });
    }
    let moduleItem;
    switch (parser.getToken()) {
      case 20564:
        moduleItem = parseExportDeclaration(parser, context, scope);
        break;
      case 86106:
        moduleItem = parseImportDeclaration(parser, context, scope);
        break;
      default:
        moduleItem = parseStatementListItem(
          parser,
          context,
          scope,
          undefined,
          4,
          {},
        );
    }
    if (parser.leadingDecorators?.decorators.length) {
      parser.report(170);
    }
    return moduleItem;
  }
  function parseStatementListItem(
    parser,
    context,
    scope,
    privateScope,
    origin,
    labels,
  ) {
    const start = parser.tokenStart;
    switch (parser.getToken()) {
      case 86104:
        return parseFunctionDeclaration(
          parser,
          context,
          scope,
          privateScope,
          origin,
          1,
          0,
          0,
          start,
        );
      case 132:
      case 86094:
        return parseClassDeclaration(parser, context, scope, privateScope, 0);
      case 86090:
        return parseLexicalDeclaration(
          parser,
          context,
          scope,
          privateScope,
          16,
          0,
        );
      case 241737:
        return parseLetIdentOrVarDeclarationStatement(
          parser,
          context,
          scope,
          privateScope,
          origin,
        );
      case 20564:
        parser.report(103, 'export');
      case 86106:
        nextToken(parser, context);
        switch (parser.getToken()) {
          case 67174411:
            return parseImportCallDeclaration(
              parser,
              context,
              privateScope,
              start,
            );
          case 67108877:
            return parseImportMetaDeclaration(parser, context, start);
          default:
            parser.report(103, 'import');
        }
      case 209005:
        return parseAsyncArrowOrAsyncFunctionDeclaration(
          parser,
          context,
          scope,
          privateScope,
          origin,
          labels,
          1,
        );
      default:
        return parseStatement(
          parser,
          context,
          scope,
          privateScope,
          origin,
          labels,
          1,
        );
    }
  }
  function parseStatement(
    parser,
    context,
    scope,
    privateScope,
    origin,
    labels,
    allowFuncDecl,
  ) {
    switch (parser.getToken()) {
      case 86088:
        return parseVariableStatement(parser, context, scope, privateScope, 0);
      case 20572:
        return parseReturnStatement(parser, context, privateScope);
      case 20569:
        return parseIfStatement(parser, context, scope, privateScope, labels);
      case 20567:
        return parseForStatement(parser, context, scope, privateScope, labels);
      case 20562:
        return parseDoWhileStatement(
          parser,
          context,
          scope,
          privateScope,
          labels,
        );
      case 20578:
        return parseWhileStatement(
          parser,
          context,
          scope,
          privateScope,
          labels,
        );
      case 86110:
        return parseSwitchStatement(
          parser,
          context,
          scope,
          privateScope,
          labels,
        );
      case 1074790417:
        return parseEmptyStatement(parser, context);
      case 2162700:
        return parseBlock(
          parser,
          context,
          scope?.createChildScope(),
          privateScope,
          labels,
          parser.tokenStart,
        );
      case 86112:
        return parseThrowStatement(parser, context, privateScope);
      case 20555:
        return parseBreakStatement(parser, context, labels);
      case 20559:
        return parseContinueStatement(parser, context, labels);
      case 20577:
        return parseTryStatement(parser, context, scope, privateScope, labels);
      case 20579:
        return parseWithStatement(parser, context, scope, privateScope, labels);
      case 20560:
        return parseDebuggerStatement(parser, context);
      case 209005:
        return parseAsyncArrowOrAsyncFunctionDeclaration(
          parser,
          context,
          scope,
          privateScope,
          origin,
          labels,
          0,
        );
      case 20557:
        parser.report(162);
      case 20566:
        parser.report(163);
      case 86104:
        parser.report(context & 1 ? 76 : !parser.options.webcompat ? 78 : 77);
      case 86094:
        parser.report(79);
      default:
        return parseExpressionOrLabelledStatement(
          parser,
          context,
          scope,
          privateScope,
          origin,
          labels,
          allowFuncDecl,
        );
    }
  }
  function parseExpressionOrLabelledStatement(
    parser,
    context,
    scope,
    privateScope,
    origin,
    labels,
    allowFuncDecl,
  ) {
    const { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
    const token = parser.getToken();
    let expr;
    switch (token) {
      case 241737:
        expr = parseIdentifier(parser, context);
        if (context & 1) parser.report(85);
        if (parser.getToken() === 69271571) parser.report(84);
        break;
      default:
        expr = parsePrimaryExpression(
          parser,
          context,
          privateScope,
          2,
          0,
          1,
          0,
          1,
          parser.tokenStart,
        );
    }
    if (token & 143360 && parser.getToken() === 21) {
      return parseLabelledStatement(
        parser,
        context,
        scope,
        privateScope,
        origin,
        labels,
        tokenValue,
        expr,
        token,
        allowFuncDecl,
        tokenStart,
      );
    }
    expr = parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expr,
      0,
      0,
      tokenStart,
    );
    expr = parseAssignmentExpression(
      parser,
      context,
      privateScope,
      0,
      0,
      tokenStart,
      expr,
    );
    if (parser.getToken() === 18) {
      expr = parseSequenceExpression(
        parser,
        context,
        privateScope,
        0,
        tokenStart,
        expr,
      );
    }
    return parseExpressionStatement(parser, context, expr, tokenStart);
  }
  function parseBlock(
    parser,
    context,
    scope,
    privateScope,
    labels,
    start = parser.tokenStart,
    type = 'BlockStatement',
  ) {
    const body = [];
    consume(parser, context | 32, 2162700);
    while (parser.getToken() !== 1074790415) {
      body.push(
        parseStatementListItem(parser, context, scope, privateScope, 2, {
          $: labels,
        }),
      );
    }
    consume(parser, context | 32, 1074790415);
    return parser.finishNode({ type: type, body: body }, start);
  }
  function parseReturnStatement(parser, context, privateScope) {
    if ((context & 4096) === 0) parser.report(92);
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    const argument =
      parser.flags & 1 || parser.getToken() & 1048576
        ? null
        : parseExpressions(
            parser,
            context,
            privateScope,
            0,
            1,
            parser.tokenStart,
          );
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      { type: 'ReturnStatement', argument: argument },
      start,
    );
  }
  function parseExpressionStatement(parser, context, expression, start) {
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      { type: 'ExpressionStatement', expression: expression },
      start,
    );
  }
  function parseLabelledStatement(
    parser,
    context,
    scope,
    privateScope,
    origin,
    labels,
    value,
    expr,
    token,
    allowFuncDecl,
    start,
  ) {
    validateBindingIdentifier(parser, context, 0, token, 1);
    validateAndDeclareLabel(parser, labels, value);
    nextToken(parser, context | 32);
    const body =
      allowFuncDecl &&
      (context & 1) === 0 &&
      parser.options.webcompat &&
      parser.getToken() === 86104
        ? parseFunctionDeclaration(
            parser,
            context,
            scope?.createChildScope(),
            privateScope,
            origin,
            0,
            0,
            0,
            parser.tokenStart,
          )
        : parseStatement(
            parser,
            context,
            scope,
            privateScope,
            origin,
            labels,
            allowFuncDecl,
          );
    return parser.finishNode(
      { type: 'LabeledStatement', label: expr, body: body },
      start,
    );
  }
  function parseAsyncArrowOrAsyncFunctionDeclaration(
    parser,
    context,
    scope,
    privateScope,
    origin,
    labels,
    allowFuncDecl,
  ) {
    const { tokenValue: tokenValue, tokenStart: start } = parser;
    const token = parser.getToken();
    let expr = parseIdentifier(parser, context);
    if (parser.getToken() === 21) {
      return parseLabelledStatement(
        parser,
        context,
        scope,
        privateScope,
        origin,
        labels,
        tokenValue,
        expr,
        token,
        1,
        start,
      );
    }
    const asyncNewLine = parser.flags & 1;
    if (!asyncNewLine) {
      if (parser.getToken() === 86104) {
        if (!allowFuncDecl) parser.report(123);
        return parseFunctionDeclaration(
          parser,
          context,
          scope,
          privateScope,
          origin,
          1,
          0,
          1,
          start,
        );
      }
      if (isValidIdentifier(context, parser.getToken())) {
        expr = parseAsyncArrowAfterIdent(
          parser,
          context,
          privateScope,
          1,
          start,
        );
        if (parser.getToken() === 18)
          expr = parseSequenceExpression(
            parser,
            context,
            privateScope,
            0,
            start,
            expr,
          );
        return parseExpressionStatement(parser, context, expr, start);
      }
    }
    if (parser.getToken() === 67174411) {
      expr = parseAsyncArrowOrCallExpression(
        parser,
        context,
        privateScope,
        expr,
        1,
        1,
        0,
        asyncNewLine,
        start,
      );
    } else {
      if (parser.getToken() === 10) {
        classifyIdentifier(parser, context, token);
        if ((token & 36864) === 36864) {
          parser.flags |= 256;
        }
        expr = parseArrowFromIdentifier(
          parser,
          context | 2048,
          privateScope,
          parser.tokenValue,
          expr,
          0,
          1,
          0,
          start,
        );
      }
      parser.assignable = 1;
    }
    expr = parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expr,
      0,
      0,
      start,
    );
    expr = parseAssignmentExpression(
      parser,
      context,
      privateScope,
      0,
      0,
      start,
      expr,
    );
    parser.assignable = 1;
    if (parser.getToken() === 18) {
      expr = parseSequenceExpression(
        parser,
        context,
        privateScope,
        0,
        start,
        expr,
      );
    }
    return parseExpressionStatement(parser, context, expr, start);
  }
  function parseDirective(parser, context, expression, token, start) {
    const endIndex = parser.startIndex;
    if (token !== 1074790417) {
      parser.assignable = 2;
      expression = parseMemberOrUpdateExpression(
        parser,
        context,
        undefined,
        expression,
        0,
        0,
        start,
      );
      if (parser.getToken() !== 1074790417) {
        expression = parseAssignmentExpression(
          parser,
          context,
          undefined,
          0,
          0,
          start,
          expression,
        );
        if (parser.getToken() === 18) {
          expression = parseSequenceExpression(
            parser,
            context,
            undefined,
            0,
            start,
            expression,
          );
        }
      }
      matchOrInsertSemicolon(parser, context | 32);
    }
    const node = { type: 'ExpressionStatement', expression: expression };
    if (expression.type === 'Literal' && typeof expression.value === 'string') {
      node.directive = parser.source.slice(start.index + 1, endIndex - 1);
    }
    return parser.finishNode(node, start);
  }
  function parseEmptyStatement(parser, context) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    return parser.finishNode({ type: 'EmptyStatement' }, start);
  }
  function parseThrowStatement(parser, context, privateScope) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    if (parser.flags & 1) parser.report(90);
    const argument = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      { type: 'ThrowStatement', argument: argument },
      start,
    );
  }
  function parseIfStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    consume(parser, context | 32, 67174411);
    parser.assignable = 1;
    const test = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    consume(parser, context | 32, 16);
    const consequent = parseConsequentOrAlternative(
      parser,
      context,
      scope,
      privateScope,
      labels,
    );
    let alternate = null;
    if (parser.getToken() === 20563) {
      nextToken(parser, context | 32);
      alternate = parseConsequentOrAlternative(
        parser,
        context,
        scope,
        privateScope,
        labels,
      );
    }
    return parser.finishNode(
      {
        type: 'IfStatement',
        test: test,
        consequent: consequent,
        alternate: alternate,
      },
      start,
    );
  }
  function parseConsequentOrAlternative(
    parser,
    context,
    scope,
    privateScope,
    labels,
  ) {
    const { tokenStart: tokenStart } = parser;
    return context & 1 ||
      !parser.options.webcompat ||
      parser.getToken() !== 86104
      ? parseStatement(
          parser,
          context,
          scope,
          privateScope,
          0,
          { $: labels },
          0,
        )
      : parseFunctionDeclaration(
          parser,
          context,
          scope?.createChildScope(),
          privateScope,
          0,
          0,
          0,
          0,
          tokenStart,
        );
  }
  function parseSwitchStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    consume(parser, context | 32, 67174411);
    const discriminant = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    consume(parser, context, 16);
    consume(parser, context, 2162700);
    const cases = [];
    let seenDefault = 0;
    scope = scope?.createChildScope(8);
    while (parser.getToken() !== 1074790415) {
      const { tokenStart: tokenStart } = parser;
      let test = null;
      const consequent = [];
      if (consumeOpt(parser, context | 32, 20556)) {
        test = parseExpressions(
          parser,
          context,
          privateScope,
          0,
          1,
          parser.tokenStart,
        );
      } else {
        consume(parser, context | 32, 20561);
        if (seenDefault) parser.report(89);
        seenDefault = 1;
      }
      consume(parser, context | 32, 21);
      while (
        parser.getToken() !== 20556 &&
        parser.getToken() !== 1074790415 &&
        parser.getToken() !== 20561
      ) {
        consequent.push(
          parseStatementListItem(parser, context | 4, scope, privateScope, 2, {
            $: labels,
          }),
        );
      }
      cases.push(
        parser.finishNode(
          { type: 'SwitchCase', test: test, consequent: consequent },
          tokenStart,
        ),
      );
    }
    consume(parser, context | 32, 1074790415);
    return parser.finishNode(
      { type: 'SwitchStatement', discriminant: discriminant, cases: cases },
      start,
    );
  }
  function parseWhileStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    consume(parser, context | 32, 67174411);
    const test = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    consume(parser, context | 32, 16);
    const body = parseIterationStatementBody(
      parser,
      context,
      scope,
      privateScope,
      labels,
    );
    return parser.finishNode(
      { type: 'WhileStatement', test: test, body: body },
      start,
    );
  }
  function parseIterationStatementBody(
    parser,
    context,
    scope,
    privateScope,
    labels,
  ) {
    return parseStatement(
      parser,
      ((context | 131072) ^ 131072) | 128,
      scope,
      privateScope,
      0,
      { loop: 1, $: labels },
      0,
    );
  }
  function parseContinueStatement(parser, context, labels) {
    if ((context & 128) === 0) parser.report(68);
    const start = parser.tokenStart;
    nextToken(parser, context);
    let label = null;
    if ((parser.flags & 1) === 0 && parser.getToken() & 143360) {
      const { tokenValue: tokenValue } = parser;
      label = parseIdentifier(parser, context | 32);
      if (!isValidLabel(parser, labels, tokenValue, 1))
        parser.report(138, tokenValue);
    }
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      { type: 'ContinueStatement', label: label },
      start,
    );
  }
  function parseBreakStatement(parser, context, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    let label = null;
    if ((parser.flags & 1) === 0 && parser.getToken() & 143360) {
      const { tokenValue: tokenValue } = parser;
      label = parseIdentifier(parser, context | 32);
      if (!isValidLabel(parser, labels, tokenValue, 0))
        parser.report(138, tokenValue);
    } else if ((context & (4 | 128)) === 0) {
      parser.report(69);
    }
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode({ type: 'BreakStatement', label: label }, start);
  }
  function parseWithStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    if (context & 1) parser.report(91);
    consume(parser, context | 32, 67174411);
    const object = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    consume(parser, context | 32, 16);
    const body = parseStatement(
      parser,
      context,
      scope,
      privateScope,
      2,
      labels,
      0,
    );
    return parser.finishNode(
      { type: 'WithStatement', object: object, body: body },
      start,
    );
  }
  function parseDebuggerStatement(parser, context) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode({ type: 'DebuggerStatement' }, start);
  }
  function parseTryStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    const firstScope = scope?.createChildScope(16);
    const block = parseBlock(parser, context, firstScope, privateScope, {
      $: labels,
    });
    const { tokenStart: tokenStart } = parser;
    const handler = consumeOpt(parser, context | 32, 20557)
      ? parseCatchBlock(
          parser,
          context,
          scope,
          privateScope,
          labels,
          tokenStart,
        )
      : null;
    let finalizer = null;
    if (parser.getToken() === 20566) {
      nextToken(parser, context | 32);
      const finalizerScope = scope?.createChildScope(4);
      const block = parseBlock(parser, context, finalizerScope, privateScope, {
        $: labels,
      });
      finalizer = block;
    }
    if (!handler && !finalizer) {
      parser.report(88);
    }
    return parser.finishNode(
      {
        type: 'TryStatement',
        block: block,
        handler: handler,
        finalizer: finalizer,
      },
      start,
    );
  }
  function parseCatchBlock(
    parser,
    context,
    scope,
    privateScope,
    labels,
    start,
  ) {
    let param = null;
    let additionalScope = scope;
    if (consumeOpt(parser, context, 67174411)) {
      scope = scope?.createChildScope(4);
      param = parseBindingPattern(
        parser,
        context,
        scope,
        privateScope,
        (parser.getToken() & 2097152) === 2097152 ? 256 : 512,
        0,
      );
      if (parser.getToken() === 18) {
        parser.report(86);
      } else if (parser.getToken() === 1077936155) {
        parser.report(87);
      }
      consume(parser, context | 32, 16);
    }
    additionalScope = scope?.createChildScope(32);
    const body = parseBlock(parser, context, additionalScope, privateScope, {
      $: labels,
    });
    return parser.finishNode(
      { type: 'CatchClause', param: param, body: body },
      start,
    );
  }
  function parseStaticBlock(parser, context, scope, privateScope, start) {
    scope = scope?.createChildScope();
    const ctorContext = 512 | 4096 | 1024 | 4 | 128;
    context =
      ((context | ctorContext) ^ ctorContext) | 256 | 2048 | 524288 | 65536;
    return parseBlock(
      parser,
      context,
      scope,
      privateScope,
      {},
      start,
      'StaticBlock',
    );
  }
  function parseDoWhileStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    const body = parseIterationStatementBody(
      parser,
      context,
      scope,
      privateScope,
      labels,
    );
    consume(parser, context, 20578);
    consume(parser, context | 32, 67174411);
    const test = parseExpressions(
      parser,
      context,
      privateScope,
      0,
      1,
      parser.tokenStart,
    );
    consume(parser, context | 32, 16);
    consumeOpt(parser, context | 32, 1074790417);
    return parser.finishNode(
      { type: 'DoWhileStatement', body: body, test: test },
      start,
    );
  }
  function parseLetIdentOrVarDeclarationStatement(
    parser,
    context,
    scope,
    privateScope,
    origin,
  ) {
    const { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
    const token = parser.getToken();
    let expr = parseIdentifier(parser, context);
    if (parser.getToken() & (143360 | 2097152)) {
      const declarations = parseVariableDeclarationList(
        parser,
        context,
        scope,
        privateScope,
        8,
        0,
      );
      matchOrInsertSemicolon(parser, context | 32);
      return parser.finishNode(
        {
          type: 'VariableDeclaration',
          kind: 'let',
          declarations: declarations,
        },
        tokenStart,
      );
    }
    parser.assignable = 1;
    if (context & 1) parser.report(85);
    if (parser.getToken() === 21) {
      return parseLabelledStatement(
        parser,
        context,
        scope,
        privateScope,
        origin,
        {},
        tokenValue,
        expr,
        token,
        0,
        tokenStart,
      );
    }
    if (parser.getToken() === 10) {
      let scope = void 0;
      if (parser.options.lexical)
        scope = createArrowHeadParsingScope(parser, context, tokenValue);
      parser.flags = (parser.flags | 128) ^ 128;
      expr = parseArrowFunctionExpression(
        parser,
        context,
        scope,
        privateScope,
        [expr],
        0,
        tokenStart,
      );
    } else {
      expr = parseMemberOrUpdateExpression(
        parser,
        context,
        privateScope,
        expr,
        0,
        0,
        tokenStart,
      );
      expr = parseAssignmentExpression(
        parser,
        context,
        privateScope,
        0,
        0,
        tokenStart,
        expr,
      );
    }
    if (parser.getToken() === 18) {
      expr = parseSequenceExpression(
        parser,
        context,
        privateScope,
        0,
        tokenStart,
        expr,
      );
    }
    return parseExpressionStatement(parser, context, expr, tokenStart);
  }
  function parseLexicalDeclaration(
    parser,
    context,
    scope,
    privateScope,
    kind,
    origin,
  ) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    const declarations = parseVariableDeclarationList(
      parser,
      context,
      scope,
      privateScope,
      kind,
      origin,
    );
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      {
        type: 'VariableDeclaration',
        kind: kind & 8 ? 'let' : 'const',
        declarations: declarations,
      },
      start,
    );
  }
  function parseVariableStatement(
    parser,
    context,
    scope,
    privateScope,
    origin,
  ) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    const declarations = parseVariableDeclarationList(
      parser,
      context,
      scope,
      privateScope,
      4,
      origin,
    );
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(
      { type: 'VariableDeclaration', kind: 'var', declarations: declarations },
      start,
    );
  }
  function parseVariableDeclarationList(
    parser,
    context,
    scope,
    privateScope,
    kind,
    origin,
  ) {
    let bindingCount = 1;
    const list = [
      parseVariableDeclaration(
        parser,
        context,
        scope,
        privateScope,
        kind,
        origin,
      ),
    ];
    while (consumeOpt(parser, context, 18)) {
      bindingCount++;
      list.push(
        parseVariableDeclaration(
          parser,
          context,
          scope,
          privateScope,
          kind,
          origin,
        ),
      );
    }
    if (bindingCount > 1 && origin & 32 && parser.getToken() & 262144) {
      parser.report(61, KeywordDescTable[parser.getToken() & 255]);
    }
    return list;
  }
  function parseVariableDeclaration(
    parser,
    context,
    scope,
    privateScope,
    kind,
    origin,
  ) {
    const { tokenStart: tokenStart } = parser;
    const token = parser.getToken();
    let init = null;
    const id = parseBindingPattern(
      parser,
      context,
      scope,
      privateScope,
      kind,
      origin,
    );
    if (parser.getToken() === 1077936155) {
      nextToken(parser, context | 32);
      init = parseExpression(
        parser,
        context,
        privateScope,
        1,
        0,
        parser.tokenStart,
      );
      if (origin & 32 || (token & 2097152) === 0) {
        if (
          parser.getToken() === 471156 ||
          (parser.getToken() === 8673330 &&
            (token & 2097152 || (kind & 4) === 0 || context & 1))
        ) {
          throw new ParseError(
            tokenStart,
            parser.currentLocation,
            60,
            parser.getToken() === 471156 ? 'of' : 'in',
          );
        }
      }
    } else if (
      (kind & 16 || (token & 2097152) > 0) &&
      (parser.getToken() & 262144) !== 262144
    ) {
      parser.report(59, kind & 16 ? 'const' : 'destructuring');
    }
    return parser.finishNode(
      { type: 'VariableDeclarator', id: id, init: init },
      tokenStart,
    );
  }
  function parseForStatement(parser, context, scope, privateScope, labels) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    const forAwait =
      ((context & 2048) > 0 || ((context & 2) > 0 && (context & 8) > 0)) &&
      consumeOpt(parser, context, 209006);
    consume(parser, context | 32, 67174411);
    scope = scope?.createChildScope(1);
    let test = null;
    let update = null;
    let destructible = 0;
    let init = null;
    let isVarDecl =
      parser.getToken() === 86088 ||
      parser.getToken() === 241737 ||
      parser.getToken() === 86090;
    let right;
    const { tokenStart: tokenStart } = parser;
    const token = parser.getToken();
    if (isVarDecl) {
      if (token === 241737) {
        init = parseIdentifier(parser, context);
        if (parser.getToken() & (143360 | 2097152)) {
          if (parser.getToken() === 8673330) {
            if (context & 1) parser.report(67);
          } else {
            init = parser.finishNode(
              {
                type: 'VariableDeclaration',
                kind: 'let',
                declarations: parseVariableDeclarationList(
                  parser,
                  context | 131072,
                  scope,
                  privateScope,
                  8,
                  32,
                ),
              },
              tokenStart,
            );
          }
          parser.assignable = 1;
        } else if (context & 1) {
          parser.report(67);
        } else {
          isVarDecl = false;
          parser.assignable = 1;
          init = parseMemberOrUpdateExpression(
            parser,
            context,
            privateScope,
            init,
            0,
            0,
            tokenStart,
          );
          if (parser.getToken() === 471156) parser.report(115);
        }
      } else {
        nextToken(parser, context);
        init = parser.finishNode(
          token === 86088
            ? {
                type: 'VariableDeclaration',
                kind: 'var',
                declarations: parseVariableDeclarationList(
                  parser,
                  context | 131072,
                  scope,
                  privateScope,
                  4,
                  32,
                ),
              }
            : {
                type: 'VariableDeclaration',
                kind: 'const',
                declarations: parseVariableDeclarationList(
                  parser,
                  context | 131072,
                  scope,
                  privateScope,
                  16,
                  32,
                ),
              },
          tokenStart,
        );
        parser.assignable = 1;
      }
    } else if (token === 1074790417) {
      if (forAwait) parser.report(82);
    } else if ((token & 2097152) === 2097152) {
      const patternStart = parser.tokenStart;
      init =
        token === 2162700
          ? parseObjectLiteralOrPattern(
              parser,
              context,
              void 0,
              privateScope,
              1,
              0,
              0,
              2,
              32,
            )
          : parseArrayExpressionOrPattern(
              parser,
              context,
              void 0,
              privateScope,
              1,
              0,
              0,
              2,
              32,
            );
      destructible = parser.destructible;
      if (destructible & 64) {
        parser.report(63);
      }
      parser.assignable = destructible & 16 ? 2 : 1;
      init = parseMemberOrUpdateExpression(
        parser,
        context | 131072,
        privateScope,
        init,
        0,
        0,
        patternStart,
      );
    } else {
      init = parseLeftHandSideExpression(
        parser,
        context | 131072,
        privateScope,
        1,
        0,
        1,
      );
    }
    if ((parser.getToken() & 262144) === 262144) {
      if (parser.getToken() === 471156) {
        if (parser.assignable & 2) parser.report(80, forAwait ? 'await' : 'of');
        reinterpretToPattern(parser, init);
        nextToken(parser, context | 32);
        right = parseExpression(
          parser,
          context,
          privateScope,
          1,
          0,
          parser.tokenStart,
        );
        consume(parser, context | 32, 16);
        const body = parseIterationStatementBody(
          parser,
          context,
          scope,
          privateScope,
          labels,
        );
        return parser.finishNode(
          {
            type: 'ForOfStatement',
            left: init,
            right: right,
            body: body,
            await: forAwait,
          },
          start,
        );
      }
      if (parser.assignable & 2) parser.report(80, 'in');
      reinterpretToPattern(parser, init);
      nextToken(parser, context | 32);
      if (forAwait) parser.report(82);
      right = parseExpressions(
        parser,
        context,
        privateScope,
        0,
        1,
        parser.tokenStart,
      );
      consume(parser, context | 32, 16);
      const body = parseIterationStatementBody(
        parser,
        context,
        scope,
        privateScope,
        labels,
      );
      return parser.finishNode(
        { type: 'ForInStatement', body: body, left: init, right: right },
        start,
      );
    }
    if (forAwait) parser.report(82);
    if (!isVarDecl) {
      if (destructible & 8 && parser.getToken() !== 1077936155) {
        parser.report(80, 'loop');
      }
      init = parseAssignmentExpression(
        parser,
        context | 131072,
        privateScope,
        0,
        0,
        tokenStart,
        init,
      );
    }
    if (parser.getToken() === 18)
      init = parseSequenceExpression(
        parser,
        context,
        privateScope,
        0,
        tokenStart,
        init,
      );
    consume(parser, context | 32, 1074790417);
    if (parser.getToken() !== 1074790417)
      test = parseExpressions(
        parser,
        context,
        privateScope,
        0,
        1,
        parser.tokenStart,
      );
    consume(parser, context | 32, 1074790417);
    if (parser.getToken() !== 16)
      update = parseExpressions(
        parser,
        context,
        privateScope,
        0,
        1,
        parser.tokenStart,
      );
    consume(parser, context | 32, 16);
    const body = parseIterationStatementBody(
      parser,
      context,
      scope,
      privateScope,
      labels,
    );
    return parser.finishNode(
      {
        type: 'ForStatement',
        init: init,
        test: test,
        update: update,
        body: body,
      },
      start,
    );
  }
  function parseRestrictedIdentifier(parser, context, scope) {
    if (!isValidIdentifier(context, parser.getToken())) parser.report(118);
    if ((parser.getToken() & 537079808) === 537079808) parser.report(119);
    scope?.addBlockName(context, parser.tokenValue, 8, 0);
    return parseIdentifier(parser, context);
  }
  function parseImportDeclaration(parser, context, scope) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    let source = null;
    const { tokenStart: tokenStart } = parser;
    let specifiers = [];
    if (parser.getToken() === 134283267) {
      source = parseLiteral(parser, context);
    } else {
      if (parser.getToken() & 143360) {
        const local = parseRestrictedIdentifier(parser, context, scope);
        specifiers = [
          parser.finishNode(
            { type: 'ImportDefaultSpecifier', local: local },
            tokenStart,
          ),
        ];
        if (consumeOpt(parser, context, 18)) {
          switch (parser.getToken()) {
            case 8391476:
              specifiers.push(
                parseImportNamespaceSpecifier(parser, context, scope),
              );
              break;
            case 2162700:
              parseImportSpecifierOrNamedImports(
                parser,
                context,
                scope,
                specifiers,
              );
              break;
            default:
              parser.report(107);
          }
        }
      } else {
        switch (parser.getToken()) {
          case 8391476:
            specifiers = [
              parseImportNamespaceSpecifier(parser, context, scope),
            ];
            break;
          case 2162700:
            parseImportSpecifierOrNamedImports(
              parser,
              context,
              scope,
              specifiers,
            );
            break;
          case 67174411:
            return parseImportCallDeclaration(
              parser,
              context,
              undefined,
              start,
            );
          case 67108877:
            return parseImportMetaDeclaration(parser, context, start);
          default:
            parser.report(30, KeywordDescTable[parser.getToken() & 255]);
        }
      }
      source = parseModuleSpecifier(parser, context);
    }
    const attributes = parseImportAttributes(parser, context);
    const node = {
      type: 'ImportDeclaration',
      specifiers: specifiers,
      source: source,
      attributes: attributes,
    };
    matchOrInsertSemicolon(parser, context | 32);
    return parser.finishNode(node, start);
  }
  function parseImportNamespaceSpecifier(parser, context, scope) {
    const { tokenStart: tokenStart } = parser;
    nextToken(parser, context);
    consume(parser, context, 77932);
    if ((parser.getToken() & 134217728) === 134217728) {
      throw new ParseError(
        tokenStart,
        parser.currentLocation,
        30,
        KeywordDescTable[parser.getToken() & 255],
      );
    }
    return parser.finishNode(
      {
        type: 'ImportNamespaceSpecifier',
        local: parseRestrictedIdentifier(parser, context, scope),
      },
      tokenStart,
    );
  }
  function parseModuleSpecifier(parser, context) {
    consume(parser, context, 209011);
    if (parser.getToken() !== 134283267) parser.report(105, 'Import');
    return parseLiteral(parser, context);
  }
  function parseImportSpecifierOrNamedImports(
    parser,
    context,
    scope,
    specifiers,
  ) {
    nextToken(parser, context);
    while (parser.getToken() & 143360 || parser.getToken() === 134283267) {
      let { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      const imported = parseModuleExportName(parser, context);
      let local;
      if (consumeOpt(parser, context, 77932)) {
        if (
          (parser.getToken() & 134217728) === 134217728 ||
          parser.getToken() === 18
        ) {
          parser.report(106);
        } else {
          validateBindingIdentifier(parser, context, 16, parser.getToken(), 0);
        }
        tokenValue = parser.tokenValue;
        local = parseIdentifier(parser, context);
      } else if (imported.type === 'Identifier') {
        validateBindingIdentifier(parser, context, 16, token, 0);
        local = imported;
      } else {
        parser.report(25, KeywordDescTable[77932 & 255]);
      }
      scope?.addBlockName(context, tokenValue, 8, 0);
      specifiers.push(
        parser.finishNode(
          { type: 'ImportSpecifier', local: local, imported: imported },
          tokenStart,
        ),
      );
      if (parser.getToken() !== 1074790415) consume(parser, context, 18);
    }
    consume(parser, context, 1074790415);
    return specifiers;
  }
  function parseImportMetaDeclaration(parser, context, start) {
    let expr = parseImportMetaExpression(
      parser,
      context,
      parser.finishNode({ type: 'Identifier', name: 'import' }, start),
      start,
    );
    expr = parseMemberOrUpdateExpression(
      parser,
      context,
      undefined,
      expr,
      0,
      0,
      start,
    );
    expr = parseAssignmentExpression(
      parser,
      context,
      undefined,
      0,
      0,
      start,
      expr,
    );
    if (parser.getToken() === 18) {
      expr = parseSequenceExpression(
        parser,
        context,
        undefined,
        0,
        start,
        expr,
      );
    }
    return parseExpressionStatement(parser, context, expr, start);
  }
  function parseImportCallDeclaration(parser, context, privateScope, start) {
    let expr = parseImportExpression(parser, context, privateScope, 0, start);
    expr = parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expr,
      0,
      0,
      start,
    );
    if (parser.getToken() === 18) {
      expr = parseSequenceExpression(
        parser,
        context,
        privateScope,
        0,
        start,
        expr,
      );
    }
    return parseExpressionStatement(parser, context, expr, start);
  }
  function parseExportDeclaration(parser, context, scope) {
    const start = parser.leadingDecorators.decorators.length
      ? parser.leadingDecorators.start
      : parser.tokenStart;
    nextToken(parser, context | 32);
    const specifiers = [];
    let declaration = null;
    let source = null;
    let attributes = [];
    if (consumeOpt(parser, context | 32, 20561)) {
      switch (parser.getToken()) {
        case 86104: {
          declaration = parseFunctionDeclaration(
            parser,
            context,
            scope,
            undefined,
            4,
            1,
            1,
            0,
            parser.tokenStart,
          );
          break;
        }
        case 132:
        case 86094:
          declaration = parseClassDeclaration(
            parser,
            context,
            scope,
            undefined,
            1,
          );
          break;
        case 209005: {
          const { tokenStart: tokenStart } = parser;
          declaration = parseIdentifier(parser, context);
          const { flags: flags } = parser;
          if ((flags & 1) === 0) {
            if (parser.getToken() === 86104) {
              declaration = parseFunctionDeclaration(
                parser,
                context,
                scope,
                undefined,
                4,
                1,
                1,
                1,
                tokenStart,
              );
            } else {
              if (parser.getToken() === 67174411) {
                declaration = parseAsyncArrowOrCallExpression(
                  parser,
                  context,
                  undefined,
                  declaration,
                  1,
                  1,
                  0,
                  flags,
                  tokenStart,
                );
                declaration = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  undefined,
                  declaration,
                  0,
                  0,
                  tokenStart,
                );
                declaration = parseAssignmentExpression(
                  parser,
                  context,
                  undefined,
                  0,
                  0,
                  tokenStart,
                  declaration,
                );
              } else if (parser.getToken() & 143360) {
                if (scope)
                  scope = createArrowHeadParsingScope(
                    parser,
                    context,
                    parser.tokenValue,
                  );
                declaration = parseIdentifier(parser, context);
                declaration = parseArrowFunctionExpression(
                  parser,
                  context,
                  scope,
                  undefined,
                  [declaration],
                  1,
                  tokenStart,
                );
              }
            }
          }
          break;
        }
        default:
          declaration = parseExpression(
            parser,
            context,
            undefined,
            1,
            0,
            parser.tokenStart,
          );
          matchOrInsertSemicolon(parser, context | 32);
      }
      if (scope) parser.declareUnboundVariable('default');
      return parser.finishNode(
        { type: 'ExportDefaultDeclaration', declaration: declaration },
        start,
      );
    }
    switch (parser.getToken()) {
      case 8391476: {
        nextToken(parser, context);
        let exported = null;
        const isNamedDeclaration = consumeOpt(parser, context, 77932);
        if (isNamedDeclaration) {
          if (scope) parser.declareUnboundVariable(parser.tokenValue);
          exported = parseModuleExportName(parser, context);
        }
        consume(parser, context, 209011);
        if (parser.getToken() !== 134283267) parser.report(105, 'Export');
        source = parseLiteral(parser, context);
        const attributes = parseImportAttributes(parser, context);
        const node = {
          type: 'ExportAllDeclaration',
          source: source,
          exported: exported,
          attributes: attributes,
        };
        matchOrInsertSemicolon(parser, context | 32);
        return parser.finishNode(node, start);
      }
      case 2162700: {
        nextToken(parser, context);
        const tmpExportedNames = [];
        const tmpExportedBindings = [];
        let hasLiteralLocal = 0;
        while (parser.getToken() & 143360 || parser.getToken() === 134283267) {
          const { tokenStart: tokenStart, tokenValue: tokenValue } = parser;
          const local = parseModuleExportName(parser, context);
          if (local.type === 'Literal') {
            hasLiteralLocal = 1;
          }
          let exported;
          if (parser.getToken() === 77932) {
            nextToken(parser, context);
            if (
              (parser.getToken() & 143360) === 0 &&
              parser.getToken() !== 134283267
            ) {
              parser.report(106);
            }
            if (scope) {
              tmpExportedNames.push(parser.tokenValue);
              tmpExportedBindings.push(tokenValue);
            }
            exported = parseModuleExportName(parser, context);
          } else {
            if (scope) {
              tmpExportedNames.push(parser.tokenValue);
              tmpExportedBindings.push(parser.tokenValue);
            }
            exported = local;
          }
          specifiers.push(
            parser.finishNode(
              { type: 'ExportSpecifier', local: local, exported: exported },
              tokenStart,
            ),
          );
          if (parser.getToken() !== 1074790415) consume(parser, context, 18);
        }
        consume(parser, context, 1074790415);
        if (consumeOpt(parser, context, 209011)) {
          if (parser.getToken() !== 134283267) parser.report(105, 'Export');
          source = parseLiteral(parser, context);
          attributes = parseImportAttributes(parser, context);
          if (scope) {
            tmpExportedNames.forEach((n) => parser.declareUnboundVariable(n));
          }
        } else {
          if (hasLiteralLocal) {
            parser.report(172);
          }
          if (scope) {
            tmpExportedNames.forEach((n) => parser.declareUnboundVariable(n));
            tmpExportedBindings.forEach((b) => parser.addBindingToExports(b));
          }
        }
        matchOrInsertSemicolon(parser, context | 32);
        break;
      }
      case 132:
      case 86094:
        declaration = parseClassDeclaration(
          parser,
          context,
          scope,
          undefined,
          2,
        );
        break;
      case 86104:
        declaration = parseFunctionDeclaration(
          parser,
          context,
          scope,
          undefined,
          4,
          1,
          2,
          0,
          parser.tokenStart,
        );
        break;
      case 241737:
        declaration = parseLexicalDeclaration(
          parser,
          context,
          scope,
          undefined,
          8,
          64,
        );
        break;
      case 86090:
        declaration = parseLexicalDeclaration(
          parser,
          context,
          scope,
          undefined,
          16,
          64,
        );
        break;
      case 86088:
        declaration = parseVariableStatement(
          parser,
          context,
          scope,
          undefined,
          64,
        );
        break;
      case 209005: {
        const { tokenStart: tokenStart } = parser;
        nextToken(parser, context);
        if ((parser.flags & 1) === 0 && parser.getToken() === 86104) {
          declaration = parseFunctionDeclaration(
            parser,
            context,
            scope,
            undefined,
            4,
            1,
            2,
            1,
            tokenStart,
          );
          break;
        }
      }
      default:
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
    const node = {
      type: 'ExportNamedDeclaration',
      declaration: declaration,
      specifiers: specifiers,
      source: source,
      attributes: attributes,
    };
    return parser.finishNode(node, start);
  }
  function parseExpression(
    parser,
    context,
    privateScope,
    canAssign,
    inGroup,
    start,
  ) {
    let expr = parsePrimaryExpression(
      parser,
      context,
      privateScope,
      2,
      0,
      canAssign,
      inGroup,
      1,
      start,
    );
    expr = parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expr,
      inGroup,
      0,
      start,
    );
    return parseAssignmentExpression(
      parser,
      context,
      privateScope,
      inGroup,
      0,
      start,
      expr,
    );
  }
  function parseSequenceExpression(
    parser,
    context,
    privateScope,
    inGroup,
    start,
    expr,
  ) {
    const expressions = [expr];
    while (consumeOpt(parser, context | 32, 18)) {
      expressions.push(
        parseExpression(
          parser,
          context,
          privateScope,
          1,
          inGroup,
          parser.tokenStart,
        ),
      );
    }
    return parser.finishNode(
      { type: 'SequenceExpression', expressions: expressions },
      start,
    );
  }
  function parseExpressions(
    parser,
    context,
    privateScope,
    inGroup,
    canAssign,
    start,
  ) {
    const expr = parseExpression(
      parser,
      context,
      privateScope,
      canAssign,
      inGroup,
      start,
    );
    return parser.getToken() === 18
      ? parseSequenceExpression(
          parser,
          context,
          privateScope,
          inGroup,
          start,
          expr,
        )
      : expr;
  }
  function parseAssignmentExpression(
    parser,
    context,
    privateScope,
    inGroup,
    isPattern,
    start,
    left,
  ) {
    const token = parser.getToken();
    if ((token & 4194304) === 4194304) {
      if (parser.assignable & 2) parser.report(26);
      if (
        (!isPattern &&
          token === 1077936155 &&
          left.type === 'ArrayExpression') ||
        left.type === 'ObjectExpression'
      ) {
        reinterpretToPattern(parser, left);
      }
      nextToken(parser, context | 32);
      const right = parseExpression(
        parser,
        context,
        privateScope,
        1,
        inGroup,
        parser.tokenStart,
      );
      parser.assignable = 2;
      return parser.finishNode(
        isPattern
          ? { type: 'AssignmentPattern', left: left, right: right }
          : {
              type: 'AssignmentExpression',
              left: left,
              operator: KeywordDescTable[token & 255],
              right: right,
            },
        start,
      );
    }
    if ((token & 8388608) === 8388608) {
      left = parseBinaryExpression(
        parser,
        context,
        privateScope,
        inGroup,
        start,
        4,
        token,
        left,
      );
    }
    if (consumeOpt(parser, context | 32, 22)) {
      left = parseConditionalExpression(
        parser,
        context,
        privateScope,
        left,
        start,
      );
    }
    return left;
  }
  function parseAssignmentExpressionOrPattern(
    parser,
    context,
    privateScope,
    inGroup,
    isPattern,
    start,
    left,
  ) {
    const token = parser.getToken();
    nextToken(parser, context | 32);
    const right = parseExpression(
      parser,
      context,
      privateScope,
      1,
      inGroup,
      parser.tokenStart,
    );
    left = parser.finishNode(
      isPattern
        ? { type: 'AssignmentPattern', left: left, right: right }
        : {
            type: 'AssignmentExpression',
            left: left,
            operator: KeywordDescTable[token & 255],
            right: right,
          },
      start,
    );
    parser.assignable = 2;
    return left;
  }
  function parseConditionalExpression(
    parser,
    context,
    privateScope,
    test,
    start,
  ) {
    const consequent = parseExpression(
      parser,
      (context | 131072) ^ 131072,
      privateScope,
      1,
      0,
      parser.tokenStart,
    );
    consume(parser, context | 32, 21);
    parser.assignable = 1;
    const alternate = parseExpression(
      parser,
      context,
      privateScope,
      1,
      0,
      parser.tokenStart,
    );
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'ConditionalExpression',
        test: test,
        consequent: consequent,
        alternate: alternate,
      },
      start,
    );
  }
  function parseBinaryExpression(
    parser,
    context,
    privateScope,
    inGroup,
    start,
    minPrecedence,
    operator,
    left,
  ) {
    const bit = -((context & 131072) > 0) & 8673330;
    let t;
    let precedence;
    parser.assignable = 2;
    while (parser.getToken() & 8388608) {
      t = parser.getToken();
      precedence = t & 3840;
      if (
        (t & 524288 && operator & 268435456) ||
        (operator & 524288 && t & 268435456)
      ) {
        parser.report(165);
      }
      if (
        precedence + ((t === 8391735) << 8) - ((bit === t) << 12) <=
        minPrecedence
      )
        break;
      nextToken(parser, context | 32);
      left = parser.finishNode(
        {
          type:
            t & 524288 || t & 268435456
              ? 'LogicalExpression'
              : 'BinaryExpression',
          left: left,
          right: parseBinaryExpression(
            parser,
            context,
            privateScope,
            inGroup,
            parser.tokenStart,
            precedence,
            t,
            parseLeftHandSideExpression(
              parser,
              context,
              privateScope,
              0,
              inGroup,
              1,
            ),
          ),
          operator: KeywordDescTable[t & 255],
        },
        start,
      );
    }
    if (parser.getToken() === 1077936155) parser.report(26);
    return left;
  }
  function parseUnaryExpression(parser, context, privateScope, isLHS, inGroup) {
    if (!isLHS) parser.report(0);
    const { tokenStart: tokenStart } = parser;
    const unaryOperator = parser.getToken();
    nextToken(parser, context | 32);
    const arg = parseLeftHandSideExpression(
      parser,
      context,
      privateScope,
      0,
      inGroup,
      1,
    );
    if (parser.getToken() === 8391735) parser.report(33);
    if (context & 1 && unaryOperator === 16863276) {
      if (arg.type === 'Identifier') {
        parser.report(121);
      } else if (isPropertyWithPrivateFieldKey(arg)) {
        parser.report(127);
      }
    }
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'UnaryExpression',
        operator: KeywordDescTable[unaryOperator & 255],
        argument: arg,
        prefix: true,
      },
      tokenStart,
    );
  }
  function parseAsyncExpression(
    parser,
    context,
    privateScope,
    inGroup,
    isLHS,
    canAssign,
    inNew,
    start,
  ) {
    const token = parser.getToken();
    const expr = parseIdentifier(parser, context);
    const { flags: flags } = parser;
    if ((flags & 1) === 0) {
      if (parser.getToken() === 86104) {
        return parseFunctionExpression(
          parser,
          context,
          privateScope,
          1,
          inGroup,
          start,
        );
      }
      if (isValidIdentifier(context, parser.getToken())) {
        if (!isLHS) parser.report(0);
        if ((parser.getToken() & 36864) === 36864) {
          parser.flags |= 256;
        }
        return parseAsyncArrowAfterIdent(
          parser,
          context,
          privateScope,
          canAssign,
          start,
        );
      }
    }
    if (!inNew && parser.getToken() === 67174411) {
      return parseAsyncArrowOrCallExpression(
        parser,
        context,
        privateScope,
        expr,
        canAssign,
        1,
        0,
        flags,
        start,
      );
    }
    if (parser.getToken() === 10) {
      classifyIdentifier(parser, context, token);
      if (inNew) parser.report(51);
      if ((token & 36864) === 36864) {
        parser.flags |= 256;
      }
      return parseArrowFromIdentifier(
        parser,
        context,
        privateScope,
        parser.tokenValue,
        expr,
        inNew,
        canAssign,
        0,
        start,
      );
    }
    parser.assignable = 1;
    return expr;
  }
  function parseYieldExpressionOrIdentifier(
    parser,
    context,
    privateScope,
    inGroup,
    canAssign,
    start,
  ) {
    if (inGroup) parser.destructible |= 256;
    if (context & 1024) {
      nextToken(parser, context | 32);
      if (context & 8192) parser.report(32);
      if (!canAssign) parser.report(26);
      if (parser.getToken() === 22) parser.report(124);
      let argument = null;
      let delegate = false;
      if ((parser.flags & 1) === 0) {
        delegate = consumeOpt(parser, context | 32, 8391476);
        if (parser.getToken() & (12288 | 65536) || delegate) {
          argument = parseExpression(
            parser,
            context,
            privateScope,
            1,
            0,
            parser.tokenStart,
          );
        }
      } else if (parser.getToken() === 8391476) {
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
      }
      parser.assignable = 2;
      return parser.finishNode(
        { type: 'YieldExpression', argument: argument, delegate: delegate },
        start,
      );
    }
    if (context & 1) parser.report(97, 'yield');
    return parseIdentifierOrArrow(parser, context, privateScope);
  }
  function parseAwaitExpressionOrIdentifier(
    parser,
    context,
    privateScope,
    inNew,
    inGroup,
    start,
  ) {
    if (inGroup) parser.destructible |= 128;
    if (context & 524288) parser.report(177);
    const possibleIdentifierOrArrowFunc = parseIdentifierOrArrow(
      parser,
      context,
      privateScope,
    );
    const isIdentifier =
      possibleIdentifierOrArrowFunc.type === 'ArrowFunctionExpression' ||
      (parser.getToken() & 65536) === 0;
    if (isIdentifier) {
      if (context & 2048)
        throw new ParseError(
          start,
          {
            index: parser.startIndex,
            line: parser.startLine,
            column: parser.startColumn,
          },
          176,
        );
      if (context & 2)
        throw new ParseError(
          start,
          {
            index: parser.startIndex,
            line: parser.startLine,
            column: parser.startColumn,
          },
          110,
        );
      if (context & 8192 && context & 2048)
        throw new ParseError(
          start,
          {
            index: parser.startIndex,
            line: parser.startLine,
            column: parser.startColumn,
          },
          110,
        );
      return possibleIdentifierOrArrowFunc;
    }
    if (context & 8192) {
      throw new ParseError(
        start,
        {
          index: parser.startIndex,
          line: parser.startLine,
          column: parser.startColumn,
        },
        31,
      );
    }
    if (context & 2048 || (context & 2 && context & 8)) {
      if (inNew)
        throw new ParseError(
          start,
          {
            index: parser.startIndex,
            line: parser.startLine,
            column: parser.startColumn,
          },
          0,
        );
      const argument = parseLeftHandSideExpression(
        parser,
        context,
        privateScope,
        0,
        0,
        1,
      );
      if (parser.getToken() === 8391735) parser.report(33);
      parser.assignable = 2;
      return parser.finishNode(
        { type: 'AwaitExpression', argument: argument },
        start,
      );
    }
    if (context & 2)
      throw new ParseError(
        start,
        {
          index: parser.startIndex,
          line: parser.startLine,
          column: parser.startColumn,
        },
        98,
      );
    return possibleIdentifierOrArrowFunc;
  }
  function parseFunctionBody(
    parser,
    context,
    scope,
    privateScope,
    origin,
    funcNameToken,
    functionScope,
  ) {
    const { tokenStart: tokenStart } = parser;
    consume(parser, context | 32, 2162700);
    const body = [];
    if (parser.getToken() !== 1074790415) {
      while (parser.getToken() === 134283267) {
        const {
          index: index,
          tokenStart: tokenStart,
          tokenIndex: tokenIndex,
          tokenValue: tokenValue,
        } = parser;
        const token = parser.getToken();
        const expr = parseLiteral(parser, context);
        if (isValidStrictMode(parser, index, tokenIndex, tokenValue)) {
          context |= 1;
          if (parser.flags & 128) {
            throw new ParseError(tokenStart, parser.currentLocation, 66);
          }
          if (parser.flags & 64) {
            throw new ParseError(tokenStart, parser.currentLocation, 9);
          }
          if (parser.flags & 4096) {
            throw new ParseError(tokenStart, parser.currentLocation, 15);
          }
          functionScope?.reportScopeError();
        }
        body.push(parseDirective(parser, context, expr, token, tokenStart));
      }
      if (context & 1) {
        if (funcNameToken) {
          if ((funcNameToken & 537079808) === 537079808) {
            parser.report(119);
          }
          if ((funcNameToken & 36864) === 36864) {
            parser.report(40);
          }
        }
        if (parser.flags & 512) parser.report(119);
        if (parser.flags & 256) parser.report(118);
      }
    }
    parser.flags =
      (parser.flags | 512 | 256 | 64 | 4096) ^ (512 | 256 | 64 | 4096);
    parser.destructible = (parser.destructible | 256) ^ 256;
    while (parser.getToken() !== 1074790415) {
      body.push(
        parseStatementListItem(parser, context, scope, privateScope, 4, {}),
      );
    }
    consume(parser, origin & (16 | 8) ? context | 32 : context, 1074790415);
    parser.flags &= -4289;
    if (parser.getToken() === 1077936155) parser.report(26);
    return parser.finishNode(
      { type: 'BlockStatement', body: body },
      tokenStart,
    );
  }
  function parseSuperExpression(parser, context) {
    const { tokenStart: tokenStart } = parser;
    nextToken(parser, context);
    switch (parser.getToken()) {
      case 67108990:
        parser.report(167);
      case 67174411: {
        if ((context & 512) === 0) parser.report(28);
        parser.assignable = 2;
        break;
      }
      case 69271571:
      case 67108877: {
        if ((context & 256) === 0) parser.report(29);
        parser.assignable = 1;
        break;
      }
      default:
        parser.report(30, 'super');
    }
    return parser.finishNode({ type: 'Super' }, tokenStart);
  }
  function parseLeftHandSideExpression(
    parser,
    context,
    privateScope,
    canAssign,
    inGroup,
    isLHS,
  ) {
    const start = parser.tokenStart;
    const expression = parsePrimaryExpression(
      parser,
      context,
      privateScope,
      2,
      0,
      canAssign,
      inGroup,
      isLHS,
      start,
    );
    return parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expression,
      inGroup,
      0,
      start,
    );
  }
  function parseUpdateExpression(parser, context, expr, start) {
    if (parser.assignable & 2) parser.report(55);
    const token = parser.getToken();
    nextToken(parser, context);
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'UpdateExpression',
        argument: expr,
        operator: KeywordDescTable[token & 255],
        prefix: false,
      },
      start,
    );
  }
  function parseMemberOrUpdateExpression(
    parser,
    context,
    privateScope,
    expr,
    inGroup,
    inChain,
    start,
  ) {
    if (
      (parser.getToken() & 33619968) === 33619968 &&
      (parser.flags & 1) === 0
    ) {
      expr = parseUpdateExpression(parser, context, expr, start);
    } else if ((parser.getToken() & 67108864) === 67108864) {
      context = (context | 131072) ^ 131072;
      switch (parser.getToken()) {
        case 67108877: {
          nextToken(parser, (context | 262144 | 8) ^ 8);
          if (
            context & 16 &&
            parser.getToken() === 130 &&
            parser.tokenValue === 'super'
          ) {
            parser.report(173);
          }
          parser.assignable = 1;
          const property = parsePropertyOrPrivatePropertyName(
            parser,
            context | 64,
            privateScope,
          );
          expr = parser.finishNode(
            {
              type: 'MemberExpression',
              object: expr,
              computed: false,
              property: property,
              optional: false,
            },
            start,
          );
          break;
        }
        case 69271571: {
          let restoreHasOptionalChaining = false;
          if ((parser.flags & 2048) === 2048) {
            restoreHasOptionalChaining = true;
            parser.flags = (parser.flags | 2048) ^ 2048;
          }
          nextToken(parser, context | 32);
          const { tokenStart: tokenStart } = parser;
          const property = parseExpressions(
            parser,
            context,
            privateScope,
            inGroup,
            1,
            tokenStart,
          );
          consume(parser, context, 20);
          parser.assignable = 1;
          expr = parser.finishNode(
            {
              type: 'MemberExpression',
              object: expr,
              computed: true,
              property: property,
              optional: false,
            },
            start,
          );
          if (restoreHasOptionalChaining) {
            parser.flags |= 2048;
          }
          break;
        }
        case 67174411: {
          if ((parser.flags & 1024) === 1024) {
            parser.flags = (parser.flags | 1024) ^ 1024;
            return expr;
          }
          let restoreHasOptionalChaining = false;
          if ((parser.flags & 2048) === 2048) {
            restoreHasOptionalChaining = true;
            parser.flags = (parser.flags | 2048) ^ 2048;
          }
          const args = parseArguments(parser, context, privateScope, inGroup);
          parser.assignable = 2;
          expr = parser.finishNode(
            {
              type: 'CallExpression',
              callee: expr,
              arguments: args,
              optional: false,
            },
            start,
          );
          if (restoreHasOptionalChaining) {
            parser.flags |= 2048;
          }
          break;
        }
        case 67108990: {
          nextToken(parser, (context | 262144 | 8) ^ 8);
          parser.flags |= 2048;
          parser.assignable = 2;
          expr = parseOptionalChain(parser, context, privateScope, expr, start);
          break;
        }
        default:
          if ((parser.flags & 2048) === 2048) {
            parser.report(166);
          }
          parser.assignable = 2;
          expr = parser.finishNode(
            {
              type: 'TaggedTemplateExpression',
              tag: expr,
              quasi:
                parser.getToken() === 67174408
                  ? parseTemplate(parser, context | 64, privateScope)
                  : parseTemplateLiteral(parser, context),
            },
            start,
          );
      }
      expr = parseMemberOrUpdateExpression(
        parser,
        context,
        privateScope,
        expr,
        0,
        1,
        start,
      );
    }
    if (inChain === 0 && (parser.flags & 2048) === 2048) {
      parser.flags = (parser.flags | 2048) ^ 2048;
      expr = parser.finishNode(
        { type: 'ChainExpression', expression: expr },
        start,
      );
    }
    return expr;
  }
  function parseOptionalChain(parser, context, privateScope, expr, start) {
    let restoreHasOptionalChaining = false;
    let node;
    if (parser.getToken() === 69271571 || parser.getToken() === 67174411) {
      if ((parser.flags & 2048) === 2048) {
        restoreHasOptionalChaining = true;
        parser.flags = (parser.flags | 2048) ^ 2048;
      }
    }
    if (parser.getToken() === 69271571) {
      nextToken(parser, context | 32);
      const { tokenStart: tokenStart } = parser;
      const property = parseExpressions(
        parser,
        context,
        privateScope,
        0,
        1,
        tokenStart,
      );
      consume(parser, context, 20);
      parser.assignable = 2;
      node = parser.finishNode(
        {
          type: 'MemberExpression',
          object: expr,
          computed: true,
          optional: true,
          property: property,
        },
        start,
      );
    } else if (parser.getToken() === 67174411) {
      const args = parseArguments(parser, context, privateScope, 0);
      parser.assignable = 2;
      node = parser.finishNode(
        {
          type: 'CallExpression',
          callee: expr,
          arguments: args,
          optional: true,
        },
        start,
      );
    } else {
      const property = parsePropertyOrPrivatePropertyName(
        parser,
        context,
        privateScope,
      );
      parser.assignable = 2;
      node = parser.finishNode(
        {
          type: 'MemberExpression',
          object: expr,
          computed: false,
          optional: true,
          property: property,
        },
        start,
      );
    }
    if (restoreHasOptionalChaining) {
      parser.flags |= 2048;
    }
    return node;
  }
  function parsePropertyOrPrivatePropertyName(parser, context, privateScope) {
    if (
      (parser.getToken() & 143360) === 0 &&
      parser.getToken() !== -2147483528 &&
      parser.getToken() !== -2147483527 &&
      parser.getToken() !== 130
    ) {
      parser.report(160);
    }
    return parser.getToken() === 130
      ? parsePrivateIdentifier(parser, context, privateScope, 0)
      : parseIdentifier(parser, context);
  }
  function parseUpdateExpressionPrefixed(
    parser,
    context,
    privateScope,
    inNew,
    isLHS,
    start,
  ) {
    if (inNew) parser.report(56);
    if (!isLHS) parser.report(0);
    const token = parser.getToken();
    nextToken(parser, context | 32);
    const arg = parseLeftHandSideExpression(
      parser,
      context,
      privateScope,
      0,
      0,
      1,
    );
    if (parser.assignable & 2) {
      parser.report(55);
    }
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'UpdateExpression',
        argument: arg,
        operator: KeywordDescTable[token & 255],
        prefix: true,
      },
      start,
    );
  }
  function parsePrimaryExpression(
    parser,
    context,
    privateScope,
    kind,
    inNew,
    canAssign,
    inGroup,
    isLHS,
    start,
  ) {
    if ((parser.getToken() & 143360) === 143360) {
      switch (parser.getToken()) {
        case 209006:
          return parseAwaitExpressionOrIdentifier(
            parser,
            context,
            privateScope,
            inNew,
            inGroup,
            start,
          );
        case 241771:
          return parseYieldExpressionOrIdentifier(
            parser,
            context,
            privateScope,
            inGroup,
            canAssign,
            start,
          );
        case 209005:
          return parseAsyncExpression(
            parser,
            context,
            privateScope,
            inGroup,
            isLHS,
            canAssign,
            inNew,
            start,
          );
      }
      const { tokenValue: tokenValue } = parser;
      const token = parser.getToken();
      const expr = parseIdentifier(parser, context | 64);
      if (parser.getToken() === 10) {
        if (!isLHS) parser.report(0);
        classifyIdentifier(parser, context, token);
        if ((token & 36864) === 36864) {
          parser.flags |= 256;
        }
        return parseArrowFromIdentifier(
          parser,
          context,
          privateScope,
          tokenValue,
          expr,
          inNew,
          canAssign,
          0,
          start,
        );
      }
      if (
        context & 16 &&
        !(context & 32768) &&
        !(context & 8192) &&
        parser.tokenValue === 'arguments'
      )
        parser.report(130);
      if ((token & 255) === (241737 & 255)) {
        if (context & 1) parser.report(113);
        if (kind & (8 | 16)) parser.report(100);
      }
      parser.assignable =
        context & 1 && (token & 537079808) === 537079808 ? 2 : 1;
      return expr;
    }
    if ((parser.getToken() & 134217728) === 134217728) {
      return parseLiteral(parser, context);
    }
    switch (parser.getToken()) {
      case 33619993:
      case 33619994:
        return parseUpdateExpressionPrefixed(
          parser,
          context,
          privateScope,
          inNew,
          isLHS,
          start,
        );
      case 16863276:
      case 16842798:
      case 16842799:
      case 25233968:
      case 25233969:
      case 16863275:
      case 16863277:
        return parseUnaryExpression(
          parser,
          context,
          privateScope,
          isLHS,
          inGroup,
        );
      case 86104:
        return parseFunctionExpression(
          parser,
          context,
          privateScope,
          0,
          inGroup,
          start,
        );
      case 2162700:
        return parseObjectLiteral(
          parser,
          context,
          privateScope,
          canAssign ? 0 : 1,
          inGroup,
        );
      case 69271571:
        return parseArrayLiteral(
          parser,
          context,
          privateScope,
          canAssign ? 0 : 1,
          inGroup,
        );
      case 67174411:
        return parseParenthesizedExpression(
          parser,
          context | 64,
          privateScope,
          canAssign,
          1,
          0,
          start,
        );
      case 86021:
      case 86022:
      case 86023:
        return parseNullOrTrueOrFalseLiteral(parser, context);
      case 86111:
        return parseThisExpression(parser, context);
      case 65540:
        return parseRegExpLiteral(parser, context);
      case 132:
      case 86094:
        return parseClassExpression(
          parser,
          context,
          privateScope,
          inGroup,
          start,
        );
      case 86109:
        return parseSuperExpression(parser, context);
      case 67174409:
        return parseTemplateLiteral(parser, context);
      case 67174408:
        return parseTemplate(parser, context, privateScope);
      case 86107:
        return parseNewExpression(parser, context, privateScope, inGroup);
      case 134283388:
        return parseBigIntLiteral(parser, context);
      case 130:
        return parsePrivateIdentifier(parser, context, privateScope, 0);
      case 86106:
        return parseImportCallOrMetaExpression(
          parser,
          context,
          privateScope,
          inNew,
          inGroup,
          start,
        );
      case 8456256:
        if (parser.options.jsx)
          return parseJSXRootElementOrFragment(
            parser,
            context,
            privateScope,
            0,
            parser.tokenStart,
          );
      default:
        if (isValidIdentifier(context, parser.getToken()))
          return parseIdentifierOrArrow(parser, context, privateScope);
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
  }
  function parseImportCallOrMetaExpression(
    parser,
    context,
    privateScope,
    inNew,
    inGroup,
    start,
  ) {
    let expr = parseIdentifier(parser, context);
    if (parser.getToken() === 67108877) {
      return parseImportMetaExpression(parser, context, expr, start);
    }
    if (inNew) parser.report(142);
    expr = parseImportExpression(parser, context, privateScope, inGroup, start);
    parser.assignable = 2;
    return parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expr,
      inGroup,
      0,
      start,
    );
  }
  function parseImportMetaExpression(parser, context, meta, start) {
    if ((context & 2) === 0) parser.report(169);
    nextToken(parser, context);
    const token = parser.getToken();
    if (token !== 209030 && parser.tokenValue !== 'meta') {
      parser.report(174);
    } else if (token & -2147483648) {
      parser.report(175);
    }
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'MetaProperty',
        meta: meta,
        property: parseIdentifier(parser, context),
      },
      start,
    );
  }
  function parseImportExpression(
    parser,
    context,
    privateScope,
    inGroup,
    start,
  ) {
    consume(parser, context | 32, 67174411);
    if (parser.getToken() === 14) parser.report(143);
    const source = parseExpression(
      parser,
      context,
      privateScope,
      1,
      inGroup,
      parser.tokenStart,
    );
    let options = null;
    if (parser.getToken() === 18) {
      consume(parser, context, 18);
      if (parser.getToken() !== 16) {
        const expContext = (context | 131072) ^ 131072;
        options = parseExpression(
          parser,
          expContext,
          privateScope,
          1,
          inGroup,
          parser.tokenStart,
        );
      }
      consumeOpt(parser, context, 18);
    }
    const node = { type: 'ImportExpression', source: source, options: options };
    consume(parser, context, 16);
    return parser.finishNode(node, start);
  }
  function parseImportAttributes(parser, context) {
    if (!consumeOpt(parser, context, 20579)) return [];
    consume(parser, context, 2162700);
    const attributes = [];
    const keysContent = new Set();
    while (parser.getToken() !== 1074790415) {
      const start = parser.tokenStart;
      const key = parseIdentifierOrStringLiteral(parser, context);
      consume(parser, context, 21);
      const value = parseStringLiteral(parser, context);
      const keyContent = key.type === 'Literal' ? key.value : key.name;
      if (keysContent.has(keyContent)) {
        parser.report(145, `${keyContent}`);
      }
      keysContent.add(keyContent);
      attributes.push(
        parser.finishNode(
          { type: 'ImportAttribute', key: key, value: value },
          start,
        ),
      );
      if (parser.getToken() !== 1074790415) {
        consume(parser, context, 18);
      }
    }
    consume(parser, context, 1074790415);
    return attributes;
  }
  function parseStringLiteral(parser, context) {
    if (parser.getToken() === 134283267) {
      return parseLiteral(parser, context);
    } else {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
  }
  function parseIdentifierOrStringLiteral(parser, context) {
    if (parser.getToken() === 134283267) {
      return parseLiteral(parser, context);
    } else if (parser.getToken() & 143360) {
      return parseIdentifier(parser, context);
    } else {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
  }
  function validateStringWellFormed(parser, str) {
    const len = str.length;
    for (let i = 0; i < len; i++) {
      const code = str.charCodeAt(i);
      if ((code & 64512) !== 55296) continue;
      if (code > 56319 || ++i >= len || (str.charCodeAt(i) & 64512) !== 56320) {
        parser.report(171, JSON.stringify(str.charAt(i--)));
      }
    }
  }
  function parseModuleExportName(parser, context) {
    if (parser.getToken() === 134283267) {
      validateStringWellFormed(parser, parser.tokenValue);
      return parseLiteral(parser, context);
    } else if (parser.getToken() & 143360) {
      return parseIdentifier(parser, context);
    } else {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
  }
  function parseBigIntLiteral(parser, context) {
    const {
      tokenRaw: tokenRaw,
      tokenValue: tokenValue,
      tokenStart: tokenStart,
    } = parser;
    nextToken(parser, context);
    parser.assignable = 2;
    const node = {
      type: 'Literal',
      value: tokenValue,
      bigint: String(tokenValue),
    };
    if (parser.options.raw) {
      node.raw = tokenRaw;
    }
    return parser.finishNode(node, tokenStart);
  }
  function parseTemplateLiteral(parser, context) {
    parser.assignable = 2;
    const {
      tokenValue: tokenValue,
      tokenRaw: tokenRaw,
      tokenStart: tokenStart,
    } = parser;
    consume(parser, context, 67174409);
    const quasis = [
      parseTemplateElement(parser, tokenValue, tokenRaw, tokenStart, true),
    ];
    return parser.finishNode(
      { type: 'TemplateLiteral', expressions: [], quasis: quasis },
      tokenStart,
    );
  }
  function parseTemplate(parser, context, privateScope) {
    context = (context | 131072) ^ 131072;
    const {
      tokenValue: tokenValue,
      tokenRaw: tokenRaw,
      tokenStart: tokenStart,
    } = parser;
    consume(parser, (context & -65) | 32, 67174408);
    const quasis = [
      parseTemplateElement(parser, tokenValue, tokenRaw, tokenStart, false),
    ];
    const expressions = [
      parseExpressions(
        parser,
        context & -65,
        privateScope,
        0,
        1,
        parser.tokenStart,
      ),
    ];
    if (parser.getToken() !== 1074790415) parser.report(83);
    while (
      parser.setToken(scanTemplateTail(parser, context), true) !== 67174409
    ) {
      const {
        tokenValue: tokenValue,
        tokenRaw: tokenRaw,
        tokenStart: tokenStart,
      } = parser;
      consume(parser, (context & -65) | 32, 67174408);
      quasis.push(
        parseTemplateElement(parser, tokenValue, tokenRaw, tokenStart, false),
      );
      expressions.push(
        parseExpressions(
          parser,
          context,
          privateScope,
          0,
          1,
          parser.tokenStart,
        ),
      );
      if (parser.getToken() !== 1074790415) parser.report(83);
    }
    {
      const {
        tokenValue: tokenValue,
        tokenRaw: tokenRaw,
        tokenStart: tokenStart,
      } = parser;
      consume(parser, context, 67174409);
      quasis.push(
        parseTemplateElement(parser, tokenValue, tokenRaw, tokenStart, true),
      );
    }
    return parser.finishNode(
      { type: 'TemplateLiteral', expressions: expressions, quasis: quasis },
      tokenStart,
    );
  }
  function parseTemplateElement(parser, cooked, raw, start, tail) {
    const node = parser.finishNode(
      {
        type: 'TemplateElement',
        value: { cooked: cooked, raw: raw },
        tail: tail,
      },
      start,
    );
    const tailSize = tail ? 1 : 2;
    if (parser.options.ranges) {
      node.start += 1;
      node.range[0] += 1;
      node.end -= tailSize;
      node.range[1] -= tailSize;
    }
    if (parser.options.loc) {
      node.loc.start.column += 1;
      node.loc.end.column -= tailSize;
    }
    return node;
  }
  function parseSpreadElement(parser, context, privateScope) {
    const start = parser.tokenStart;
    context = (context | 131072) ^ 131072;
    consume(parser, context | 32, 14);
    const argument = parseExpression(
      parser,
      context,
      privateScope,
      1,
      0,
      parser.tokenStart,
    );
    parser.assignable = 1;
    return parser.finishNode(
      { type: 'SpreadElement', argument: argument },
      start,
    );
  }
  function parseArguments(parser, context, privateScope, inGroup) {
    nextToken(parser, context | 32);
    const args = [];
    if (parser.getToken() === 16) {
      nextToken(parser, context | 64);
      return args;
    }
    while (parser.getToken() !== 16) {
      if (parser.getToken() === 14) {
        args.push(parseSpreadElement(parser, context, privateScope));
      } else {
        args.push(
          parseExpression(
            parser,
            context,
            privateScope,
            1,
            inGroup,
            parser.tokenStart,
          ),
        );
      }
      if (parser.getToken() !== 18) break;
      nextToken(parser, context | 32);
      if (parser.getToken() === 16) break;
    }
    consume(parser, context | 64, 16);
    return args;
  }
  function parseIdentifier(parser, context) {
    const { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
    const allowRegex =
      tokenValue === 'await' && (parser.getToken() & -2147483648) === 0;
    nextToken(parser, context | (allowRegex ? 32 : 0));
    return parser.finishNode(
      { type: 'Identifier', name: tokenValue },
      tokenStart,
    );
  }
  function parseLiteral(parser, context) {
    const {
      tokenValue: tokenValue,
      tokenRaw: tokenRaw,
      tokenStart: tokenStart,
    } = parser;
    if (parser.getToken() === 134283388) {
      return parseBigIntLiteral(parser, context);
    }
    nextToken(parser, context);
    parser.assignable = 2;
    return parser.finishNode(
      parser.options.raw
        ? { type: 'Literal', value: tokenValue, raw: tokenRaw }
        : { type: 'Literal', value: tokenValue },
      tokenStart,
    );
  }
  function parseNullOrTrueOrFalseLiteral(parser, context) {
    const start = parser.tokenStart;
    const raw = KeywordDescTable[parser.getToken() & 255];
    const value = parser.getToken() === 86023 ? null : raw === 'true';
    nextToken(parser, context);
    parser.assignable = 2;
    return parser.finishNode(
      parser.options.raw
        ? { type: 'Literal', value: value, raw: raw }
        : { type: 'Literal', value: value },
      start,
    );
  }
  function parseThisExpression(parser, context) {
    const { tokenStart: tokenStart } = parser;
    nextToken(parser, context);
    parser.assignable = 2;
    return parser.finishNode({ type: 'ThisExpression' }, tokenStart);
  }
  function parseFunctionDeclaration(
    parser,
    context,
    scope,
    privateScope,
    origin,
    allowGen,
    flags,
    isAsync,
    start,
  ) {
    nextToken(parser, context | 32);
    const isGenerator = allowGen ? optionalBit(parser, context, 8391476) : 0;
    let id = null;
    let funcNameToken;
    let functionScope = scope ? parser.createScope() : void 0;
    if (parser.getToken() === 67174411) {
      if ((flags & 1) === 0) parser.report(39, 'Function');
    } else {
      const kind =
        origin & 4 && ((context & 8) === 0 || (context & 2) === 0)
          ? 4
          : 64 | (isAsync ? 1024 : 0) | (isGenerator ? 1024 : 0);
      validateFunctionName(parser, context, parser.getToken());
      if (scope) {
        if (kind & 4) {
          scope.addVarName(context, parser.tokenValue, kind);
        } else {
          scope.addBlockName(context, parser.tokenValue, kind, origin);
        }
        functionScope = functionScope?.createChildScope(128);
        if (flags) {
          if (flags & 2) {
            parser.declareUnboundVariable(parser.tokenValue);
          }
        }
      }
      funcNameToken = parser.getToken();
      if (parser.getToken() & 143360) {
        id = parseIdentifier(parser, context);
      } else {
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
      }
    }
    {
      const modifierFlags = 256 | 512 | 1024 | 2048 | 8192 | 16384;
      context =
        ((context | modifierFlags) ^ modifierFlags) |
        65536 |
        (isAsync ? 2048 : 0) |
        (isGenerator ? 1024 : 0) |
        (isGenerator ? 0 : 262144);
    }
    functionScope = functionScope?.createChildScope(256);
    const params = parseFormalParametersOrFormalList(
      parser,
      (context | 8192) & -524289,
      functionScope,
      privateScope,
      0,
      1,
    );
    const modifierFlags = 8 | 4 | 128 | 524288;
    const body = parseFunctionBody(
      parser,
      ((context | modifierFlags) ^ modifierFlags) | 32768 | 4096,
      functionScope?.createChildScope(64),
      privateScope,
      8,
      funcNameToken,
      functionScope,
    );
    return parser.finishNode(
      {
        type: 'FunctionDeclaration',
        id: id,
        params: params,
        body: body,
        async: isAsync === 1,
        generator: isGenerator === 1,
      },
      start,
    );
  }
  function parseFunctionExpression(
    parser,
    context,
    privateScope,
    isAsync,
    inGroup,
    start,
  ) {
    nextToken(parser, context | 32);
    const isGenerator = optionalBit(parser, context, 8391476);
    const generatorAndAsyncFlags =
      (isAsync ? 2048 : 0) | (isGenerator ? 1024 : 0);
    let id = null;
    let funcNameToken;
    let scope = parser.createScopeIfLexical();
    const modifierFlags = 256 | 512 | 1024 | 2048 | 8192 | 16384 | 524288;
    if (parser.getToken() & 143360) {
      validateFunctionName(
        parser,
        ((context | modifierFlags) ^ modifierFlags) | generatorAndAsyncFlags,
        parser.getToken(),
      );
      scope = scope?.createChildScope(128);
      funcNameToken = parser.getToken();
      id = parseIdentifier(parser, context);
    }
    context =
      ((context | modifierFlags) ^ modifierFlags) |
      65536 |
      generatorAndAsyncFlags |
      (isGenerator ? 0 : 262144);
    scope = scope?.createChildScope(256);
    const params = parseFormalParametersOrFormalList(
      parser,
      (context | 8192) & -524289,
      scope,
      privateScope,
      inGroup,
      1,
    );
    const body = parseFunctionBody(
      parser,
      (context & -131229) | 32768 | 4096,
      scope?.createChildScope(64),
      privateScope,
      0,
      funcNameToken,
      scope,
    );
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'FunctionExpression',
        id: id,
        params: params,
        body: body,
        async: isAsync === 1,
        generator: isGenerator === 1,
      },
      start,
    );
  }
  function parseArrayLiteral(
    parser,
    context,
    privateScope,
    skipInitializer,
    inGroup,
  ) {
    const expr = parseArrayExpressionOrPattern(
      parser,
      context,
      void 0,
      privateScope,
      skipInitializer,
      inGroup,
      0,
      2,
      0,
    );
    if (parser.destructible & 64) {
      parser.report(63);
    }
    if (parser.destructible & 8) {
      parser.report(62);
    }
    return expr;
  }
  function parseArrayExpressionOrPattern(
    parser,
    context,
    scope,
    privateScope,
    skipInitializer,
    inGroup,
    isPattern,
    kind,
    origin,
  ) {
    const { tokenStart: start } = parser;
    nextToken(parser, context | 32);
    const elements = [];
    let destructible = 0;
    context = (context | 131072) ^ 131072;
    while (parser.getToken() !== 20) {
      if (consumeOpt(parser, context | 32, 18)) {
        elements.push(null);
      } else {
        let left;
        const { tokenStart: tokenStart, tokenValue: tokenValue } = parser;
        const token = parser.getToken();
        if (token & 143360) {
          left = parsePrimaryExpression(
            parser,
            context,
            privateScope,
            kind,
            0,
            1,
            inGroup,
            1,
            tokenStart,
          );
          if (parser.getToken() === 1077936155) {
            if (parser.assignable & 2) parser.report(26);
            nextToken(parser, context | 32);
            scope?.addVarOrBlock(context, tokenValue, kind, origin);
            const right = parseExpression(
              parser,
              context,
              privateScope,
              1,
              inGroup,
              parser.tokenStart,
            );
            left = parser.finishNode(
              isPattern
                ? { type: 'AssignmentPattern', left: left, right: right }
                : {
                    type: 'AssignmentExpression',
                    operator: '=',
                    left: left,
                    right: right,
                  },
              tokenStart,
            );
            destructible |=
              parser.destructible & 256
                ? 256
                : 0 | (parser.destructible & 128)
                  ? 128
                  : 0;
          } else if (parser.getToken() === 18 || parser.getToken() === 20) {
            if (parser.assignable & 2) {
              destructible |= 16;
            } else {
              scope?.addVarOrBlock(context, tokenValue, kind, origin);
            }
            destructible |=
              parser.destructible & 256
                ? 256
                : 0 | (parser.destructible & 128)
                  ? 128
                  : 0;
          } else {
            destructible |= kind & 1 ? 32 : (kind & 2) === 0 ? 16 : 0;
            left = parseMemberOrUpdateExpression(
              parser,
              context,
              privateScope,
              left,
              inGroup,
              0,
              tokenStart,
            );
            if (parser.getToken() !== 18 && parser.getToken() !== 20) {
              if (parser.getToken() !== 1077936155) destructible |= 16;
              left = parseAssignmentExpression(
                parser,
                context,
                privateScope,
                inGroup,
                isPattern,
                tokenStart,
                left,
              );
            } else if (parser.getToken() !== 1077936155) {
              destructible |= parser.assignable & 2 ? 16 : 32;
            }
          }
        } else if (token & 2097152) {
          left =
            parser.getToken() === 2162700
              ? parseObjectLiteralOrPattern(
                  parser,
                  context,
                  scope,
                  privateScope,
                  0,
                  inGroup,
                  isPattern,
                  kind,
                  origin,
                )
              : parseArrayExpressionOrPattern(
                  parser,
                  context,
                  scope,
                  privateScope,
                  0,
                  inGroup,
                  isPattern,
                  kind,
                  origin,
                );
          destructible |= parser.destructible;
          parser.assignable = parser.destructible & 16 ? 2 : 1;
          if (parser.getToken() === 18 || parser.getToken() === 20) {
            if (parser.assignable & 2) {
              destructible |= 16;
            }
          } else if (parser.destructible & 8) {
            parser.report(71);
          } else {
            left = parseMemberOrUpdateExpression(
              parser,
              context,
              privateScope,
              left,
              inGroup,
              0,
              tokenStart,
            );
            destructible = parser.assignable & 2 ? 16 : 0;
            if (parser.getToken() !== 18 && parser.getToken() !== 20) {
              left = parseAssignmentExpression(
                parser,
                context,
                privateScope,
                inGroup,
                isPattern,
                tokenStart,
                left,
              );
            } else if (parser.getToken() !== 1077936155) {
              destructible |= parser.assignable & 2 ? 16 : 32;
            }
          }
        } else if (token === 14) {
          left = parseSpreadOrRestElement(
            parser,
            context,
            scope,
            privateScope,
            20,
            kind,
            origin,
            0,
            inGroup,
            isPattern,
          );
          destructible |= parser.destructible;
          if (parser.getToken() !== 18 && parser.getToken() !== 20)
            parser.report(30, KeywordDescTable[parser.getToken() & 255]);
        } else {
          left = parseLeftHandSideExpression(
            parser,
            context,
            privateScope,
            1,
            0,
            1,
          );
          if (parser.getToken() !== 18 && parser.getToken() !== 20) {
            left = parseAssignmentExpression(
              parser,
              context,
              privateScope,
              inGroup,
              isPattern,
              tokenStart,
              left,
            );
            if ((kind & (2 | 1)) === 0 && token === 67174411)
              destructible |= 16;
          } else if (parser.assignable & 2) {
            destructible |= 16;
          } else if (token === 67174411) {
            destructible |= parser.assignable & 1 && kind & (2 | 1) ? 32 : 16;
          }
        }
        elements.push(left);
        if (consumeOpt(parser, context | 32, 18)) {
          if (parser.getToken() === 20) break;
        } else break;
      }
    }
    consume(parser, context, 20);
    const node = parser.finishNode(
      {
        type: isPattern ? 'ArrayPattern' : 'ArrayExpression',
        elements: elements,
      },
      start,
    );
    if (!skipInitializer && parser.getToken() & 4194304) {
      return parseArrayOrObjectAssignmentPattern(
        parser,
        context,
        privateScope,
        destructible,
        inGroup,
        isPattern,
        start,
        node,
      );
    }
    parser.destructible = destructible;
    return node;
  }
  function parseArrayOrObjectAssignmentPattern(
    parser,
    context,
    privateScope,
    destructible,
    inGroup,
    isPattern,
    start,
    node,
  ) {
    if (parser.getToken() !== 1077936155) parser.report(26);
    nextToken(parser, context | 32);
    if (destructible & 16) parser.report(26);
    if (!isPattern) reinterpretToPattern(parser, node);
    const { tokenStart: tokenStart } = parser;
    const right = parseExpression(
      parser,
      context,
      privateScope,
      1,
      inGroup,
      tokenStart,
    );
    parser.destructible =
      ((destructible | 64 | 8) ^ (8 | 64)) |
      (parser.destructible & 128 ? 128 : 0) |
      (parser.destructible & 256 ? 256 : 0);
    return parser.finishNode(
      isPattern
        ? { type: 'AssignmentPattern', left: node, right: right }
        : {
            type: 'AssignmentExpression',
            left: node,
            operator: '=',
            right: right,
          },
      start,
    );
  }
  function parseSpreadOrRestElement(
    parser,
    context,
    scope,
    privateScope,
    closingToken,
    kind,
    origin,
    isAsync,
    inGroup,
    isPattern,
  ) {
    const { tokenStart: start } = parser;
    nextToken(parser, context | 32);
    let argument = null;
    let destructible = 0;
    const { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
    let token = parser.getToken();
    if (token & 143360) {
      parser.assignable = 1;
      argument = parsePrimaryExpression(
        parser,
        context,
        privateScope,
        kind,
        0,
        1,
        inGroup,
        1,
        tokenStart,
      );
      token = parser.getToken();
      argument = parseMemberOrUpdateExpression(
        parser,
        context,
        privateScope,
        argument,
        inGroup,
        0,
        tokenStart,
      );
      if (parser.getToken() !== 18 && parser.getToken() !== closingToken) {
        if (parser.assignable & 2 && parser.getToken() === 1077936155)
          parser.report(71);
        destructible |= 16;
        argument = parseAssignmentExpression(
          parser,
          context,
          privateScope,
          inGroup,
          isPattern,
          tokenStart,
          argument,
        );
      }
      if (parser.assignable & 2) {
        destructible |= 16;
      } else if (token === closingToken || token === 18) {
        scope?.addVarOrBlock(context, tokenValue, kind, origin);
      } else {
        destructible |= 32;
      }
      destructible |= parser.destructible & 128 ? 128 : 0;
    } else if (token === closingToken) {
      parser.report(41);
    } else if (token & 2097152) {
      argument =
        parser.getToken() === 2162700
          ? parseObjectLiteralOrPattern(
              parser,
              context,
              scope,
              privateScope,
              1,
              inGroup,
              isPattern,
              kind,
              origin,
            )
          : parseArrayExpressionOrPattern(
              parser,
              context,
              scope,
              privateScope,
              1,
              inGroup,
              isPattern,
              kind,
              origin,
            );
      token = parser.getToken();
      if (token !== 1077936155 && token !== closingToken && token !== 18) {
        if (parser.destructible & 8) parser.report(71);
        argument = parseMemberOrUpdateExpression(
          parser,
          context,
          privateScope,
          argument,
          inGroup,
          0,
          tokenStart,
        );
        destructible |= parser.assignable & 2 ? 16 : 0;
        if ((parser.getToken() & 4194304) === 4194304) {
          if (parser.getToken() !== 1077936155) destructible |= 16;
          argument = parseAssignmentExpression(
            parser,
            context,
            privateScope,
            inGroup,
            isPattern,
            tokenStart,
            argument,
          );
        } else {
          if ((parser.getToken() & 8388608) === 8388608) {
            argument = parseBinaryExpression(
              parser,
              context,
              privateScope,
              1,
              tokenStart,
              4,
              token,
              argument,
            );
          }
          if (consumeOpt(parser, context | 32, 22)) {
            argument = parseConditionalExpression(
              parser,
              context,
              privateScope,
              argument,
              tokenStart,
            );
          }
          destructible |= parser.assignable & 2 ? 16 : 32;
        }
      } else {
        destructible |=
          closingToken === 1074790415 && token !== 1077936155
            ? 16
            : parser.destructible;
      }
    } else {
      destructible |= 32;
      argument = parseLeftHandSideExpression(
        parser,
        context,
        privateScope,
        1,
        inGroup,
        1,
      );
      const { tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      if (token === 1077936155) {
        if (parser.assignable & 2) parser.report(26);
        argument = parseAssignmentExpression(
          parser,
          context,
          privateScope,
          inGroup,
          isPattern,
          tokenStart,
          argument,
        );
        destructible |= 16;
      } else {
        if (token === 18) {
          destructible |= 16;
        } else if (token !== closingToken) {
          argument = parseAssignmentExpression(
            parser,
            context,
            privateScope,
            inGroup,
            isPattern,
            tokenStart,
            argument,
          );
        }
        destructible |= parser.assignable & 1 ? 32 : 16;
      }
      parser.destructible = destructible;
      if (parser.getToken() !== closingToken && parser.getToken() !== 18)
        parser.report(161);
      return parser.finishNode(
        {
          type: isPattern ? 'RestElement' : 'SpreadElement',
          argument: argument,
        },
        start,
      );
    }
    if (parser.getToken() !== closingToken) {
      if (kind & 1) destructible |= isAsync ? 16 : 32;
      if (consumeOpt(parser, context | 32, 1077936155)) {
        if (destructible & 16) parser.report(26);
        reinterpretToPattern(parser, argument);
        const right = parseExpression(
          parser,
          context,
          privateScope,
          1,
          inGroup,
          parser.tokenStart,
        );
        argument = parser.finishNode(
          isPattern
            ? { type: 'AssignmentPattern', left: argument, right: right }
            : {
                type: 'AssignmentExpression',
                left: argument,
                operator: '=',
                right: right,
              },
          tokenStart,
        );
        destructible = 16;
      } else {
        destructible |= 16;
      }
    }
    parser.destructible = destructible;
    return parser.finishNode(
      { type: isPattern ? 'RestElement' : 'SpreadElement', argument: argument },
      start,
    );
  }
  function parseMethodDefinition(
    parser,
    context,
    privateScope,
    kind,
    inGroup,
    start,
  ) {
    const modifierFlags =
      1024 | 2048 | 8192 | ((kind & 64) === 0 ? 512 | 16384 : 0);
    context =
      ((context | modifierFlags) ^ modifierFlags) |
      (kind & 8 ? 1024 : 0) |
      (kind & 16 ? 2048 : 0) |
      (kind & 64 ? 16384 : 0) |
      256 |
      32768 |
      65536;
    let scope = parser.createScopeIfLexical(256);
    const params = parseMethodFormals(
      parser,
      (context | 8192) & -524289,
      scope,
      privateScope,
      kind,
      1,
      inGroup,
    );
    scope = scope?.createChildScope(64);
    const body = parseFunctionBody(
      parser,
      (context & -655373) | 32768 | 4096,
      scope,
      privateScope,
      0,
      void 0,
      scope?.parent,
    );
    return parser.finishNode(
      {
        type: 'FunctionExpression',
        params: params,
        body: body,
        async: (kind & 16) > 0,
        generator: (kind & 8) > 0,
        id: null,
      },
      start,
    );
  }
  function parseObjectLiteral(
    parser,
    context,
    privateScope,
    skipInitializer,
    inGroup,
  ) {
    const expr = parseObjectLiteralOrPattern(
      parser,
      context,
      void 0,
      privateScope,
      skipInitializer,
      inGroup,
      0,
      2,
      0,
    );
    if (parser.destructible & 64) {
      parser.report(63);
    }
    if (parser.destructible & 8) {
      parser.report(62);
    }
    return expr;
  }
  function parseObjectLiteralOrPattern(
    parser,
    context,
    scope,
    privateScope,
    skipInitializer,
    inGroup,
    isPattern,
    kind,
    origin,
  ) {
    const { tokenStart: start } = parser;
    nextToken(parser, context);
    const properties = [];
    let destructible = 0;
    let prototypeCount = 0;
    context = (context | 131072) ^ 131072;
    while (parser.getToken() !== 1074790415) {
      const { tokenValue: tokenValue, tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      if (token === 14) {
        properties.push(
          parseSpreadOrRestElement(
            parser,
            context,
            scope,
            privateScope,
            1074790415,
            kind,
            origin,
            0,
            inGroup,
            isPattern,
          ),
        );
      } else {
        let state = 0;
        let key = null;
        let value;
        if (
          parser.getToken() & 143360 ||
          parser.getToken() === -2147483528 ||
          parser.getToken() === -2147483527
        ) {
          if (parser.getToken() === -2147483527) destructible |= 16;
          key = parseIdentifier(parser, context);
          if (
            parser.getToken() === 18 ||
            parser.getToken() === 1074790415 ||
            parser.getToken() === 1077936155
          ) {
            state |= 4;
            if (context & 1 && (token & 537079808) === 537079808) {
              destructible |= 16;
            } else {
              validateBindingIdentifier(parser, context, kind, token, 0);
            }
            scope?.addVarOrBlock(context, tokenValue, kind, origin);
            if (consumeOpt(parser, context | 32, 1077936155)) {
              destructible |= 8;
              const right = parseExpression(
                parser,
                context,
                privateScope,
                1,
                inGroup,
                parser.tokenStart,
              );
              destructible |=
                parser.destructible & 256
                  ? 256
                  : 0 | (parser.destructible & 128)
                    ? 128
                    : 0;
              value = parser.finishNode(
                {
                  type: 'AssignmentPattern',
                  left: parser.options.uniqueKeyInPattern
                    ? Object.assign({}, key)
                    : key,
                  right: right,
                },
                tokenStart,
              );
            } else {
              destructible |=
                (token === 209006 ? 128 : 0) | (token === -2147483528 ? 16 : 0);
              value = parser.options.uniqueKeyInPattern
                ? Object.assign({}, key)
                : key;
            }
          } else if (consumeOpt(parser, context | 32, 21)) {
            const { tokenStart: tokenStart } = parser;
            if (tokenValue === '__proto__') prototypeCount++;
            if (parser.getToken() & 143360) {
              const tokenAfterColon = parser.getToken();
              const valueAfterColon = parser.tokenValue;
              value = parsePrimaryExpression(
                parser,
                context,
                privateScope,
                kind,
                0,
                1,
                inGroup,
                1,
                tokenStart,
              );
              const token = parser.getToken();
              value = parseMemberOrUpdateExpression(
                parser,
                context,
                privateScope,
                value,
                inGroup,
                0,
                tokenStart,
              );
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (
                  token === 1077936155 ||
                  token === 1074790415 ||
                  token === 18
                ) {
                  destructible |= parser.destructible & 128 ? 128 : 0;
                  if (parser.assignable & 2) {
                    destructible |= 16;
                  } else if ((tokenAfterColon & 143360) === 143360) {
                    scope?.addVarOrBlock(
                      context,
                      valueAfterColon,
                      kind,
                      origin,
                    );
                  }
                } else {
                  destructible |= parser.assignable & 1 ? 32 : 16;
                }
              } else if ((parser.getToken() & 4194304) === 4194304) {
                if (parser.assignable & 2) {
                  destructible |= 16;
                } else if (token !== 1077936155) {
                  destructible |= 32;
                } else {
                  scope?.addVarOrBlock(context, valueAfterColon, kind, origin);
                }
                value = parseAssignmentExpression(
                  parser,
                  context,
                  privateScope,
                  inGroup,
                  isPattern,
                  tokenStart,
                  value,
                );
              } else {
                destructible |= 16;
                if ((parser.getToken() & 8388608) === 8388608) {
                  value = parseBinaryExpression(
                    parser,
                    context,
                    privateScope,
                    1,
                    tokenStart,
                    4,
                    token,
                    value,
                  );
                }
                if (consumeOpt(parser, context | 32, 22)) {
                  value = parseConditionalExpression(
                    parser,
                    context,
                    privateScope,
                    value,
                    tokenStart,
                  );
                }
              }
            } else if ((parser.getToken() & 2097152) === 2097152) {
              value =
                parser.getToken() === 69271571
                  ? parseArrayExpressionOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    )
                  : parseObjectLiteralOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    );
              destructible = parser.destructible;
              parser.assignable = destructible & 16 ? 2 : 1;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) destructible |= 16;
              } else if (parser.destructible & 8) {
                parser.report(71);
              } else {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 2 ? 16 : 0;
                if ((parser.getToken() & 4194304) === 4194304) {
                  value = parseAssignmentExpressionOrPattern(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                } else {
                  if ((parser.getToken() & 8388608) === 8388608) {
                    value = parseBinaryExpression(
                      parser,
                      context,
                      privateScope,
                      1,
                      tokenStart,
                      4,
                      token,
                      value,
                    );
                  }
                  if (consumeOpt(parser, context | 32, 22)) {
                    value = parseConditionalExpression(
                      parser,
                      context,
                      privateScope,
                      value,
                      tokenStart,
                    );
                  }
                  destructible |= parser.assignable & 2 ? 16 : 32;
                }
              }
            } else {
              value = parseLeftHandSideExpression(
                parser,
                context,
                privateScope,
                1,
                inGroup,
                1,
              );
              destructible |= parser.assignable & 1 ? 32 : 16;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) destructible |= 16;
              } else {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 2 ? 16 : 0;
                if (parser.getToken() !== 18 && token !== 1074790415) {
                  if (parser.getToken() !== 1077936155) destructible |= 16;
                  value = parseAssignmentExpression(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                }
              }
            }
          } else if (parser.getToken() === 69271571) {
            destructible |= 16;
            if (token === 209005) state |= 16;
            state |= (token === 209008 ? 256 : token === 209009 ? 512 : 1) | 2;
            key = parseComputedPropertyName(
              parser,
              context,
              privateScope,
              inGroup,
            );
            destructible |= parser.assignable;
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else if (parser.getToken() & 143360) {
            destructible |= 16;
            if (token === -2147483528) parser.report(95);
            if (token === 209005) {
              if (parser.flags & 1) parser.report(132);
              state |= 16 | 1;
            } else if (token === 209008) {
              state |= 256;
            } else if (token === 209009) {
              state |= 512;
            } else {
              parser.report(0);
            }
            key = parseIdentifier(parser, context);
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else if (parser.getToken() === 67174411) {
            destructible |= 16;
            state |= 1;
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else if (parser.getToken() === 8391476) {
            destructible |= 16;
            if (token === 209008) {
              parser.report(42);
            } else if (token === 209009) {
              parser.report(43);
            } else if (token !== 209005) {
              parser.report(30, KeywordDescTable[8391476 & 255]);
            }
            nextToken(parser, context);
            state |= 8 | 1 | (token === 209005 ? 16 : 0);
            if (parser.getToken() & 143360) {
              key = parseIdentifier(parser, context);
            } else if ((parser.getToken() & 134217728) === 134217728) {
              key = parseLiteral(parser, context);
            } else if (parser.getToken() === 69271571) {
              state |= 2;
              key = parseComputedPropertyName(
                parser,
                context,
                privateScope,
                inGroup,
              );
              destructible |= parser.assignable;
            } else {
              parser.report(30, KeywordDescTable[parser.getToken() & 255]);
            }
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else if ((parser.getToken() & 134217728) === 134217728) {
            if (token === 209005) state |= 16;
            state |= token === 209008 ? 256 : token === 209009 ? 512 : 1;
            destructible |= 16;
            key = parseLiteral(parser, context);
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else {
            parser.report(133);
          }
        } else if ((parser.getToken() & 134217728) === 134217728) {
          key = parseLiteral(parser, context);
          if (parser.getToken() === 21) {
            consume(parser, context | 32, 21);
            const { tokenStart: tokenStart } = parser;
            if (tokenValue === '__proto__') prototypeCount++;
            if (parser.getToken() & 143360) {
              value = parsePrimaryExpression(
                parser,
                context,
                privateScope,
                kind,
                0,
                1,
                inGroup,
                1,
                tokenStart,
              );
              const { tokenValue: valueAfterColon } = parser;
              const token = parser.getToken();
              value = parseMemberOrUpdateExpression(
                parser,
                context,
                privateScope,
                value,
                inGroup,
                0,
                tokenStart,
              );
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (
                  token === 1077936155 ||
                  token === 1074790415 ||
                  token === 18
                ) {
                  if (parser.assignable & 2) {
                    destructible |= 16;
                  } else {
                    scope?.addVarOrBlock(
                      context,
                      valueAfterColon,
                      kind,
                      origin,
                    );
                  }
                } else {
                  destructible |= parser.assignable & 1 ? 32 : 16;
                }
              } else if (parser.getToken() === 1077936155) {
                if (parser.assignable & 2) destructible |= 16;
                value = parseAssignmentExpression(
                  parser,
                  context,
                  privateScope,
                  inGroup,
                  isPattern,
                  tokenStart,
                  value,
                );
              } else {
                destructible |= 16;
                value = parseAssignmentExpression(
                  parser,
                  context,
                  privateScope,
                  inGroup,
                  isPattern,
                  tokenStart,
                  value,
                );
              }
            } else if ((parser.getToken() & 2097152) === 2097152) {
              value =
                parser.getToken() === 69271571
                  ? parseArrayExpressionOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    )
                  : parseObjectLiteralOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    );
              destructible = parser.destructible;
              parser.assignable = destructible & 16 ? 2 : 1;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) {
                  destructible |= 16;
                }
              } else if ((parser.destructible & 8) !== 8) {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 2 ? 16 : 0;
                if ((parser.getToken() & 4194304) === 4194304) {
                  value = parseAssignmentExpressionOrPattern(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                } else {
                  if ((parser.getToken() & 8388608) === 8388608) {
                    value = parseBinaryExpression(
                      parser,
                      context,
                      privateScope,
                      1,
                      tokenStart,
                      4,
                      token,
                      value,
                    );
                  }
                  if (consumeOpt(parser, context | 32, 22)) {
                    value = parseConditionalExpression(
                      parser,
                      context,
                      privateScope,
                      value,
                      tokenStart,
                    );
                  }
                  destructible |= parser.assignable & 2 ? 16 : 32;
                }
              }
            } else {
              value = parseLeftHandSideExpression(
                parser,
                context,
                privateScope,
                1,
                0,
                1,
              );
              destructible |= parser.assignable & 1 ? 32 : 16;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) {
                  destructible |= 16;
                }
              } else {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 1 ? 0 : 16;
                if (
                  parser.getToken() !== 18 &&
                  parser.getToken() !== 1074790415
                ) {
                  if (parser.getToken() !== 1077936155) destructible |= 16;
                  value = parseAssignmentExpression(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                }
              }
            }
          } else if (parser.getToken() === 67174411) {
            state |= 1;
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
            destructible = parser.assignable | 16;
          } else {
            parser.report(134);
          }
        } else if (parser.getToken() === 69271571) {
          key = parseComputedPropertyName(
            parser,
            context,
            privateScope,
            inGroup,
          );
          destructible |= parser.destructible & 256 ? 256 : 0;
          state |= 2;
          if (parser.getToken() === 21) {
            nextToken(parser, context | 32);
            const { tokenStart: tokenStart, tokenValue: tokenValue } = parser;
            const tokenAfterColon = parser.getToken();
            if (parser.getToken() & 143360) {
              value = parsePrimaryExpression(
                parser,
                context,
                privateScope,
                kind,
                0,
                1,
                inGroup,
                1,
                tokenStart,
              );
              const token = parser.getToken();
              value = parseMemberOrUpdateExpression(
                parser,
                context,
                privateScope,
                value,
                inGroup,
                0,
                tokenStart,
              );
              if ((parser.getToken() & 4194304) === 4194304) {
                destructible |=
                  parser.assignable & 2 ? 16 : token === 1077936155 ? 0 : 32;
                value = parseAssignmentExpressionOrPattern(
                  parser,
                  context,
                  privateScope,
                  inGroup,
                  isPattern,
                  tokenStart,
                  value,
                );
              } else if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (
                  token === 1077936155 ||
                  token === 1074790415 ||
                  token === 18
                ) {
                  if (parser.assignable & 2) {
                    destructible |= 16;
                  } else if ((tokenAfterColon & 143360) === 143360) {
                    scope?.addVarOrBlock(context, tokenValue, kind, origin);
                  }
                } else {
                  destructible |= parser.assignable & 1 ? 32 : 16;
                }
              } else {
                destructible |= 16;
                value = parseAssignmentExpression(
                  parser,
                  context,
                  privateScope,
                  inGroup,
                  isPattern,
                  tokenStart,
                  value,
                );
              }
            } else if ((parser.getToken() & 2097152) === 2097152) {
              value =
                parser.getToken() === 69271571
                  ? parseArrayExpressionOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    )
                  : parseObjectLiteralOrPattern(
                      parser,
                      context,
                      scope,
                      privateScope,
                      0,
                      inGroup,
                      isPattern,
                      kind,
                      origin,
                    );
              destructible = parser.destructible;
              parser.assignable = destructible & 16 ? 2 : 1;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) destructible |= 16;
              } else if (destructible & 8) {
                parser.report(62);
              } else {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 2 ? destructible | 16 : 0;
                if ((parser.getToken() & 4194304) === 4194304) {
                  if (parser.getToken() !== 1077936155) destructible |= 16;
                  value = parseAssignmentExpressionOrPattern(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                } else {
                  if ((parser.getToken() & 8388608) === 8388608) {
                    value = parseBinaryExpression(
                      parser,
                      context,
                      privateScope,
                      1,
                      tokenStart,
                      4,
                      token,
                      value,
                    );
                  }
                  if (consumeOpt(parser, context | 32, 22)) {
                    value = parseConditionalExpression(
                      parser,
                      context,
                      privateScope,
                      value,
                      tokenStart,
                    );
                  }
                  destructible |= parser.assignable & 2 ? 16 : 32;
                }
              }
            } else {
              value = parseLeftHandSideExpression(
                parser,
                context,
                privateScope,
                1,
                0,
                1,
              );
              destructible |= parser.assignable & 1 ? 32 : 16;
              if (
                parser.getToken() === 18 ||
                parser.getToken() === 1074790415
              ) {
                if (parser.assignable & 2) destructible |= 16;
              } else {
                value = parseMemberOrUpdateExpression(
                  parser,
                  context,
                  privateScope,
                  value,
                  inGroup,
                  0,
                  tokenStart,
                );
                destructible = parser.assignable & 1 ? 0 : 16;
                if (
                  parser.getToken() !== 18 &&
                  parser.getToken() !== 1074790415
                ) {
                  if (parser.getToken() !== 1077936155) destructible |= 16;
                  value = parseAssignmentExpression(
                    parser,
                    context,
                    privateScope,
                    inGroup,
                    isPattern,
                    tokenStart,
                    value,
                  );
                }
              }
            }
          } else if (parser.getToken() === 67174411) {
            state |= 1;
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
            destructible = 16;
          } else {
            parser.report(44);
          }
        } else if (token === 8391476) {
          consume(parser, context | 32, 8391476);
          state |= 8;
          if (parser.getToken() & 143360) {
            const token = parser.getToken();
            key = parseIdentifier(parser, context);
            state |= 1;
            if (parser.getToken() === 67174411) {
              destructible |= 16;
              value = parseMethodDefinition(
                parser,
                context,
                privateScope,
                state,
                inGroup,
                parser.tokenStart,
              );
            } else {
              throw new ParseError(
                parser.tokenStart,
                parser.currentLocation,
                token === 209005
                  ? 46
                  : token === 209008 || parser.getToken() === 209009
                    ? 45
                    : 47,
                KeywordDescTable[token & 255],
              );
            }
          } else if ((parser.getToken() & 134217728) === 134217728) {
            destructible |= 16;
            key = parseLiteral(parser, context);
            state |= 1;
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else if (parser.getToken() === 69271571) {
            destructible |= 16;
            state |= 2 | 1;
            key = parseComputedPropertyName(
              parser,
              context,
              privateScope,
              inGroup,
            );
            value = parseMethodDefinition(
              parser,
              context,
              privateScope,
              state,
              inGroup,
              parser.tokenStart,
            );
          } else {
            parser.report(126);
          }
        } else {
          parser.report(30, KeywordDescTable[token & 255]);
        }
        destructible |= parser.destructible & 128 ? 128 : 0;
        parser.destructible = destructible;
        properties.push(
          parser.finishNode(
            {
              type: 'Property',
              key: key,
              value: value,
              kind: !(state & 768) ? 'init' : state & 512 ? 'set' : 'get',
              computed: (state & 2) > 0,
              method: (state & 1) > 0,
              shorthand: (state & 4) > 0,
            },
            tokenStart,
          ),
        );
      }
      destructible |= parser.destructible;
      if (parser.getToken() !== 18) break;
      nextToken(parser, context);
    }
    consume(parser, context, 1074790415);
    if (prototypeCount > 1) destructible |= 64;
    const node = parser.finishNode(
      {
        type: isPattern ? 'ObjectPattern' : 'ObjectExpression',
        properties: properties,
      },
      start,
    );
    if (!skipInitializer && parser.getToken() & 4194304) {
      return parseArrayOrObjectAssignmentPattern(
        parser,
        context,
        privateScope,
        destructible,
        inGroup,
        isPattern,
        start,
        node,
      );
    }
    parser.destructible = destructible;
    return node;
  }
  function parseMethodFormals(
    parser,
    context,
    scope,
    privateScope,
    kind,
    type,
    inGroup,
  ) {
    consume(parser, context, 67174411);
    const params = [];
    parser.flags = (parser.flags | 128) ^ 128;
    if (parser.getToken() === 16) {
      if (kind & 512) {
        parser.report(37, 'Setter', 'one', '');
      }
      nextToken(parser, context);
      return params;
    }
    if (kind & 256) {
      parser.report(37, 'Getter', 'no', 's');
    }
    if (kind & 512 && parser.getToken() === 14) {
      parser.report(38);
    }
    context = (context | 131072) ^ 131072;
    let setterArgs = 0;
    let isNonSimpleParameterList = 0;
    while (parser.getToken() !== 18) {
      let left = null;
      const { tokenStart: tokenStart } = parser;
      if (parser.getToken() & 143360) {
        if ((context & 1) === 0) {
          if ((parser.getToken() & 36864) === 36864) {
            parser.flags |= 256;
          }
          if ((parser.getToken() & 537079808) === 537079808) {
            parser.flags |= 512;
          }
        }
        left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0);
      } else {
        if (parser.getToken() === 2162700) {
          left = parseObjectLiteralOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            inGroup,
            1,
            type,
            0,
          );
        } else if (parser.getToken() === 69271571) {
          left = parseArrayExpressionOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            inGroup,
            1,
            type,
            0,
          );
        } else if (parser.getToken() === 14) {
          left = parseSpreadOrRestElement(
            parser,
            context,
            scope,
            privateScope,
            16,
            type,
            0,
            0,
            inGroup,
            1,
          );
        }
        isNonSimpleParameterList = 1;
        if (parser.destructible & (32 | 16)) parser.report(50);
      }
      if (parser.getToken() === 1077936155) {
        nextToken(parser, context | 32);
        isNonSimpleParameterList = 1;
        const right = parseExpression(
          parser,
          context,
          privateScope,
          1,
          0,
          parser.tokenStart,
        );
        left = parser.finishNode(
          { type: 'AssignmentPattern', left: left, right: right },
          tokenStart,
        );
      }
      setterArgs++;
      params.push(left);
      if (!consumeOpt(parser, context, 18)) break;
      if (parser.getToken() === 16) {
        break;
      }
    }
    if (kind & 512 && setterArgs !== 1) {
      parser.report(37, 'Setter', 'one', '');
    }
    scope?.reportScopeError();
    if (isNonSimpleParameterList) parser.flags |= 128;
    consume(parser, context, 16);
    return params;
  }
  function parseComputedPropertyName(parser, context, privateScope, inGroup) {
    nextToken(parser, context | 32);
    const key = parseExpression(
      parser,
      (context | 131072) ^ 131072,
      privateScope,
      1,
      inGroup,
      parser.tokenStart,
    );
    consume(parser, context, 20);
    return key;
  }
  function parseParenthesizedExpression(
    parser,
    context,
    privateScope,
    canAssign,
    kind,
    origin,
    start,
  ) {
    parser.flags = (parser.flags | 128) ^ 128;
    const parenthesesStart = parser.tokenStart;
    nextToken(parser, context | 32 | 262144);
    const scope = parser.createScopeIfLexical()?.createChildScope(512);
    context = (context | 131072) ^ 131072;
    if (consumeOpt(parser, context, 16)) {
      return parseParenthesizedArrow(
        parser,
        context,
        scope,
        privateScope,
        [],
        canAssign,
        0,
        start,
      );
    }
    let destructible = 0;
    parser.destructible &= -385;
    let expr;
    let expressions = [];
    let isSequence = 0;
    let isNonSimpleParameterList = 0;
    let hasStrictReserved = 0;
    const tokenAfterParenthesesStart = parser.tokenStart;
    parser.assignable = 1;
    while (parser.getToken() !== 16) {
      const { tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      if (token & 143360) {
        scope?.addBlockName(context, parser.tokenValue, 1, 0);
        if ((token & 537079808) === 537079808) {
          isNonSimpleParameterList = 1;
        } else if ((token & 36864) === 36864) {
          hasStrictReserved = 1;
        }
        expr = parsePrimaryExpression(
          parser,
          context,
          privateScope,
          kind,
          0,
          1,
          1,
          1,
          tokenStart,
        );
        if (parser.getToken() === 16 || parser.getToken() === 18) {
          if (parser.assignable & 2) {
            destructible |= 16;
            isNonSimpleParameterList = 1;
          }
        } else {
          if (parser.getToken() === 1077936155) {
            isNonSimpleParameterList = 1;
          } else {
            destructible |= 16;
          }
          expr = parseMemberOrUpdateExpression(
            parser,
            context,
            privateScope,
            expr,
            1,
            0,
            tokenStart,
          );
          if (parser.getToken() !== 16 && parser.getToken() !== 18) {
            expr = parseAssignmentExpression(
              parser,
              context,
              privateScope,
              1,
              0,
              tokenStart,
              expr,
            );
          }
        }
      } else if ((token & 2097152) === 2097152) {
        expr =
          token === 2162700
            ? parseObjectLiteralOrPattern(
                parser,
                context | 262144,
                scope,
                privateScope,
                0,
                1,
                0,
                kind,
                origin,
              )
            : parseArrayExpressionOrPattern(
                parser,
                context | 262144,
                scope,
                privateScope,
                0,
                1,
                0,
                kind,
                origin,
              );
        destructible |= parser.destructible;
        isNonSimpleParameterList = 1;
        parser.assignable = 2;
        if (parser.getToken() !== 16 && parser.getToken() !== 18) {
          if (destructible & 8) parser.report(122);
          expr = parseMemberOrUpdateExpression(
            parser,
            context,
            privateScope,
            expr,
            0,
            0,
            tokenStart,
          );
          destructible |= 16;
          if (parser.getToken() !== 16 && parser.getToken() !== 18) {
            expr = parseAssignmentExpression(
              parser,
              context,
              privateScope,
              0,
              0,
              tokenStart,
              expr,
            );
          }
        }
      } else if (token === 14) {
        expr = parseSpreadOrRestElement(
          parser,
          context,
          scope,
          privateScope,
          16,
          kind,
          origin,
          0,
          1,
          0,
        );
        if (parser.destructible & 16) parser.report(74);
        isNonSimpleParameterList = 1;
        if (
          isSequence &&
          (parser.getToken() === 16 || parser.getToken() === 18)
        ) {
          expressions.push(expr);
        }
        destructible |= 8;
        break;
      } else {
        destructible |= 16;
        expr = parseExpression(parser, context, privateScope, 1, 1, tokenStart);
        if (
          isSequence &&
          (parser.getToken() === 16 || parser.getToken() === 18)
        ) {
          expressions.push(expr);
        }
        if (parser.getToken() === 18) {
          if (!isSequence) {
            isSequence = 1;
            expressions = [expr];
          }
        }
        if (isSequence) {
          while (consumeOpt(parser, context | 32, 18)) {
            expressions.push(
              parseExpression(
                parser,
                context,
                privateScope,
                1,
                1,
                parser.tokenStart,
              ),
            );
          }
          parser.assignable = 2;
          expr = parser.finishNode(
            { type: 'SequenceExpression', expressions: expressions },
            tokenAfterParenthesesStart,
          );
        }
        consume(parser, context, 16);
        parser.destructible = destructible;
        return parser.options.preserveParens
          ? parser.finishNode(
              { type: 'ParenthesizedExpression', expression: expr },
              parenthesesStart,
            )
          : expr;
      }
      if (
        isSequence &&
        (parser.getToken() === 16 || parser.getToken() === 18)
      ) {
        expressions.push(expr);
      }
      if (!consumeOpt(parser, context | 32, 18)) break;
      if (!isSequence) {
        isSequence = 1;
        expressions = [expr];
      }
      if (parser.getToken() === 16) {
        destructible |= 8;
        break;
      }
    }
    if (isSequence) {
      parser.assignable = 2;
      expr = parser.finishNode(
        { type: 'SequenceExpression', expressions: expressions },
        tokenAfterParenthesesStart,
      );
    }
    consume(parser, context, 16);
    if (destructible & 16 && destructible & 8) parser.report(151);
    destructible |=
      parser.destructible & 256
        ? 256
        : 0 | (parser.destructible & 128)
          ? 128
          : 0;
    if (parser.getToken() === 10) {
      if (destructible & (32 | 16)) parser.report(49);
      if (context & (2048 | 2) && destructible & 128) parser.report(31);
      if (context & (1 | 1024) && destructible & 256) {
        parser.report(32);
      }
      if (isNonSimpleParameterList) parser.flags |= 128;
      if (hasStrictReserved) parser.flags |= 256;
      return parseParenthesizedArrow(
        parser,
        context,
        scope,
        privateScope,
        isSequence ? expressions : [expr],
        canAssign,
        0,
        start,
      );
    }
    if (destructible & 64) {
      parser.report(63);
    }
    if (destructible & 8) {
      parser.report(144);
    }
    parser.destructible = ((parser.destructible | 256) ^ 256) | destructible;
    return parser.options.preserveParens
      ? parser.finishNode(
          { type: 'ParenthesizedExpression', expression: expr },
          parenthesesStart,
        )
      : expr;
  }
  function parseIdentifierOrArrow(parser, context, privateScope) {
    const { tokenStart: start } = parser;
    const { tokenValue: tokenValue } = parser;
    let isNonSimpleParameterList = 0;
    let hasStrictReserved = 0;
    if ((parser.getToken() & 537079808) === 537079808) {
      isNonSimpleParameterList = 1;
    } else if ((parser.getToken() & 36864) === 36864) {
      hasStrictReserved = 1;
    }
    const expr = parseIdentifier(parser, context);
    parser.assignable = 1;
    if (parser.getToken() === 10) {
      const scope = parser.options.lexical
        ? createArrowHeadParsingScope(parser, context, tokenValue)
        : undefined;
      if (isNonSimpleParameterList) parser.flags |= 128;
      if (hasStrictReserved) parser.flags |= 256;
      return parseArrowFunctionExpression(
        parser,
        context,
        scope,
        privateScope,
        [expr],
        0,
        start,
      );
    }
    return expr;
  }
  function parseArrowFromIdentifier(
    parser,
    context,
    privateScope,
    value,
    expr,
    inNew,
    canAssign,
    isAsync,
    start,
  ) {
    if (!canAssign) parser.report(57);
    if (inNew) parser.report(51);
    parser.flags &= -129;
    const scope = parser.options.lexical
      ? createArrowHeadParsingScope(parser, context, value)
      : void 0;
    return parseArrowFunctionExpression(
      parser,
      context,
      scope,
      privateScope,
      [expr],
      isAsync,
      start,
    );
  }
  function parseParenthesizedArrow(
    parser,
    context,
    scope,
    privateScope,
    params,
    canAssign,
    isAsync,
    start,
  ) {
    if (!canAssign) parser.report(57);
    for (let i = 0; i < params.length; ++i)
      reinterpretToPattern(parser, params[i]);
    return parseArrowFunctionExpression(
      parser,
      context,
      scope,
      privateScope,
      params,
      isAsync,
      start,
    );
  }
  function parseArrowFunctionExpression(
    parser,
    context,
    scope,
    privateScope,
    params,
    isAsync,
    start,
  ) {
    if (parser.flags & 1) parser.report(48);
    consume(parser, context | 32, 10);
    const modifierFlags = 1024 | 2048 | 8192 | 524288;
    context =
      ((context | modifierFlags) ^ modifierFlags) | (isAsync ? 2048 : 0);
    const expression = parser.getToken() !== 2162700;
    let body;
    scope?.reportScopeError();
    if (expression) {
      parser.flags =
        (parser.flags | 512 | 256 | 64 | 4096) ^ (512 | 256 | 64 | 4096);
      body = parseExpression(
        parser,
        context,
        privateScope,
        1,
        0,
        parser.tokenStart,
      );
    } else {
      scope = scope?.createChildScope(64);
      const modifierFlags = 4 | 131072 | 8;
      body = parseFunctionBody(
        parser,
        ((context | modifierFlags) ^ modifierFlags) | 4096,
        scope,
        privateScope,
        16,
        void 0,
        void 0,
      );
      switch (parser.getToken()) {
        case 69271571:
          if ((parser.flags & 1) === 0) {
            parser.report(116);
          }
          break;
        case 67108877:
        case 67174409:
        case 22:
          parser.report(117);
        case 67174411:
          if ((parser.flags & 1) === 0) {
            parser.report(116);
          }
          parser.flags |= 1024;
          break;
      }
      if ((parser.getToken() & 8388608) === 8388608 && (parser.flags & 1) === 0)
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
      if ((parser.getToken() & 33619968) === 33619968) parser.report(125);
    }
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'ArrowFunctionExpression',
        params: params,
        body: body,
        async: isAsync === 1,
        expression: expression,
        generator: false,
      },
      start,
    );
  }
  function parseFormalParametersOrFormalList(
    parser,
    context,
    scope,
    privateScope,
    inGroup,
    kind,
  ) {
    consume(parser, context, 67174411);
    parser.flags = (parser.flags | 128) ^ 128;
    const params = [];
    if (consumeOpt(parser, context, 16)) return params;
    context = (context | 131072) ^ 131072;
    let isNonSimpleParameterList = 0;
    while (parser.getToken() !== 18) {
      let left;
      const { tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      if (token & 143360) {
        if ((context & 1) === 0) {
          if ((token & 36864) === 36864) {
            parser.flags |= 256;
          }
          if ((token & 537079808) === 537079808) {
            parser.flags |= 512;
          }
        }
        left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0);
      } else {
        if (token === 2162700) {
          left = parseObjectLiteralOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            inGroup,
            1,
            kind,
            0,
          );
        } else if (token === 69271571) {
          left = parseArrayExpressionOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            inGroup,
            1,
            kind,
            0,
          );
        } else if (token === 14) {
          left = parseSpreadOrRestElement(
            parser,
            context,
            scope,
            privateScope,
            16,
            kind,
            0,
            0,
            inGroup,
            1,
          );
        } else {
          parser.report(30, KeywordDescTable[token & 255]);
        }
        isNonSimpleParameterList = 1;
        if (parser.destructible & (32 | 16)) {
          parser.report(50);
        }
      }
      if (parser.getToken() === 1077936155) {
        nextToken(parser, context | 32);
        isNonSimpleParameterList = 1;
        const right = parseExpression(
          parser,
          context,
          privateScope,
          1,
          inGroup,
          parser.tokenStart,
        );
        left = parser.finishNode(
          { type: 'AssignmentPattern', left: left, right: right },
          tokenStart,
        );
      }
      params.push(left);
      if (!consumeOpt(parser, context, 18)) break;
      if (parser.getToken() === 16) {
        break;
      }
    }
    if (isNonSimpleParameterList) parser.flags |= 128;
    if (isNonSimpleParameterList || context & 1) {
      scope?.reportScopeError();
    }
    consume(parser, context, 16);
    return params;
  }
  function parseMemberExpressionNoCall(
    parser,
    context,
    privateScope,
    expr,
    inGroup,
    start,
  ) {
    const token = parser.getToken();
    if (token & 67108864) {
      if (token === 67108877) {
        nextToken(parser, context | 262144);
        parser.assignable = 1;
        const property = parsePropertyOrPrivatePropertyName(
          parser,
          context,
          privateScope,
        );
        return parseMemberExpressionNoCall(
          parser,
          context,
          privateScope,
          parser.finishNode(
            {
              type: 'MemberExpression',
              object: expr,
              computed: false,
              property: property,
              optional: false,
            },
            start,
          ),
          0,
          start,
        );
      } else if (token === 69271571) {
        nextToken(parser, context | 32);
        const { tokenStart: tokenStart } = parser;
        const property = parseExpressions(
          parser,
          context,
          privateScope,
          inGroup,
          1,
          tokenStart,
        );
        consume(parser, context, 20);
        parser.assignable = 1;
        return parseMemberExpressionNoCall(
          parser,
          context,
          privateScope,
          parser.finishNode(
            {
              type: 'MemberExpression',
              object: expr,
              computed: true,
              property: property,
              optional: false,
            },
            start,
          ),
          0,
          start,
        );
      } else if (token === 67174408 || token === 67174409) {
        parser.assignable = 2;
        return parseMemberExpressionNoCall(
          parser,
          context,
          privateScope,
          parser.finishNode(
            {
              type: 'TaggedTemplateExpression',
              tag: expr,
              quasi:
                parser.getToken() === 67174408
                  ? parseTemplate(parser, context | 64, privateScope)
                  : parseTemplateLiteral(parser, context | 64),
            },
            start,
          ),
          0,
          start,
        );
      }
    }
    return expr;
  }
  function parseNewExpression(parser, context, privateScope, inGroup) {
    const { tokenStart: start } = parser;
    const id = parseIdentifier(parser, context | 32);
    const { tokenStart: tokenStart } = parser;
    if (consumeOpt(parser, context, 67108877)) {
      if (context & 65536 && parser.getToken() === 209029) {
        parser.assignable = 2;
        return parseMetaProperty(parser, context, id, start);
      }
      parser.report(94);
    }
    parser.assignable = 2;
    if ((parser.getToken() & 16842752) === 16842752) {
      parser.report(65, KeywordDescTable[parser.getToken() & 255]);
    }
    const expr = parsePrimaryExpression(
      parser,
      context,
      privateScope,
      2,
      1,
      0,
      inGroup,
      1,
      tokenStart,
    );
    context = (context | 131072) ^ 131072;
    if (parser.getToken() === 67108990) parser.report(168);
    const callee = parseMemberExpressionNoCall(
      parser,
      context,
      privateScope,
      expr,
      inGroup,
      tokenStart,
    );
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'NewExpression',
        callee: callee,
        arguments:
          parser.getToken() === 67174411
            ? parseArguments(parser, context, privateScope, inGroup)
            : [],
      },
      start,
    );
  }
  function parseMetaProperty(parser, context, meta, start) {
    const property = parseIdentifier(parser, context);
    return parser.finishNode(
      { type: 'MetaProperty', meta: meta, property: property },
      start,
    );
  }
  function parseAsyncArrowAfterIdent(
    parser,
    context,
    privateScope,
    canAssign,
    start,
  ) {
    if (parser.getToken() === 209006) parser.report(31);
    if (context & (1 | 1024) && parser.getToken() === 241771) {
      parser.report(32);
    }
    classifyIdentifier(parser, context, parser.getToken());
    if ((parser.getToken() & 36864) === 36864) {
      parser.flags |= 256;
    }
    return parseArrowFromIdentifier(
      parser,
      (context & -524289) | 2048,
      privateScope,
      parser.tokenValue,
      parseIdentifier(parser, context),
      0,
      canAssign,
      1,
      start,
    );
  }
  function parseAsyncArrowOrCallExpression(
    parser,
    context,
    privateScope,
    callee,
    canAssign,
    kind,
    origin,
    flags,
    start,
  ) {
    nextToken(parser, context | 32);
    const scope = parser.createScopeIfLexical()?.createChildScope(512);
    context = (context | 131072) ^ 131072;
    if (consumeOpt(parser, context, 16)) {
      if (parser.getToken() === 10) {
        if (flags & 1) parser.report(48);
        return parseParenthesizedArrow(
          parser,
          context,
          scope,
          privateScope,
          [],
          canAssign,
          1,
          start,
        );
      }
      return parser.finishNode(
        {
          type: 'CallExpression',
          callee: callee,
          arguments: [],
          optional: false,
        },
        start,
      );
    }
    let destructible = 0;
    let expr = null;
    let isNonSimpleParameterList = 0;
    parser.destructible = (parser.destructible | 256 | 128) ^ (256 | 128);
    const params = [];
    while (parser.getToken() !== 16) {
      const { tokenStart: tokenStart } = parser;
      const token = parser.getToken();
      if (token & 143360) {
        scope?.addBlockName(context, parser.tokenValue, kind, 0);
        if ((token & 537079808) === 537079808) {
          parser.flags |= 512;
        } else if ((token & 36864) === 36864) {
          parser.flags |= 256;
        }
        expr = parsePrimaryExpression(
          parser,
          context,
          privateScope,
          kind,
          0,
          1,
          1,
          1,
          tokenStart,
        );
        if (parser.getToken() === 16 || parser.getToken() === 18) {
          if (parser.assignable & 2) {
            destructible |= 16;
            isNonSimpleParameterList = 1;
          }
        } else {
          if (parser.getToken() === 1077936155) {
            isNonSimpleParameterList = 1;
          } else {
            destructible |= 16;
          }
          expr = parseMemberOrUpdateExpression(
            parser,
            context,
            privateScope,
            expr,
            1,
            0,
            tokenStart,
          );
          if (parser.getToken() !== 16 && parser.getToken() !== 18) {
            expr = parseAssignmentExpression(
              parser,
              context,
              privateScope,
              1,
              0,
              tokenStart,
              expr,
            );
          }
        }
      } else if (token & 2097152) {
        expr =
          token === 2162700
            ? parseObjectLiteralOrPattern(
                parser,
                context,
                scope,
                privateScope,
                0,
                1,
                0,
                kind,
                origin,
              )
            : parseArrayExpressionOrPattern(
                parser,
                context,
                scope,
                privateScope,
                0,
                1,
                0,
                kind,
                origin,
              );
        destructible |= parser.destructible;
        isNonSimpleParameterList = 1;
        if (parser.getToken() !== 16 && parser.getToken() !== 18) {
          if (destructible & 8) parser.report(122);
          expr = parseMemberOrUpdateExpression(
            parser,
            context,
            privateScope,
            expr,
            0,
            0,
            tokenStart,
          );
          destructible |= 16;
          if ((parser.getToken() & 8388608) === 8388608) {
            expr = parseBinaryExpression(
              parser,
              context,
              privateScope,
              1,
              start,
              4,
              token,
              expr,
            );
          }
          if (consumeOpt(parser, context | 32, 22)) {
            expr = parseConditionalExpression(
              parser,
              context,
              privateScope,
              expr,
              start,
            );
          }
        }
      } else if (token === 14) {
        expr = parseSpreadOrRestElement(
          parser,
          context,
          scope,
          privateScope,
          16,
          kind,
          origin,
          1,
          1,
          0,
        );
        destructible |=
          (parser.getToken() === 16 ? 0 : 16) | parser.destructible;
        isNonSimpleParameterList = 1;
      } else {
        expr = parseExpression(parser, context, privateScope, 1, 0, tokenStart);
        destructible = parser.assignable;
        params.push(expr);
        while (consumeOpt(parser, context | 32, 18)) {
          params.push(
            parseExpression(parser, context, privateScope, 1, 0, tokenStart),
          );
        }
        destructible |= parser.assignable;
        consume(parser, context, 16);
        parser.destructible = destructible | 16;
        parser.assignable = 2;
        return parser.finishNode(
          {
            type: 'CallExpression',
            callee: callee,
            arguments: params,
            optional: false,
          },
          start,
        );
      }
      params.push(expr);
      if (!consumeOpt(parser, context | 32, 18)) break;
    }
    consume(parser, context, 16);
    destructible |=
      parser.destructible & 256
        ? 256
        : 0 | (parser.destructible & 128)
          ? 128
          : 0;
    if (parser.getToken() === 10) {
      if (destructible & (32 | 16)) parser.report(27);
      if (parser.flags & 1 || flags & 1) parser.report(48);
      if (destructible & 128) parser.report(31);
      if (context & (1 | 1024) && destructible & 256) parser.report(32);
      if (isNonSimpleParameterList) parser.flags |= 128;
      return parseParenthesizedArrow(
        parser,
        context | 2048,
        scope,
        privateScope,
        params,
        canAssign,
        1,
        start,
      );
    }
    if (destructible & 64) {
      parser.report(63);
    }
    if (destructible & 8) {
      parser.report(62);
    }
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'CallExpression',
        callee: callee,
        arguments: params,
        optional: false,
      },
      start,
    );
  }
  function parseRegExpLiteral(parser, context) {
    const {
      tokenRaw: tokenRaw,
      tokenRegExp: tokenRegExp,
      tokenValue: tokenValue,
      tokenStart: tokenStart,
    } = parser;
    nextToken(parser, context);
    parser.assignable = 2;
    const node = { type: 'Literal', value: tokenValue, regex: tokenRegExp };
    if (parser.options.raw) {
      node.raw = tokenRaw;
    }
    return parser.finishNode(node, tokenStart);
  }
  function parseClassDeclaration(parser, context, scope, privateScope, flags) {
    let start;
    let decorators;
    if (parser.leadingDecorators.decorators.length) {
      if (parser.getToken() === 132) {
        parser.report(30, '@');
      }
      start = parser.leadingDecorators.start;
      decorators = [...parser.leadingDecorators.decorators];
      parser.leadingDecorators.decorators.length = 0;
    } else {
      start = parser.tokenStart;
      decorators = parseDecorators(parser, context, privateScope);
    }
    context = (context | 16384 | 1) ^ 16384;
    nextToken(parser, context);
    let id = null;
    let superClass = null;
    const { tokenValue: tokenValue } = parser;
    if (parser.getToken() & 4096 && parser.getToken() !== 20565) {
      if (isStrictReservedWord(parser, context, parser.getToken())) {
        parser.report(118);
      }
      if ((parser.getToken() & 537079808) === 537079808) {
        parser.report(119);
      }
      if (scope) {
        scope.addBlockName(context, tokenValue, 32, 0);
        if (flags) {
          if (flags & 2) {
            parser.declareUnboundVariable(tokenValue);
          }
        }
      }
      id = parseIdentifier(parser, context);
    } else {
      if ((flags & 1) === 0) parser.report(39, 'Class');
    }
    let inheritedContext = context;
    if (consumeOpt(parser, context | 32, 20565)) {
      superClass = parseLeftHandSideExpression(
        parser,
        context,
        privateScope,
        0,
        0,
        0,
      );
      inheritedContext |= 512;
    } else {
      inheritedContext = (inheritedContext | 512) ^ 512;
    }
    const body = parseClassBody(
      parser,
      inheritedContext,
      context,
      scope,
      privateScope,
      2,
      8,
      0,
    );
    return parser.finishNode(
      {
        type: 'ClassDeclaration',
        id: id,
        superClass: superClass,
        body: body,
        ...(parser.options.next ? { decorators: decorators } : null),
      },
      start,
    );
  }
  function parseClassExpression(parser, context, privateScope, inGroup, start) {
    let id = null;
    let superClass = null;
    const decorators = parseDecorators(parser, context, privateScope);
    context = (context | 1 | 16384) ^ 16384;
    nextToken(parser, context);
    if (parser.getToken() & 4096 && parser.getToken() !== 20565) {
      if (isStrictReservedWord(parser, context, parser.getToken()))
        parser.report(118);
      if ((parser.getToken() & 537079808) === 537079808) {
        parser.report(119);
      }
      id = parseIdentifier(parser, context);
    }
    let inheritedContext = context;
    if (consumeOpt(parser, context | 32, 20565)) {
      superClass = parseLeftHandSideExpression(
        parser,
        context,
        privateScope,
        0,
        inGroup,
        0,
      );
      inheritedContext |= 512;
    } else {
      inheritedContext = (inheritedContext | 512) ^ 512;
    }
    const body = parseClassBody(
      parser,
      inheritedContext,
      context,
      void 0,
      privateScope,
      2,
      0,
      inGroup,
    );
    parser.assignable = 2;
    return parser.finishNode(
      {
        type: 'ClassExpression',
        id: id,
        superClass: superClass,
        body: body,
        ...(parser.options.next ? { decorators: decorators } : null),
      },
      start,
    );
  }
  function parseDecorators(parser, context, privateScope) {
    const list = [];
    if (parser.options.next) {
      while (parser.getToken() === 132) {
        list.push(parseDecoratorList(parser, context, privateScope));
      }
    }
    return list;
  }
  function parseDecoratorList(parser, context, privateScope) {
    const start = parser.tokenStart;
    nextToken(parser, context | 32);
    let expression = parsePrimaryExpression(
      parser,
      context,
      privateScope,
      2,
      0,
      1,
      0,
      1,
      start,
    );
    expression = parseMemberOrUpdateExpression(
      parser,
      context,
      privateScope,
      expression,
      0,
      0,
      parser.tokenStart,
    );
    return parser.finishNode(
      { type: 'Decorator', expression: expression },
      start,
    );
  }
  function parseClassBody(
    parser,
    context,
    inheritedContext,
    scope,
    parentScope,
    kind,
    origin,
    inGroup,
  ) {
    const { tokenStart: tokenStart } = parser;
    const privateScope = parser.createPrivateScopeIfLexical(parentScope);
    consume(parser, context | 32, 2162700);
    const modifierFlags = 131072 | 524288;
    context = (context | modifierFlags) ^ modifierFlags;
    const hasConstr = parser.flags & 32;
    parser.flags = (parser.flags | 32) ^ 32;
    const body = [];
    while (parser.getToken() !== 1074790415) {
      const decoratorStart = parser.tokenStart;
      const decorators = parseDecorators(parser, context, privateScope);
      if (decorators.length > 0 && parser.tokenValue === 'constructor') {
        parser.report(109);
      }
      if (parser.getToken() === 1074790415) parser.report(108);
      if (consumeOpt(parser, context, 1074790417)) {
        if (decorators.length > 0) parser.report(120);
        continue;
      }
      body.push(
        parseClassElementList(
          parser,
          context,
          scope,
          privateScope,
          inheritedContext,
          kind,
          decorators,
          0,
          inGroup,
          decorators.length > 0 ? decoratorStart : parser.tokenStart,
        ),
      );
    }
    consume(parser, origin & 8 ? context | 32 : context, 1074790415);
    privateScope?.validatePrivateIdentifierRefs();
    parser.flags = (parser.flags & -33) | hasConstr;
    return parser.finishNode({ type: 'ClassBody', body: body }, tokenStart);
  }
  function parseClassElementList(
    parser,
    context,
    scope,
    privateScope,
    inheritedContext,
    type,
    decorators,
    isStatic,
    inGroup,
    start,
  ) {
    let kind = isStatic ? 32 : 0;
    let key = null;
    const token = parser.getToken();
    if (token & (143360 | 36864) || token === -2147483528) {
      key = parseIdentifier(parser, context);
      switch (token) {
        case 36970:
          if (
            !isStatic &&
            parser.getToken() !== 67174411 &&
            (parser.getToken() & 1048576) !== 1048576 &&
            parser.getToken() !== 1077936155
          ) {
            return parseClassElementList(
              parser,
              context,
              scope,
              privateScope,
              inheritedContext,
              type,
              decorators,
              1,
              inGroup,
              start,
            );
          }
          break;
        case 209005:
          if (parser.getToken() !== 67174411 && (parser.flags & 1) === 0) {
            if ((parser.getToken() & 1073741824) === 1073741824) {
              return parsePropertyDefinition(
                parser,
                context,
                privateScope,
                key,
                kind,
                decorators,
                start,
              );
            }
            kind |= 16 | (optionalBit(parser, context, 8391476) ? 8 : 0);
          }
          break;
        case 209008:
          if (parser.getToken() !== 67174411) {
            if ((parser.getToken() & 1073741824) === 1073741824) {
              return parsePropertyDefinition(
                parser,
                context,
                privateScope,
                key,
                kind,
                decorators,
                start,
              );
            }
            kind |= 256;
          }
          break;
        case 209009:
          if (parser.getToken() !== 67174411) {
            if ((parser.getToken() & 1073741824) === 1073741824) {
              return parsePropertyDefinition(
                parser,
                context,
                privateScope,
                key,
                kind,
                decorators,
                start,
              );
            }
            kind |= 512;
          }
          break;
        case 12402:
          if (parser.getToken() !== 67174411 && (parser.flags & 1) === 0) {
            if ((parser.getToken() & 1073741824) === 1073741824) {
              return parsePropertyDefinition(
                parser,
                context,
                privateScope,
                key,
                kind,
                decorators,
                start,
              );
            }
            if (parser.options.next) kind |= 1024;
          }
          break;
      }
    } else if (token === 69271571) {
      kind |= 2;
      key = parseComputedPropertyName(
        parser,
        inheritedContext,
        privateScope,
        inGroup,
      );
    } else if ((token & 134217728) === 134217728) {
      key = parseLiteral(parser, context);
    } else if (token === 8391476) {
      kind |= 8;
      nextToken(parser, context);
    } else if (parser.getToken() === 130) {
      kind |= 8192;
      key = parsePrivateIdentifier(parser, context | 16, privateScope, 768);
    } else if ((parser.getToken() & 1073741824) === 1073741824) {
      kind |= 128;
    } else if (isStatic && token === 2162700) {
      return parseStaticBlock(parser, context | 16, scope, privateScope, start);
    } else if (token === -2147483527) {
      key = parseIdentifier(parser, context);
      if (parser.getToken() !== 67174411)
        parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    } else {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
    if (kind & (8 | 16 | 768 | 1024)) {
      if (
        parser.getToken() & 143360 ||
        parser.getToken() === -2147483528 ||
        parser.getToken() === -2147483527
      ) {
        key = parseIdentifier(parser, context);
      } else if ((parser.getToken() & 134217728) === 134217728) {
        key = parseLiteral(parser, context);
      } else if (parser.getToken() === 69271571) {
        kind |= 2;
        key = parseComputedPropertyName(parser, context, privateScope, 0);
      } else if (parser.getToken() === 130) {
        kind |= 8192;
        key = parsePrivateIdentifier(parser, context, privateScope, kind);
      } else parser.report(135);
    }
    if ((kind & 2) === 0) {
      if (parser.tokenValue === 'constructor') {
        if ((parser.getToken() & 1073741824) === 1073741824) {
          parser.report(129);
        } else if ((kind & 32) === 0 && parser.getToken() === 67174411) {
          if (kind & (768 | 16 | 128 | 8)) {
            parser.report(53, 'accessor');
          } else if ((context & 512) === 0) {
            if (parser.flags & 32) parser.report(54);
            else parser.flags |= 32;
          }
        }
        kind |= 64;
      } else if (
        (kind & 8192) === 0 &&
        kind & 32 &&
        parser.tokenValue === 'prototype'
      ) {
        parser.report(52);
      }
    }
    if (kind & 1024 || (parser.getToken() !== 67174411 && (kind & 768) === 0)) {
      return parsePropertyDefinition(
        parser,
        context,
        privateScope,
        key,
        kind,
        decorators,
        start,
      );
    }
    const value = parseMethodDefinition(
      parser,
      context | 16,
      privateScope,
      kind,
      inGroup,
      parser.tokenStart,
    );
    return parser.finishNode(
      {
        type: 'MethodDefinition',
        kind:
          (kind & 32) === 0 && kind & 64
            ? 'constructor'
            : kind & 256
              ? 'get'
              : kind & 512
                ? 'set'
                : 'method',
        static: (kind & 32) > 0,
        computed: (kind & 2) > 0,
        key: key,
        value: value,
        ...(parser.options.next ? { decorators: decorators } : null),
      },
      start,
    );
  }
  function parsePrivateIdentifier(parser, context, privateScope, kind) {
    const { tokenStart: tokenStart } = parser;
    nextToken(parser, context);
    const { tokenValue: tokenValue } = parser;
    if (tokenValue === 'constructor') parser.report(128);
    if (parser.options.lexical) {
      if (!privateScope) parser.report(4, tokenValue);
      if (kind) {
        privateScope.addPrivateIdentifier(tokenValue, kind);
      } else {
        privateScope.addPrivateIdentifierRef(tokenValue);
      }
    }
    nextToken(parser, context);
    return parser.finishNode(
      { type: 'PrivateIdentifier', name: tokenValue },
      tokenStart,
    );
  }
  function parsePropertyDefinition(
    parser,
    context,
    privateScope,
    key,
    state,
    decorators,
    start,
  ) {
    let value = null;
    if (state & 8) parser.report(0);
    if (parser.getToken() === 1077936155) {
      nextToken(parser, context | 32);
      const { tokenStart: tokenStart } = parser;
      if (parser.getToken() === 537079927) parser.report(119);
      const modifierFlags =
        1024 | 2048 | 8192 | ((state & 64) === 0 ? 512 | 16384 : 0);
      context =
        ((context | modifierFlags) ^ modifierFlags) |
        (state & 8 ? 1024 : 0) |
        (state & 16 ? 2048 : 0) |
        (state & 64 ? 16384 : 0) |
        256 |
        65536;
      value = parsePrimaryExpression(
        parser,
        context | 16,
        privateScope,
        2,
        0,
        1,
        0,
        1,
        tokenStart,
      );
      if (
        (parser.getToken() & 1073741824) !== 1073741824 ||
        (parser.getToken() & 4194304) === 4194304
      ) {
        value = parseMemberOrUpdateExpression(
          parser,
          context | 16,
          privateScope,
          value,
          0,
          0,
          tokenStart,
        );
        value = parseAssignmentExpression(
          parser,
          context | 16,
          privateScope,
          0,
          0,
          tokenStart,
          value,
        );
      }
    }
    matchOrInsertSemicolon(parser, context);
    return parser.finishNode(
      {
        type: state & 1024 ? 'AccessorProperty' : 'PropertyDefinition',
        key: key,
        value: value,
        static: (state & 32) > 0,
        computed: (state & 2) > 0,
        ...(parser.options.next ? { decorators: decorators } : null),
      },
      start,
    );
  }
  function parseBindingPattern(
    parser,
    context,
    scope,
    privateScope,
    type,
    origin,
  ) {
    if (
      parser.getToken() & 143360 ||
      ((context & 1) === 0 && parser.getToken() === -2147483527)
    )
      return parseAndClassifyIdentifier(parser, context, scope, type, origin);
    if ((parser.getToken() & 2097152) !== 2097152)
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    const left =
      parser.getToken() === 69271571
        ? parseArrayExpressionOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            0,
            1,
            type,
            origin,
          )
        : parseObjectLiteralOrPattern(
            parser,
            context,
            scope,
            privateScope,
            1,
            0,
            1,
            type,
            origin,
          );
    if (parser.destructible & 16) parser.report(50);
    if (parser.destructible & 32) parser.report(50);
    return left;
  }
  function parseAndClassifyIdentifier(parser, context, scope, kind, origin) {
    const token = parser.getToken();
    if (context & 1) {
      if ((token & 537079808) === 537079808) {
        parser.report(119);
      } else if ((token & 36864) === 36864 || token === -2147483527) {
        parser.report(118);
      }
    }
    if ((token & 20480) === 20480) {
      parser.report(102);
    }
    if (token === 241771) {
      if (context & 1024) parser.report(32);
      if (context & 2) parser.report(111);
    }
    if ((token & 255) === (241737 & 255)) {
      if (kind & (8 | 16)) parser.report(100);
    }
    if (token === 209006) {
      if (context & 2048) parser.report(176);
      if (context & 2) parser.report(110);
    }
    const { tokenValue: tokenValue, tokenStart: start } = parser;
    nextToken(parser, context);
    scope?.addVarOrBlock(context, tokenValue, kind, origin);
    return parser.finishNode({ type: 'Identifier', name: tokenValue }, start);
  }
  function parseJSXRootElementOrFragment(
    parser,
    context,
    privateScope,
    inJSXChild,
    start,
  ) {
    if (!inJSXChild) consume(parser, context, 8456256);
    if (parser.getToken() === 8390721) {
      const openingFragment = parseJSXOpeningFragment(parser, start);
      const [children, closingFragment] = parseJSXChildrenAndClosingFragment(
        parser,
        context,
        privateScope,
        inJSXChild,
      );
      return parser.finishNode(
        {
          type: 'JSXFragment',
          openingFragment: openingFragment,
          children: children,
          closingFragment: closingFragment,
        },
        start,
      );
    }
    if (parser.getToken() === 8457014)
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    let closingElement = null;
    let children = [];
    const openingElement = parseJSXOpeningElementOrSelfCloseElement(
      parser,
      context,
      privateScope,
      inJSXChild,
      start,
    );
    if (!openingElement.selfClosing) {
      [children, closingElement] = parseJSXChildrenAndClosingElement(
        parser,
        context,
        privateScope,
        inJSXChild,
      );
      const close = isEqualTagName(closingElement.name);
      if (isEqualTagName(openingElement.name) !== close)
        parser.report(155, close);
    }
    return parser.finishNode(
      {
        type: 'JSXElement',
        children: children,
        openingElement: openingElement,
        closingElement: closingElement,
      },
      start,
    );
  }
  function parseJSXOpeningFragment(parser, start) {
    nextJSXToken(parser);
    return parser.finishNode({ type: 'JSXOpeningFragment' }, start);
  }
  function parseJSXClosingElement(parser, context, inJSXChild, start) {
    consume(parser, context, 8457014);
    const name = parseJSXElementName(parser, context);
    if (parser.getToken() !== 8390721) {
      parser.report(25, KeywordDescTable[8390721 & 255]);
    }
    if (inJSXChild) {
      nextJSXToken(parser);
    } else {
      nextToken(parser, context);
    }
    return parser.finishNode({ type: 'JSXClosingElement', name: name }, start);
  }
  function parseJSXClosingFragment(parser, context, inJSXChild, start) {
    consume(parser, context, 8457014);
    if (parser.getToken() !== 8390721) {
      parser.report(25, KeywordDescTable[8390721 & 255]);
    }
    if (inJSXChild) {
      nextJSXToken(parser);
    } else {
      nextToken(parser, context);
    }
    return parser.finishNode({ type: 'JSXClosingFragment' }, start);
  }
  function parseJSXChildrenAndClosingElement(
    parser,
    context,
    privateScope,
    inJSXChild,
  ) {
    const children = [];
    while (true) {
      const child = parseJSXChildOrClosingElement(
        parser,
        context,
        privateScope,
        inJSXChild,
      );
      if (child.type === 'JSXClosingElement') {
        return [children, child];
      }
      children.push(child);
    }
  }
  function parseJSXChildrenAndClosingFragment(
    parser,
    context,
    privateScope,
    inJSXChild,
  ) {
    const children = [];
    while (true) {
      const child = parseJSXChildOrClosingFragment(
        parser,
        context,
        privateScope,
        inJSXChild,
      );
      if (child.type === 'JSXClosingFragment') {
        return [children, child];
      }
      children.push(child);
    }
  }
  function parseJSXChildOrClosingElement(
    parser,
    context,
    privateScope,
    inJSXChild,
  ) {
    if (parser.getToken() === 137) return parseJSXText(parser, context);
    if (parser.getToken() === 2162700)
      return parseJSXExpressionContainer(parser, context, privateScope, 1, 0);
    if (parser.getToken() === 8456256) {
      const { tokenStart: tokenStart } = parser;
      nextToken(parser, context);
      if (parser.getToken() === 8457014)
        return parseJSXClosingElement(parser, context, inJSXChild, tokenStart);
      return parseJSXRootElementOrFragment(
        parser,
        context,
        privateScope,
        1,
        tokenStart,
      );
    }
    parser.report(0);
  }
  function parseJSXChildOrClosingFragment(
    parser,
    context,
    privateScope,
    inJSXChild,
  ) {
    if (parser.getToken() === 137) return parseJSXText(parser, context);
    if (parser.getToken() === 2162700)
      return parseJSXExpressionContainer(parser, context, privateScope, 1, 0);
    if (parser.getToken() === 8456256) {
      const { tokenStart: tokenStart } = parser;
      nextToken(parser, context);
      if (parser.getToken() === 8457014)
        return parseJSXClosingFragment(parser, context, inJSXChild, tokenStart);
      return parseJSXRootElementOrFragment(
        parser,
        context,
        privateScope,
        1,
        tokenStart,
      );
    }
    parser.report(0);
  }
  function parseJSXText(parser, context) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    const node = { type: 'JSXText', value: parser.tokenValue };
    if (parser.options.raw) {
      node.raw = parser.tokenRaw;
    }
    return parser.finishNode(node, start);
  }
  function parseJSXOpeningElementOrSelfCloseElement(
    parser,
    context,
    privateScope,
    inJSXChild,
    start,
  ) {
    if (
      (parser.getToken() & 143360) !== 143360 &&
      (parser.getToken() & 4096) !== 4096
    )
      parser.report(0);
    const tagName = parseJSXElementName(parser, context);
    const attributes = parseJSXAttributes(parser, context, privateScope);
    const selfClosing = parser.getToken() === 8457014;
    if (selfClosing) consume(parser, context, 8457014);
    if (parser.getToken() !== 8390721) {
      parser.report(25, KeywordDescTable[8390721 & 255]);
    }
    if (inJSXChild || !selfClosing) {
      nextJSXToken(parser);
    } else {
      nextToken(parser, context);
    }
    return parser.finishNode(
      {
        type: 'JSXOpeningElement',
        name: tagName,
        attributes: attributes,
        selfClosing: selfClosing,
      },
      start,
    );
  }
  function parseJSXElementName(parser, context) {
    const { tokenStart: tokenStart } = parser;
    rescanJSXIdentifier(parser);
    let key = parseJSXIdentifier(parser, context);
    if (parser.getToken() === 21)
      return parseJSXNamespacedName(parser, context, key, tokenStart);
    while (consumeOpt(parser, context, 67108877)) {
      rescanJSXIdentifier(parser);
      key = parseJSXMemberExpression(parser, context, key, tokenStart);
    }
    return key;
  }
  function parseJSXMemberExpression(parser, context, object, start) {
    const property = parseJSXIdentifier(parser, context);
    return parser.finishNode(
      { type: 'JSXMemberExpression', object: object, property: property },
      start,
    );
  }
  function parseJSXAttributes(parser, context, privateScope) {
    const attributes = [];
    while (
      parser.getToken() !== 8457014 &&
      parser.getToken() !== 8390721 &&
      parser.getToken() !== 1048576
    ) {
      attributes.push(parseJsxAttribute(parser, context, privateScope));
    }
    return attributes;
  }
  function parseJSXSpreadAttribute(parser, context, privateScope) {
    const start = parser.tokenStart;
    nextToken(parser, context);
    consume(parser, context, 14);
    const expression = parseExpression(
      parser,
      context,
      privateScope,
      1,
      0,
      parser.tokenStart,
    );
    consume(parser, context, 1074790415);
    return parser.finishNode(
      { type: 'JSXSpreadAttribute', argument: expression },
      start,
    );
  }
  function parseJsxAttribute(parser, context, privateScope) {
    const { tokenStart: tokenStart } = parser;
    if (parser.getToken() === 2162700)
      return parseJSXSpreadAttribute(parser, context, privateScope);
    rescanJSXIdentifier(parser);
    let value = null;
    let name = parseJSXIdentifier(parser, context);
    if (parser.getToken() === 21) {
      name = parseJSXNamespacedName(parser, context, name, tokenStart);
    }
    if (parser.getToken() === 1077936155) {
      const token = scanJSXAttributeValue(parser, context);
      switch (token) {
        case 134283267:
          value = parseLiteral(parser, context);
          break;
        case 8456256:
          value = parseJSXRootElementOrFragment(
            parser,
            context,
            privateScope,
            0,
            parser.tokenStart,
          );
          break;
        case 2162700:
          value = parseJSXExpressionContainer(
            parser,
            context,
            privateScope,
            0,
            1,
          );
          break;
        default:
          parser.report(154);
      }
    }
    return parser.finishNode(
      { type: 'JSXAttribute', value: value, name: name },
      tokenStart,
    );
  }
  function parseJSXNamespacedName(parser, context, namespace, start) {
    consume(parser, context, 21);
    const name = parseJSXIdentifier(parser, context);
    return parser.finishNode(
      { type: 'JSXNamespacedName', namespace: namespace, name: name },
      start,
    );
  }
  function parseJSXExpressionContainer(
    parser,
    context,
    privateScope,
    inJSXChild,
    isAttr,
  ) {
    const { tokenStart: start } = parser;
    nextToken(parser, context | 32);
    const { tokenStart: tokenStart } = parser;
    if (parser.getToken() === 14)
      return parseJSXSpreadChild(parser, context, privateScope, start);
    let expression = null;
    if (parser.getToken() === 1074790415) {
      if (isAttr) parser.report(157);
      expression = parseJSXEmptyExpression(parser, {
        index: parser.startIndex,
        line: parser.startLine,
        column: parser.startColumn,
      });
    } else {
      expression = parseExpression(
        parser,
        context,
        privateScope,
        1,
        0,
        tokenStart,
      );
    }
    if (parser.getToken() !== 1074790415) {
      parser.report(25, KeywordDescTable[1074790415 & 255]);
    }
    if (inJSXChild) {
      nextJSXToken(parser);
    } else {
      nextToken(parser, context);
    }
    return parser.finishNode(
      { type: 'JSXExpressionContainer', expression: expression },
      start,
    );
  }
  function parseJSXSpreadChild(parser, context, privateScope, start) {
    consume(parser, context, 14);
    const expression = parseExpression(
      parser,
      context,
      privateScope,
      1,
      0,
      parser.tokenStart,
    );
    consume(parser, context, 1074790415);
    return parser.finishNode(
      { type: 'JSXSpreadChild', expression: expression },
      start,
    );
  }
  function parseJSXEmptyExpression(parser, start) {
    return parser.finishNode(
      { type: 'JSXEmptyExpression' },
      start,
      parser.tokenStart,
    );
  }
  function parseJSXIdentifier(parser, context) {
    const start = parser.tokenStart;
    if (!(parser.getToken() & 143360)) {
      parser.report(30, KeywordDescTable[parser.getToken() & 255]);
    }
    const { tokenValue: tokenValue } = parser;
    nextToken(parser, context);
    return parser.finishNode(
      { type: 'JSXIdentifier', name: tokenValue },
      start,
    );
  }
  function parse(source, options) {
    return parseSource(source, options);
  }
  const { stringify: stringify } = JSON;
  if (!String.prototype.repeat) {
    throw new Error(
      'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',
    );
  }
  if (!String.prototype.endsWith) {
    throw new Error(
      'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',
    );
  }
  const OPERATOR_PRECEDENCE = {
    '||': 2,
    '??': 3,
    '&&': 4,
    '|': 5,
    '^': 6,
    '&': 7,
    '==': 8,
    '!=': 8,
    '===': 8,
    '!==': 8,
    '<': 9,
    '>': 9,
    '<=': 9,
    '>=': 9,
    in: 9,
    instanceof: 9,
    '<<': 10,
    '>>': 10,
    '>>>': 10,
    '+': 11,
    '-': 11,
    '*': 12,
    '%': 12,
    '/': 12,
    '**': 13,
  };
  const NEEDS_PARENTHESES = 17;
  const EXPRESSIONS_PRECEDENCE = {
    ArrayExpression: 20,
    TaggedTemplateExpression: 20,
    ThisExpression: 20,
    Identifier: 20,
    PrivateIdentifier: 20,
    Literal: 18,
    TemplateLiteral: 20,
    Super: 20,
    SequenceExpression: 20,
    MemberExpression: 19,
    ChainExpression: 19,
    CallExpression: 19,
    NewExpression: 19,
    ArrowFunctionExpression: NEEDS_PARENTHESES,
    ClassExpression: NEEDS_PARENTHESES,
    FunctionExpression: NEEDS_PARENTHESES,
    ObjectExpression: NEEDS_PARENTHESES,
    UpdateExpression: 16,
    UnaryExpression: 15,
    AwaitExpression: 15,
    BinaryExpression: 14,
    LogicalExpression: 13,
    ConditionalExpression: 4,
    AssignmentExpression: 3,
    YieldExpression: 2,
    RestElement: 1,
  };
  function formatSequence(state, nodes) {
    const { generator: generator } = state;
    state.write('(');
    if (nodes != null && nodes.length > 0) {
      generator[nodes[0].type](nodes[0], state);
      const { length: length } = nodes;
      for (let i = 1; i < length; i++) {
        const param = nodes[i];
        state.write(', ');
        generator[param.type](param, state);
      }
    }
    state.write(')');
  }
  function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
    const nodePrecedence = state.expressionsPrecedence[node.type];
    if (nodePrecedence === NEEDS_PARENTHESES) {
      return true;
    }
    const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
    if (nodePrecedence !== parentNodePrecedence) {
      return (
        (!isRightHand &&
          nodePrecedence === 15 &&
          parentNodePrecedence === 14 &&
          parentNode.operator === '**') ||
        nodePrecedence < parentNodePrecedence
      );
    }
    if (nodePrecedence !== 13 && nodePrecedence !== 14) {
      return false;
    }
    if (node.operator === '**' && parentNode.operator === '**') {
      return !isRightHand;
    }
    if (
      nodePrecedence === 13 &&
      parentNodePrecedence === 13 &&
      (node.operator === '??' || parentNode.operator === '??')
    ) {
      return true;
    }
    if (isRightHand) {
      return (
        OPERATOR_PRECEDENCE[node.operator] <=
        OPERATOR_PRECEDENCE[parentNode.operator]
      );
    }
    return (
      OPERATOR_PRECEDENCE[node.operator] <
      OPERATOR_PRECEDENCE[parentNode.operator]
    );
  }
  function formatExpression(state, node, parentNode, isRightHand) {
    const { generator: generator } = state;
    if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
      state.write('(');
      generator[node.type](node, state);
      state.write(')');
    } else {
      generator[node.type](node, state);
    }
  }
  function reindent(state, text, indent, lineEnd) {
    const lines = text.split('\n');
    const end = lines.length - 1;
    state.write(lines[0].trim());
    if (end > 0) {
      state.write(lineEnd);
      for (let i = 1; i < end; i++) {
        state.write(indent + lines[i].trim() + lineEnd);
      }
      state.write(indent + lines[end].trim());
    }
  }
  function formatComments(state, comments, indent, lineEnd) {
    const { length: length } = comments;
    for (let i = 0; i < length; i++) {
      const comment = comments[i];
      state.write(indent);
      if (comment.type[0] === 'L') {
        state.write('// ' + comment.value.trim() + '\n', comment);
      } else {
        state.write('/*');
        reindent(state, comment.value, indent, lineEnd);
        state.write('*/' + lineEnd);
      }
    }
  }
  function hasCallExpression(node) {
    let currentNode = node;
    while (currentNode != null) {
      const { type: type } = currentNode;
      if (type[0] === 'C' && type[1] === 'a') {
        return true;
      } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {
        currentNode = currentNode.object;
      } else {
        return false;
      }
    }
  }
  function formatVariableDeclaration(state, node) {
    const { generator: generator } = state;
    const { declarations: declarations } = node;
    state.write(node.kind + ' ');
    const { length: length } = declarations;
    if (length > 0) {
      generator.VariableDeclarator(declarations[0], state);
      for (let i = 1; i < length; i++) {
        state.write(', ');
        generator.VariableDeclarator(declarations[i], state);
      }
    }
  }
  let ForInStatement,
    FunctionDeclaration,
    RestElement,
    BinaryExpression,
    ArrayExpression,
    BlockStatement;
  const GENERATOR = {
    Program(node, state) {
      const indent = state.indent.repeat(state.indentLevel);
      const { lineEnd: lineEnd, writeComments: writeComments } = state;
      if (writeComments && node.comments != null) {
        formatComments(state, node.comments, indent, lineEnd);
      }
      const statements = node.body;
      const { length: length } = statements;
      for (let i = 0; i < length; i++) {
        const statement = statements[i];
        if (writeComments && statement.comments != null) {
          formatComments(state, statement.comments, indent, lineEnd);
        }
        state.write(indent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }
      if (writeComments && node.trailingComments != null) {
        formatComments(state, node.trailingComments, indent, lineEnd);
      }
    },
    BlockStatement: (BlockStatement = function (node, state) {
      const indent = state.indent.repeat(state.indentLevel++);
      const { lineEnd: lineEnd, writeComments: writeComments } = state;
      const statementIndent = indent + state.indent;
      state.write('{');
      const statements = node.body;
      if (statements != null && statements.length > 0) {
        state.write(lineEnd);
        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, statementIndent, lineEnd);
        }
        const { length: length } = statements;
        for (let i = 0; i < length; i++) {
          const statement = statements[i];
          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, statementIndent, lineEnd);
          }
          state.write(statementIndent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
        state.write(indent);
      } else {
        if (writeComments && node.comments != null) {
          state.write(lineEnd);
          formatComments(state, node.comments, statementIndent, lineEnd);
          state.write(indent);
        }
      }
      if (writeComments && node.trailingComments != null) {
        formatComments(state, node.trailingComments, statementIndent, lineEnd);
      }
      state.write('}');
      state.indentLevel--;
    }),
    ClassBody: BlockStatement,
    StaticBlock(node, state) {
      state.write('static ');
      this.BlockStatement(node, state);
    },
    EmptyStatement(node, state) {
      state.write(';');
    },
    ExpressionStatement(node, state) {
      const precedence = state.expressionsPrecedence[node.expression.type];
      if (
        precedence === NEEDS_PARENTHESES ||
        (precedence === 3 && node.expression.left.type[0] === 'O')
      ) {
        state.write('(');
        this[node.expression.type](node.expression, state);
        state.write(')');
      } else {
        this[node.expression.type](node.expression, state);
      }
      state.write(';');
    },
    IfStatement(node, state) {
      state.write('if (');
      this[node.test.type](node.test, state);
      state.write(') ');
      this[node.consequent.type](node.consequent, state);
      if (node.alternate != null) {
        state.write(' else ');
        this[node.alternate.type](node.alternate, state);
      }
    },
    LabeledStatement(node, state) {
      this[node.label.type](node.label, state);
      state.write(': ');
      this[node.body.type](node.body, state);
    },
    BreakStatement(node, state) {
      state.write('break');
      if (node.label != null) {
        state.write(' ');
        this[node.label.type](node.label, state);
      }
      state.write(';');
    },
    ContinueStatement(node, state) {
      state.write('continue');
      if (node.label != null) {
        state.write(' ');
        this[node.label.type](node.label, state);
      }
      state.write(';');
    },
    WithStatement(node, state) {
      state.write('with (');
      this[node.object.type](node.object, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    SwitchStatement(node, state) {
      const indent = state.indent.repeat(state.indentLevel++);
      const { lineEnd: lineEnd, writeComments: writeComments } = state;
      state.indentLevel++;
      const caseIndent = indent + state.indent;
      const statementIndent = caseIndent + state.indent;
      state.write('switch (');
      this[node.discriminant.type](node.discriminant, state);
      state.write(') {' + lineEnd);
      const { cases: occurences } = node;
      const { length: occurencesCount } = occurences;
      for (let i = 0; i < occurencesCount; i++) {
        const occurence = occurences[i];
        if (writeComments && occurence.comments != null) {
          formatComments(state, occurence.comments, caseIndent, lineEnd);
        }
        if (occurence.test) {
          state.write(caseIndent + 'case ');
          this[occurence.test.type](occurence.test, state);
          state.write(':' + lineEnd);
        } else {
          state.write(caseIndent + 'default:' + lineEnd);
        }
        const { consequent: consequent } = occurence;
        const { length: consequentCount } = consequent;
        for (let i = 0; i < consequentCount; i++) {
          const statement = consequent[i];
          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, statementIndent, lineEnd);
          }
          state.write(statementIndent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
      }
      state.indentLevel -= 2;
      state.write(indent + '}');
    },
    ReturnStatement(node, state) {
      state.write('return');
      if (node.argument) {
        state.write(' ');
        this[node.argument.type](node.argument, state);
      }
      state.write(';');
    },
    ThrowStatement(node, state) {
      state.write('throw ');
      this[node.argument.type](node.argument, state);
      state.write(';');
    },
    TryStatement(node, state) {
      state.write('try ');
      this[node.block.type](node.block, state);
      if (node.handler) {
        const { handler: handler } = node;
        if (handler.param == null) {
          state.write(' catch ');
        } else {
          state.write(' catch (');
          this[handler.param.type](handler.param, state);
          state.write(') ');
        }
        this[handler.body.type](handler.body, state);
      }
      if (node.finalizer) {
        state.write(' finally ');
        this[node.finalizer.type](node.finalizer, state);
      }
    },
    WhileStatement(node, state) {
      state.write('while (');
      this[node.test.type](node.test, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    DoWhileStatement(node, state) {
      state.write('do ');
      this[node.body.type](node.body, state);
      state.write(' while (');
      this[node.test.type](node.test, state);
      state.write(');');
    },
    ForStatement(node, state) {
      state.write('for (');
      if (node.init != null) {
        const { init: init } = node;
        if (init.type[0] === 'V') {
          formatVariableDeclaration(state, init);
        } else {
          this[init.type](init, state);
        }
      }
      state.write('; ');
      if (node.test) {
        this[node.test.type](node.test, state);
      }
      state.write('; ');
      if (node.update) {
        this[node.update.type](node.update, state);
      }
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    ForInStatement: (ForInStatement = function (node, state) {
      state.write(`for ${node.await ? 'await ' : ''}(`);
      const { left: left } = node;
      if (left.type[0] === 'V') {
        formatVariableDeclaration(state, left);
      } else {
        this[left.type](left, state);
      }
      state.write(node.type[3] === 'I' ? ' in ' : ' of ');
      this[node.right.type](node.right, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    }),
    ForOfStatement: ForInStatement,
    DebuggerStatement(node, state) {
      state.write('debugger;', node);
    },
    FunctionDeclaration: (FunctionDeclaration = function (node, state) {
      state.write(
        (node.async ? 'async ' : '') +
          (node.generator ? 'function* ' : 'function ') +
          (node.id ? node.id.name : ''),
        node,
      );
      formatSequence(state, node.params);
      state.write(' ');
      this[node.body.type](node.body, state);
    }),
    FunctionExpression: FunctionDeclaration,
    VariableDeclaration(node, state) {
      formatVariableDeclaration(state, node);
      state.write(';');
    },
    VariableDeclarator(node, state) {
      this[node.id.type](node.id, state);
      if (node.init != null) {
        state.write(' = ');
        this[node.init.type](node.init, state);
      }
    },
    ClassDeclaration(node, state) {
      state.write('class ' + (node.id ? `${node.id.name} ` : ''), node);
      if (node.superClass) {
        state.write('extends ');
        const { superClass: superClass } = node;
        const { type: type } = superClass;
        const precedence = state.expressionsPrecedence[type];
        if (
          (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&
          (precedence === NEEDS_PARENTHESES ||
            precedence < state.expressionsPrecedence.ClassExpression)
        ) {
          state.write('(');
          this[node.superClass.type](superClass, state);
          state.write(')');
        } else {
          this[superClass.type](superClass, state);
        }
        state.write(' ');
      }
      this.ClassBody(node.body, state);
    },
    ImportDeclaration(node, state) {
      state.write('import ');
      const { specifiers: specifiers, attributes: attributes } = node;
      const { length: length } = specifiers;
      let i = 0;
      if (length > 0) {
        for (; i < length; ) {
          if (i > 0) {
            state.write(', ');
          }
          const specifier = specifiers[i];
          const type = specifier.type[6];
          if (type === 'D') {
            state.write(specifier.local.name, specifier);
            i++;
          } else if (type === 'N') {
            state.write('* as ' + specifier.local.name, specifier);
            i++;
          } else {
            break;
          }
        }
        if (i < length) {
          state.write('{');
          for (;;) {
            const specifier = specifiers[i];
            const { name: name } = specifier.imported;
            state.write(name, specifier);
            if (name !== specifier.local.name) {
              state.write(' as ' + specifier.local.name);
            }
            if (++i < length) {
              state.write(', ');
            } else {
              break;
            }
          }
          state.write('}');
        }
        state.write(' from ');
      }
      this.Literal(node.source, state);
      if (attributes && attributes.length > 0) {
        state.write(' with { ');
        for (let i = 0; i < attributes.length; i++) {
          this.ImportAttribute(attributes[i], state);
          if (i < attributes.length - 1) state.write(', ');
        }
        state.write(' }');
      }
      state.write(';');
    },
    ImportAttribute(node, state) {
      this.Identifier(node.key, state);
      state.write(': ');
      this.Literal(node.value, state);
    },
    ImportExpression(node, state) {
      state.write('import(');
      this[node.source.type](node.source, state);
      state.write(')');
    },
    ExportDefaultDeclaration(node, state) {
      state.write('export default ');
      this[node.declaration.type](node.declaration, state);
      if (
        state.expressionsPrecedence[node.declaration.type] != null &&
        node.declaration.type[0] !== 'F'
      ) {
        state.write(';');
      }
    },
    ExportNamedDeclaration(node, state) {
      state.write('export ');
      if (node.declaration) {
        this[node.declaration.type](node.declaration, state);
      } else {
        state.write('{');
        const { specifiers: specifiers } = node,
          { length: length } = specifiers;
        if (length > 0) {
          for (let i = 0; ; ) {
            const specifier = specifiers[i];
            const { name: name } = specifier.local;
            state.write(name, specifier);
            if (name !== specifier.exported.name) {
              state.write(' as ' + specifier.exported.name);
            }
            if (++i < length) {
              state.write(', ');
            } else {
              break;
            }
          }
        }
        state.write('}');
        if (node.source) {
          state.write(' from ');
          this.Literal(node.source, state);
        }
        if (node.attributes && node.attributes.length > 0) {
          state.write(' with { ');
          for (let i = 0; i < node.attributes.length; i++) {
            this.ImportAttribute(node.attributes[i], state);
            if (i < node.attributes.length - 1) state.write(', ');
          }
          state.write(' }');
        }
        state.write(';');
      }
    },
    ExportAllDeclaration(node, state) {
      if (node.exported != null) {
        state.write('export * as ' + node.exported.name + ' from ');
      } else {
        state.write('export * from ');
      }
      this.Literal(node.source, state);
      if (node.attributes && node.attributes.length > 0) {
        state.write(' with { ');
        for (let i = 0; i < node.attributes.length; i++) {
          this.ImportAttribute(node.attributes[i], state);
          if (i < node.attributes.length - 1) state.write(', ');
        }
        state.write(' }');
      }
      state.write(';');
    },
    MethodDefinition(node, state) {
      if (node.static) {
        state.write('static ');
      }
      const kind = node.kind[0];
      if (kind === 'g' || kind === 's') {
        state.write(node.kind + ' ');
      }
      if (node.value.async) {
        state.write('async ');
      }
      if (node.value.generator) {
        state.write('*');
      }
      if (node.computed) {
        state.write('[');
        this[node.key.type](node.key, state);
        state.write(']');
      } else {
        this[node.key.type](node.key, state);
      }
      formatSequence(state, node.value.params);
      state.write(' ');
      this[node.value.body.type](node.value.body, state);
    },
    ClassExpression(node, state) {
      this.ClassDeclaration(node, state);
    },
    ArrowFunctionExpression(node, state) {
      state.write(node.async ? 'async ' : '', node);
      const { params: params } = node;
      if (params != null) {
        if (params.length === 1 && params[0].type[0] === 'I') {
          state.write(params[0].name, params[0]);
        } else {
          formatSequence(state, node.params);
        }
      }
      state.write(' => ');
      if (node.body.type[0] === 'O') {
        state.write('(');
        this.ObjectExpression(node.body, state);
        state.write(')');
      } else {
        this[node.body.type](node.body, state);
      }
    },
    ThisExpression(node, state) {
      state.write('this', node);
    },
    Super(node, state) {
      state.write('super', node);
    },
    RestElement: (RestElement = function (node, state) {
      state.write('...');
      this[node.argument.type](node.argument, state);
    }),
    SpreadElement: RestElement,
    YieldExpression(node, state) {
      state.write(node.delegate ? 'yield*' : 'yield');
      if (node.argument) {
        state.write(' ');
        this[node.argument.type](node.argument, state);
      }
    },
    AwaitExpression(node, state) {
      state.write('await ', node);
      formatExpression(state, node.argument, node);
    },
    TemplateLiteral(node, state) {
      const { quasis: quasis, expressions: expressions } = node;
      state.write('`');
      const { length: length } = expressions;
      for (let i = 0; i < length; i++) {
        const expression = expressions[i];
        const quasi = quasis[i];
        state.write(quasi.value.raw, quasi);
        state.write('${');
        this[expression.type](expression, state);
        state.write('}');
      }
      const quasi = quasis[quasis.length - 1];
      state.write(quasi.value.raw, quasi);
      state.write('`');
    },
    TemplateElement(node, state) {
      state.write(node.value.raw, node);
    },
    TaggedTemplateExpression(node, state) {
      formatExpression(state, node.tag, node);
      this[node.quasi.type](node.quasi, state);
    },
    ArrayExpression: (ArrayExpression = function (node, state) {
      state.write('[');
      if (node.elements.length > 0) {
        const { elements: elements } = node,
          { length: length } = elements;
        for (let i = 0; ; ) {
          const element = elements[i];
          if (element != null) {
            this[element.type](element, state);
          }
          if (++i < length) {
            state.write(', ');
          } else {
            if (element == null) {
              state.write(', ');
            }
            break;
          }
        }
      }
      state.write(']');
    }),
    ArrayPattern: ArrayExpression,
    ObjectExpression(node, state) {
      const indent = state.indent.repeat(state.indentLevel++);
      const { lineEnd: lineEnd, writeComments: writeComments } = state;
      const propertyIndent = indent + state.indent;
      state.write('{');
      if (node.properties.length > 0) {
        state.write(lineEnd);
        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, propertyIndent, lineEnd);
        }
        const comma = ',' + lineEnd;
        const { properties: properties } = node,
          { length: length } = properties;
        for (let i = 0; ; ) {
          const property = properties[i];
          if (writeComments && property.comments != null) {
            formatComments(state, property.comments, propertyIndent, lineEnd);
          }
          state.write(propertyIndent);
          this[property.type](property, state);
          if (++i < length) {
            state.write(comma);
          } else {
            break;
          }
        }
        state.write(lineEnd);
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        }
        state.write(indent + '}');
      } else if (writeComments) {
        if (node.comments != null) {
          state.write(lineEnd);
          formatComments(state, node.comments, propertyIndent, lineEnd);
          if (node.trailingComments != null) {
            formatComments(
              state,
              node.trailingComments,
              propertyIndent,
              lineEnd,
            );
          }
          state.write(indent + '}');
        } else if (node.trailingComments != null) {
          state.write(lineEnd);
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          state.write(indent + '}');
        } else {
          state.write('}');
        }
      } else {
        state.write('}');
      }
      state.indentLevel--;
    },
    Property(node, state) {
      if (node.method || node.kind[0] !== 'i') {
        this.MethodDefinition(node, state);
      } else {
        if (!node.shorthand) {
          if (node.computed) {
            state.write('[');
            this[node.key.type](node.key, state);
            state.write(']');
          } else {
            this[node.key.type](node.key, state);
          }
          state.write(': ');
        }
        this[node.value.type](node.value, state);
      }
    },
    PropertyDefinition(node, state) {
      if (node.static) {
        state.write('static ');
      }
      if (node.computed) {
        state.write('[');
      }
      this[node.key.type](node.key, state);
      if (node.computed) {
        state.write(']');
      }
      if (node.value == null) {
        if (node.key.type[0] !== 'F') {
          state.write(';');
        }
        return;
      }
      state.write(' = ');
      this[node.value.type](node.value, state);
      state.write(';');
    },
    ObjectPattern(node, state) {
      state.write('{');
      if (node.properties.length > 0) {
        const { properties: properties } = node,
          { length: length } = properties;
        for (let i = 0; ; ) {
          this[properties[i].type](properties[i], state);
          if (++i < length) {
            state.write(', ');
          } else {
            break;
          }
        }
      }
      state.write('}');
    },
    SequenceExpression(node, state) {
      formatSequence(state, node.expressions);
    },
    UnaryExpression(node, state) {
      if (node.prefix) {
        const {
          operator: operator,
          argument: argument,
          argument: { type: type },
        } = node;
        state.write(operator);
        const needsParentheses = expressionNeedsParenthesis(
          state,
          argument,
          node,
        );
        if (
          !needsParentheses &&
          (operator.length > 1 ||
            (type[0] === 'U' &&
              (type[1] === 'n' || type[1] === 'p') &&
              argument.prefix &&
              argument.operator[0] === operator &&
              (operator === '+' || operator === '-')))
        ) {
          state.write(' ');
        }
        if (needsParentheses) {
          state.write(operator.length > 1 ? ' (' : '(');
          this[type](argument, state);
          state.write(')');
        } else {
          this[type](argument, state);
        }
      } else {
        this[node.argument.type](node.argument, state);
        state.write(node.operator);
      }
    },
    UpdateExpression(node, state) {
      if (node.prefix) {
        state.write(node.operator);
        this[node.argument.type](node.argument, state);
      } else {
        this[node.argument.type](node.argument, state);
        state.write(node.operator);
      }
    },
    AssignmentExpression(node, state) {
      this[node.left.type](node.left, state);
      state.write(' ' + node.operator + ' ');
      this[node.right.type](node.right, state);
    },
    AssignmentPattern(node, state) {
      this[node.left.type](node.left, state);
      state.write(' = ');
      this[node.right.type](node.right, state);
    },
    BinaryExpression: (BinaryExpression = function (node, state) {
      const isIn = node.operator === 'in';
      if (isIn) {
        state.write('(');
      }
      formatExpression(state, node.left, node, false);
      state.write(' ' + node.operator + ' ');
      formatExpression(state, node.right, node, true);
      if (isIn) {
        state.write(')');
      }
    }),
    LogicalExpression: BinaryExpression,
    ConditionalExpression(node, state) {
      const { test: test } = node;
      const precedence = state.expressionsPrecedence[test.type];
      if (
        precedence === NEEDS_PARENTHESES ||
        precedence <= state.expressionsPrecedence.ConditionalExpression
      ) {
        state.write('(');
        this[test.type](test, state);
        state.write(')');
      } else {
        this[test.type](test, state);
      }
      state.write(' ? ');
      this[node.consequent.type](node.consequent, state);
      state.write(' : ');
      this[node.alternate.type](node.alternate, state);
    },
    NewExpression(node, state) {
      state.write('new ');
      const precedence = state.expressionsPrecedence[node.callee.type];
      if (
        precedence === NEEDS_PARENTHESES ||
        precedence < state.expressionsPrecedence.CallExpression ||
        hasCallExpression(node.callee)
      ) {
        state.write('(');
        this[node.callee.type](node.callee, state);
        state.write(')');
      } else {
        this[node.callee.type](node.callee, state);
      }
      formatSequence(state, node['arguments']);
    },
    CallExpression(node, state) {
      const precedence = state.expressionsPrecedence[node.callee.type];
      if (
        precedence === NEEDS_PARENTHESES ||
        precedence < state.expressionsPrecedence.CallExpression
      ) {
        state.write('(');
        this[node.callee.type](node.callee, state);
        state.write(')');
      } else {
        this[node.callee.type](node.callee, state);
      }
      if (node.optional) {
        state.write('?.');
      }
      formatSequence(state, node['arguments']);
    },
    ChainExpression(node, state) {
      this[node.expression.type](node.expression, state);
    },
    MemberExpression(node, state) {
      const precedence = state.expressionsPrecedence[node.object.type];
      if (
        precedence === NEEDS_PARENTHESES ||
        precedence < state.expressionsPrecedence.MemberExpression
      ) {
        state.write('(');
        this[node.object.type](node.object, state);
        state.write(')');
      } else {
        this[node.object.type](node.object, state);
      }
      if (node.computed) {
        if (node.optional) {
          state.write('?.');
        }
        state.write('[');
        this[node.property.type](node.property, state);
        state.write(']');
      } else {
        if (node.optional) {
          state.write('?.');
        } else {
          state.write('.');
        }
        this[node.property.type](node.property, state);
      }
    },
    MetaProperty(node, state) {
      state.write(node.meta.name + '.' + node.property.name, node);
    },
    Identifier(node, state) {
      state.write(node.name, node);
    },
    PrivateIdentifier(node, state) {
      state.write(`#${node.name}`, node);
    },
    Literal(node, state) {
      if (node.raw != null) {
        state.write(node.raw, node);
      } else if (node.regex != null) {
        this.RegExpLiteral(node, state);
      } else if (node.bigint != null) {
        state.write(node.bigint + 'n', node);
      } else {
        state.write(stringify(node.value), node);
      }
    },
    RegExpLiteral(node, state) {
      const { regex: regex } = node;
      state.write(`/${regex.pattern}/${regex.flags}`, node);
    },
  };
  const EMPTY_OBJECT = {};
  class State {
    constructor(options) {
      const setup = options == null ? EMPTY_OBJECT : options;
      this.output = '';
      if (setup.output != null) {
        this.output = setup.output;
        this.write = this.writeToStream;
      } else {
        this.output = '';
      }
      this.generator = setup.generator != null ? setup.generator : GENERATOR;
      this.expressionsPrecedence =
        setup.expressionsPrecedence != null
          ? setup.expressionsPrecedence
          : EXPRESSIONS_PRECEDENCE;
      this.indent = setup.indent != null ? setup.indent : '  ';
      this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\n';
      this.indentLevel =
        setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
      this.writeComments = setup.comments ? setup.comments : false;
      if (setup.sourceMap != null) {
        this.write =
          setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
        this.sourceMap = setup.sourceMap;
        this.line = 1;
        this.column = 0;
        this.lineEndSize = this.lineEnd.split('\n').length - 1;
        this.mapping = {
          original: null,
          generated: this,
          name: undefined,
          source: setup.sourceMap.file || setup.sourceMap._file,
        };
      }
    }
    write(code) {
      this.output += code;
    }
    writeToStream(code) {
      this.output.write(code);
    }
    writeAndMap(code, node) {
      this.output += code;
      this.map(code, node);
    }
    writeToStreamAndMap(code, node) {
      this.output.write(code);
      this.map(code, node);
    }
    map(code, node) {
      if (node != null) {
        const { type: type } = node;
        if (type[0] === 'L' && type[2] === 'n') {
          this.column = 0;
          this.line++;
          return;
        }
        if (node.loc != null) {
          const { mapping: mapping } = this;
          mapping.original = node.loc.start;
          mapping.name = node.name;
          this.sourceMap.addMapping(mapping);
        }
        if (
          (type[0] === 'T' && type[8] === 'E') ||
          (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')
        ) {
          const { length: length } = code;
          let { column: column, line: line } = this;
          for (let i = 0; i < length; i++) {
            if (code[i] === '\n') {
              column = 0;
              line++;
            } else {
              column++;
            }
          }
          this.column = column;
          this.line = line;
          return;
        }
      }
      const { length: length } = code;
      const { lineEnd: lineEnd } = this;
      if (length > 0) {
        if (
          this.lineEndSize > 0 &&
          (lineEnd.length === 1
            ? code[length - 1] === lineEnd
            : code.endsWith(lineEnd))
        ) {
          this.line += this.lineEndSize;
          this.column = 0;
        } else {
          this.column += length;
        }
      }
    }
    toString() {
      return this.output;
    }
  }
  function generate(node, options) {
    const state = new State(options);
    state.generator[node.type](node, state);
    return state.output;
  }
  const meriyah = { parse: parse };
  const astring = { generate: generate };
  exports.astring = astring;
  exports.meriyah = meriyah;
  return exports;
})({});
